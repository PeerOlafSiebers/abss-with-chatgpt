[
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Transportation - Ride-sharing Platform. Classes involved are User, Driver, Rider, Ride, and Payment.",
        "output": "classDiagram\n            User <|-- Driver : inherits\n            User <|-- Rider : inherits\n            Ride -- Rider : requests\n            Ride -- Driver : fulfills\n            Payment -- Rider : makes\n            Payment -- Driver : receives\n\n            class User {\n              +string name\n              +string email\n            }\n\n            class Driver {\n              +string licenseNumber\n              +string vehicleDetails\n              +void acceptRide(Ride)\n            }\n\n            class Rider {\n              +string paymentMethod\n              +void requestRide(location, destination)\n            }\n\n            class Ride {\n              +string pickupLocation\n              +string dropLocation\n              +float fare\n            }\n\n            class Payment {\n              +float amount\n              +string method\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Education - Online Learning Platform. Classes involved are User, Instructor, Student, Course, Quiz, and Assignment.",
        "output": "classDiagram\n            User <|-- Instructor : inherits\n            User <|-- Student : inherits\n            Course -- Instructor : created_by\n            Course -- Student : enrolled_in\n            Quiz -- Course : part_of\n            Assignment -- Course : part_of\n\n            class User {\n              +string name\n              +string email\n            }\n\n            class Instructor {\n              +string specialization\n              +void createCourse(Course)\n            }\n\n            class Student {\n              +string major\n              +void enrollCourse(Course)\n            }\n\n            class Course {\n              +string title\n              +string description\n            }\n\n            class Quiz {\n              +string questions\n              +void evaluateAnswers()\n            }\n\n            class Assignment {\n              +string title\n              +string instructions\n              +void submit()\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Medicine - Hospital Management System. Classes involved are Person, Patient, Doctor, Appointment, and Prescription.",
        "output": "classDiagram\n            Person <|-- Patient : inherits\n            Person <|-- Doctor : inherits\n            Appointment -- Patient : booked_by\n            Appointment -- Doctor : attended_by\n            Prescription -- Doctor : issued_by\n            Prescription -- Patient : prescribed_to\n\n            class Person {\n              +string name\n              +string contactInfo\n            }\n\n            class Patient {\n              +string medicalHistory\n              +void bookAppointment(Doctor)\n            }\n\n            class Doctor {\n              +string specialization\n              +void diagnose(Patient)\n            }\n\n            class Appointment {\n              +string date\n              +string time\n              +string reason\n            }\n\n            class Prescription {\n              +string medication\n              +int dosage\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Finance - Banking System. Classes involved are AccountHolder, Customer, Account, Transaction, and Loan.",
        "output": "classDiagram\n            AccountHolder <|-- Customer : inherits\n            Account -- Customer : belongs_to\n            Transaction -- Account : linked_to\n            Loan -- Customer : granted_to\n\n            class AccountHolder {\n              +string name\n              +string address\n            }\n\n            class Customer {\n              +string accountNumber\n              +void deposit(float)\n              +void withdraw(float)\n            }\n\n            class Account {\n              +float balance\n              +string type\n            }\n\n            class Transaction {\n              +float amount\n              +string date\n              +string type\n            }\n\n            class Loan {\n              +float amount\n              +float interestRate\n              +void applyForLoan()\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Epidemiology - Disease Outbreak Tracking. Classes involved are Disease, Virus, Bacteria, Outbreak, Patient, and Report.",
        "output": "classDiagram\n            Disease <|-- Virus : inherits\n            Disease <|-- Bacteria : inherits\n            Outbreak -- Disease : related_to\n            Patient -- Outbreak : involved_in\n            Report -- Outbreak : describes\n\n            class Disease {\n              +string name\n              +string symptoms\n            }\n\n            class Virus {\n              +string rnaSequence\n              +void mutate()\n            }\n\n            class Bacteria {\n              +string dnaSequence\n              +void mutate()\n            }\n\n            class Outbreak {\n              +string location\n              +int numberOfCases\n              +void trackSpread()\n            }\n\n            class Patient {\n              +string name\n              +int age\n              +string status\n            }\n\n            class Report {\n              +string date\n              +string findings\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Social Science - Demographic Survey System. Classes involved are Respondent, Survey, Question, and Response.",
        "output": "classDiagram\n            Respondent -- Survey : participates_in\n            Survey -- Question : contains\n            Response -- Respondent : given_by\n\n            class Respondent {\n              +string name\n              +int age\n              +string gender\n            }\n\n            class Survey {\n              +string title\n              +string description\n              +void distribute()\n            }\n\n            class Question {\n              +string text\n              +string type\n            }\n\n            class Response {\n              +string answer\n              +date dateGiven\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Organization - Human Resource Management System. Classes involved are Employee, Manager, Staff, Department, Task, and PerformanceReview.",
        "output": "classDiagram\n            Employee <|-- Manager : inherits\n            Employee <|-- Staff : inherits\n            Department -- Employee : part_of\n            Task -- Employee : assigned_to\n            PerformanceReview -- Employee : for\n\n            class Employee {\n              +string name\n              +string id\n              +string position\n            }\n\n            class Manager {\n              +string department\n              +void assignTask(Task)\n            }\n\n            class Staff {\n              +string role\n              +void completeTask(Task)\n            }\n\n            class Department {\n              +string name\n              +string location\n            }\n\n            class Task {\n              +string title\n              +string description\n              +date dueDate\n            }\n\n            class PerformanceReview {\n              +string reviewer\n              +string comments\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Disaster Planning - Emergency Response System. Classes involved are Emergency, ResponseTeam, Member, Resource, and IncidentReport.",
        "output": "classDiagram\n            Emergency -- ResponseTeam : managed_by\n            ResponseTeam -- Member : consists_of\n            Resource -- ResponseTeam : allocated_to\n            IncidentReport -- Emergency : triggers\n\n            class Emergency {\n              +string type\n              +string location\n              +date dateReported\n            }\n\n            class ResponseTeam {\n              +string name\n              +string specialization\n            }\n\n            class Member {\n              +string name\n              +string role\n            }\n\n            class Resource {\n              +string name\n              +int quantity\n              +void allocate()\n            }\n\n            class IncidentReport {\n              +string description\n              +string status\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Tourism - Travel Booking Platform. Classes involved are User, Traveler, Agent, Booking, and Destination.",
        "output": "classDiagram\n            User <|-- Traveler : inherits\n            User <|-- Agent : inherits\n            Booking -- Traveler : made_by\n            Booking -- Agent : managed_by\n            Destination -- Booking : linked_to\n\n            class User {\n              +string name\n              +string email\n            }\n\n            class Traveler {\n              +string preferences\n              +void bookTrip(Destination)\n            }\n\n            class Agent {\n              +string agency\n              +void manageBooking(Booking)\n            }\n\n            class Booking {\n              +date startDate\n              +date endDate\n              +float price\n            }\n\n            class Destination {\n              +string name\n              +string description\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Marketing - Digital Campaign Management. Classes involved are Campaign, Manager, Ad, Audience, and Platform.",
        "output": "classDiagram\n            Campaign -- Manager : organized_by\n            Campaign -- Ad : contains\n            Audience -- Campaign : targeted_by\n            Platform -- Ad : displayed_on\n\n            class Campaign {\n              +string title\n              +float budget\n              +void launch()\n            }\n\n            class Manager {\n              +string name\n              +string department\n              +void planCampaign()\n            }\n\n            class Ad {\n              +string content\n              +date startDate\n              +date endDate\n            }\n\n            class Audience {\n              +string demographics\n              +string interests\n            }\n\n            class Platform {\n              +string name\n              +string type\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Business - Inventory Management System. Classes involved are Product, Inventory, Supplier, Order, and Shipment.",
        "output": "classDiagram\n            Product -- Inventory : stored_in\n            Supplier -- Product : provides\n            Order -- Product : contains\n            Shipment -- Order : fulfills\n\n            class Product {\n              +string name\n              +float price\n              +int quantity\n            }\n\n            class Inventory {\n              +string location\n              +int capacity\n              +void checkStock()\n            }\n\n            class Supplier {\n              +string name\n              +string contactInfo\n            }\n\n            class Order {\n              +date orderDate\n              +float totalAmount\n            }\n\n            class Shipment {\n              +date shipmentDate\n              +string carrier\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Healthcare - Telemedicine Platform. Classes involved are Patient, Doctor, Consultation, Prescription, and MedicalRecord.",
        "output": "classDiagram\n            Patient -- Consultation : requests\n            Doctor -- Consultation : provides\n            Prescription -- Consultation : issued_for\n            MedicalRecord -- Patient : contains\n\n            class Patient {\n              +string name\n              +string contactInfo\n              +void requestConsultation(Doctor)\n            }\n\n            class Doctor {\n              +string name\n              +string specialization\n              +void provideConsultation(Patient)\n            }\n\n            class Consultation {\n              +date date\n              +string notes\n            }\n\n            class Prescription {\n              +string medication\n              +int dosage\n            }\n\n            class MedicalRecord {\n              +string history\n              +string allergies\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Real Estate - Property Management System. Classes involved are Property, Owner, Tenant, Lease, and MaintenanceRequest.",
        "output": "classDiagram\n            Property -- Owner : belongs_to\n            Tenant -- Property : rents\n            Lease -- Tenant : signed_by\n            MaintenanceRequest -- Property : related_to\n\n            class Property {\n              +string address\n              +float value\n            }\n\n            class Owner {\n              +string name\n              +string contactInfo\n            }\n\n            class Tenant {\n              +string name\n              +string rentalHistory\n            }\n\n            class Lease {\n              +date startDate\n              +date endDate\n              +float rentAmount\n            }\n\n            class MaintenanceRequest {\n              +string issue\n              +date requestDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Logistics - Supply Chain Management. Classes involved are Supplier, RawMaterial, Manufacturer, Product, Distributor, and Retailer.",
        "output": "classDiagram\n            Supplier -- RawMaterial : supplies\n            Manufacturer -- Product : produces\n            Distributor -- Product : distributes\n            Retailer -- Product : sells\n\n            class Supplier {\n              +string name\n              +string location\n            }\n\n            class RawMaterial {\n              +string type\n              +float quantity\n            }\n\n            class Manufacturer {\n              +string name\n              +string location\n            }\n\n            class Product {\n              +string name\n              +float price\n            }\n\n            class Distributor {\n              +string name\n              +string region\n            }\n\n            class Retailer {\n              +string name\n              +string location\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Construction - Project Management System. Classes involved are Project, Manager, Task, Resource, and Contractor.",
        "output": "classDiagram\n            Project -- Manager : managed_by\n            Task -- Project : part_of\n            Resource -- Task : used_in\n            Contractor -- Project : hired_by\n\n            class Project {\n              +string name\n              +float budget\n              +date deadline\n            }\n\n            class Manager {\n              +string name\n              +string experience\n            }\n\n            class Task {\n              +string description\n              +date startDate\n              +date endDate\n            }\n\n            class Resource {\n              +string type\n              +int quantity\n            }\n\n            class Contractor {\n              +string name\n              +string specialty\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Retail - E-commerce Platform. Classes involved are Customer, Order, Product, Payment, and Delivery.",
        "output": "classDiagram\n            Customer -- Order : places\n            Product -- Order : included_in\n            Payment -- Order : linked_to\n            Delivery -- Order : associated_with\n\n            class Customer {\n              +string name\n              +string email\n            }\n\n            class Order {\n              +date orderDate\n              +float totalPrice\n            }\n\n            class Product {\n              +string name\n              +float price\n              +int stock\n            }\n\n            class Payment {\n              +string method\n              +float amount\n            }\n\n            class Delivery {\n              +string address\n              +date deliveryDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Energy - Power Grid Management. Classes involved are PowerPlant, Grid, Substation, Consumer, and OutageReport.",
        "output": "classDiagram\n            PowerPlant -- Grid : connected_to\n            Substation -- Grid : part_of\n            Consumer -- Grid : served_by\n            OutageReport -- Grid : related_to\n\n            class PowerPlant {\n              +string name\n              +float capacity\n            }\n\n            class Grid {\n              +string region\n              +int numberOfConsumers\n            }\n\n            class Substation {\n              +string name\n              +string location\n            }\n\n            class Consumer {\n              +string name\n              +string address\n            }\n\n            class OutageReport {\n              +string description\n              +date reportedDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Insurance - Policy Management System. Classes involved are Policy, Customer, Claim, Agent, and Payment.",
        "output": "classDiagram\n            Policy -- Customer : held_by\n            Claim -- Policy : associated_with\n            Agent -- Customer : assigned_to\n            Payment -- Policy : linked_to\n\n            class Policy {\n              +string policyNumber\n              +float coverageAmount\n            }\n\n            class Customer {\n              +string name\n              +string contactInfo\n            }\n\n            class Claim {\n              +string claimNumber\n              +float claimAmount\n            }\n\n            class Agent {\n              +string name\n              +string region\n            }\n\n            class Payment {\n              +float amount\n              +date dueDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Manufacturing - Factory Automation System. Classes involved are Machine, ProductionLine, Sensor, Operator, and MaintenanceSchedule.",
        "output": "classDiagram\n            Machine -- ProductionLine : part_of\n            Sensor -- Machine : monitors\n            Operator -- Machine : oversees\n            MaintenanceSchedule -- Machine : linked_to\n\n            class Machine {\n              +string id\n              +string type\n              +float outputCapacity\n            }\n\n            class ProductionLine {\n              +string name\n              +int numberOfMachines\n            }\n\n            class Sensor {\n              +string sensorType\n              +void monitor()\n            }\n\n            class Operator {\n              +string name\n              +string shift\n            }\n\n            class MaintenanceSchedule {\n              +date date\n              +string tasks\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Agriculture - Farm Management System. Classes involved are Farm, Crop, Farmer, Equipment, and Harvest.",
        "output": "classDiagram\n            Farm -- Crop : grows\n            Farmer -- Farm : owns\n            Equipment -- Farm : used_in\n            Harvest -- Crop : related_to\n\n            class Farm {\n              +string name\n              +float area\n            }\n\n            class Crop {\n              +string name\n              +string season\n            }\n\n            class Farmer {\n              +string name\n              +int experience\n            }\n\n            class Equipment {\n              +string name\n              +string type\n            }\n\n            class Harvest {\n              +date date\n              +float yield\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Environmental Management - Forest Conservation. Classes involved are Forest, Ranger, Animal, Threat, and ConservationPlan.",
        "output": "classDiagram\n            Forest -- Ranger : protected_by\n            Animal -- Forest : lives_in\n            Threat -- Forest : endangers\n            ConservationPlan -- Forest : applies_to\n\n            class Forest {\n              +string name\n              +float area\n              +string location\n            }\n\n            class Ranger {\n              +string name\n              +string station\n              +void patrol()\n            }\n\n            class Animal {\n              +string species\n              +int population\n            }\n\n            class Threat {\n              +string type\n              +string description\n            }\n\n            class ConservationPlan {\n              +string name\n              +date startDate\n              +date endDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Media - Streaming Platform. Classes involved are User, Subscriber, Subscription, Content, and Genre.",
        "output": "classDiagram\n            User <|-- Subscriber : inherits\n            Subscription -- Subscriber : linked_to\n            Content -- Subscription : accesses\n            Genre -- Content : categorized_by\n\n            class User {\n              +string name\n              +string email\n            }\n\n            class Subscriber {\n              +date subscriptionDate\n              +void renewSubscription()\n            }\n\n            class Subscription {\n              +float monthlyFee\n              +string type\n            }\n\n            class Content {\n              +string title\n              +date releaseDate\n            }\n\n            class Genre {\n              +string name\n              +string description\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Transportation - Public Transit System. Classes involved are Vehicle, Route, Driver, Passenger, and Ticket.",
        "output": "classDiagram\n            Vehicle -- Route : operates_on\n            Driver -- Vehicle : drives\n            Passenger -- Vehicle : rides\n            Ticket -- Passenger : purchased_by\n\n            class Vehicle {\n              +string type\n              +string id\n              +int capacity\n            }\n\n            class Route {\n              +string name\n              +string startPoint\n              +string endPoint\n            }\n\n            class Driver {\n              +string name\n              +string license\n              +void operate()\n            }\n\n            class Passenger {\n              +string name\n              +string ticketNumber\n            }\n\n            class Ticket {\n              +float price\n              +date dateOfTravel\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Technology - Software Development Lifecycle. Classes involved are Developer, Task, Feature, Project, and BugReport.",
        "output": "classDiagram\n            Developer -- Task : assigned_to\n            Task -- Feature : implements\n            Feature -- Project : part_of\n            BugReport -- Task : related_to\n\n            class Developer {\n              +string name\n              +string role\n            }\n\n            class Task {\n              +string title\n              +date dueDate\n              +string status\n            }\n\n            class Feature {\n              +string name\n              +string description\n            }\n\n            class Project {\n              +string name\n              +date startDate\n              +date endDate\n            }\n\n            class BugReport {\n              +string description\n              +date reportedDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Education - University Admission System. Classes involved are Applicant, Application, Program, Department, and AdmissionReview.",
        "output": "classDiagram\n            Applicant -- Application : submits\n            Application -- Program : applies_to\n            Program -- Department : part_of\n            AdmissionReview -- Application : evaluated_by\n\n            class Applicant {\n              +string name\n              +string email\n              +string qualifications\n            }\n\n            class Application {\n              +date submissionDate\n              +string status\n            }\n\n            class Program {\n              +string name\n              +string level\n            }\n\n            class Department {\n              +string name\n              +string faculty\n            }\n\n            class AdmissionReview {\n              +string reviewer\n              +string comments\n              +date reviewDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Finance - Stock Trading Platform. Classes involved are Trader, Portfolio, Stock, Trade, and Market.",
        "output": "classDiagram\n            Trader -- Portfolio : manages\n            Stock -- Portfolio : included_in\n            Trade -- Stock : executed_on\n            Market -- Stock : listed_on\n\n            class Trader {\n              +string name\n              +string accountNumber\n              +void placeOrder()\n            }\n\n            class Portfolio {\n              +string id\n              +float totalValue\n            }\n\n            class Stock {\n              +string tickerSymbol\n              +float currentPrice\n            }\n\n            class Trade {\n              +string type\n              +int quantity\n              +date tradeDate\n            }\n\n            class Market {\n              +string name\n              +string location\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Healthcare - Patient Portal System. Classes involved are Patient, Appointment, Doctor, LabResult, and MedicalRecord.",
        "output": "classDiagram\n            Patient -- Appointment : schedules\n            Doctor -- Appointment : attends\n            LabResult -- Patient : linked_to\n            MedicalRecord -- Patient : associated_with\n\n            class Patient {\n              +string name\n              +string dob\n              +string contactInfo\n            }\n\n            class Appointment {\n              +date appointmentDate\n              +string reason\n            }\n\n            class Doctor {\n              +string name\n              +string specialization\n            }\n\n            class LabResult {\n              +string testName\n              +string result\n              +date testDate\n            }\n\n            class MedicalRecord {\n              +string recordNumber\n              +string history\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Logistics - Warehouse Management System. Classes involved are Product, Warehouse, Inventory, Shipment, and Supplier.",
        "output": "classDiagram\n            Product -- Warehouse : stored_in\n            Inventory -- Product : tracks\n            Shipment -- Warehouse : dispatched_from\n            Supplier -- Product : delivers_to\n\n            class Product {\n              +string name\n              +string sku\n              +int quantity\n            }\n\n            class Warehouse {\n              +string name\n              +string location\n            }\n\n            class Inventory {\n              +int stockLevel\n              +date lastUpdated\n            }\n\n            class Shipment {\n              +string trackingNumber\n              +date shipmentDate\n            }\n\n            class Supplier {\n              +string name\n              +string contactInfo\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Transportation - Fleet Management System. Classes involved are Vehicle, Fleet, FleetManager, MaintenanceRecord, and Driver.",
        "output": "classDiagram\n            Vehicle -- Fleet : belongs_to\n            FleetManager -- Fleet : manages\n            MaintenanceRecord -- Vehicle : associated_with\n            Driver -- Vehicle : assigned_to\n\n            class Vehicle {\n              +string vin\n              +string make\n              +string model\n            }\n\n            class Fleet {\n              +string name\n              +int numberOfVehicles\n            }\n\n            class FleetManager {\n              +string name\n              +string contactInfo\n            }\n\n            class MaintenanceRecord {\n              +date maintenanceDate\n              +string details\n            }\n\n            class Driver {\n              +string name\n              +string licenseNumber\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Education - School Management System. Classes involved are Teacher, Class, Student, Assignment, and Grade.",
        "output": "classDiagram\n            Teacher -- Class : teaches\n            Student -- Class : attends\n            Assignment -- Class : assigned_by\n            Grade -- Assignment : linked_to\n\n            class Teacher {\n              +string name\n              +string subject\n            }\n\n            class Class {\n              +string name\n              +string gradeLevel\n            }\n\n            class Student {\n              +string name\n              +int age\n            }\n\n            class Assignment {\n              +string title\n              +date dueDate\n            }\n\n            class Grade {\n              +float score\n              +string feedback\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Retail - Point of Sale System. Classes involved are Cashier, Transaction, Product, Receipt, and Customer.",
        "output": "classDiagram\n            Cashier -- Transaction : processes\n            Product -- Transaction : sold_in\n            Receipt -- Transaction : generated_by\n            Customer -- Transaction : associated_with\n\n            class Cashier {\n              +string name\n              +string employeeId\n            }\n\n            class Transaction {\n              +date date\n              +float totalAmount\n            }\n\n            class Product {\n              +string name\n              +float price\n            }\n\n            class Receipt {\n              +string receiptNumber\n              +date dateOfIssue\n            }\n\n            class Customer {\n              +string name\n              +string loyaltyCardNumber\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Social Media - User Interaction System. Classes involved are User, Post, Comment, Like, and FriendRequest.",
        "output": "classDiagram\n            User -- Post : creates\n            Post -- Comment : receives\n            Like -- Post : related_to\n            FriendRequest -- User : sends_to\n\n            class User {\n              +string username\n              +string email\n              +date dateJoined\n            }\n\n            class Post {\n              +string content\n              +date dateCreated\n            }\n\n            class Comment {\n              +string content\n              +date datePosted\n            }\n\n            class Like {\n              +string type\n              +date dateLiked\n            }\n\n            class FriendRequest {\n              +date dateSent\n              +string status\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Tourism - Hotel Management System. Classes involved are Guest, Reservation, Room, Service, and Invoice.",
        "output": "classDiagram\n            Guest -- Reservation : makes\n            Room -- Reservation : associated_with\n            Service -- Room : offered_in\n            Invoice -- Reservation : generated_for\n\n            class Guest {\n              +string name\n              +string contactInfo\n            }\n\n            class Reservation {\n              +date checkInDate\n              +date checkOutDate\n            }\n\n            class Room {\n              +string roomNumber\n              +string type\n              +float rate\n            }\n\n            class Service {\n              +string name\n              +float cost\n            }\n\n            class Invoice {\n              +string invoiceNumber\n              +float totalAmount\n              +date issueDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Real Estate - Rental Application System. Classes involved are Applicant, Application, Property, Landlord, and Lease.",
        "output": "classDiagram\n            Applicant -- Application : submits\n            Application -- Property : applies_to\n            Landlord -- Property : owns\n            Lease -- Application : results_in\n\n            class Applicant {\n              +string name\n              +string contactInfo\n              +string employmentStatus\n            }\n\n            class Application {\n              +date submissionDate\n              +string status\n            }\n\n            class Property {\n              +string address\n              +float rentalPrice\n            }\n\n            class Landlord {\n              +string name\n              +string contactInfo\n            }\n\n            class Lease {\n              +date startDate\n              +date endDate\n              +float monthlyRent\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Healthcare - Pharmacy Management System. Classes involved are Pharmacist, Prescription, Medication, Patient, and Inventory.",
        "output": "classDiagram\n            Pharmacist -- Prescription : fills\n            Prescription -- Medication : contains\n            Patient -- Prescription : prescribed_to\n            Inventory -- Medication : tracks\n\n            class Pharmacist {\n              +string name\n              +string licenseNumber\n            }\n\n            class Prescription {\n              +date issueDate\n              +string dosageInstructions\n            }\n\n            class Medication {\n              +string name\n              +string type\n              +int quantity\n            }\n\n            class Patient {\n              +string name\n              +string contactInfo\n            }\n\n            class Inventory {\n              +string location\n              +int stockLevel\n              +date lastUpdated\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Business - Customer Relationship Management. Classes involved are Customer, Interaction, SalesRep, Product, and Feedback.",
        "output": "classDiagram\n            Customer -- Interaction : engages_in\n            SalesRep -- Interaction : manages\n            Product -- Interaction : discusses\n            Feedback -- Interaction : results_in\n\n            class Customer {\n              +string name\n              +string contactInfo\n              +string customerId\n            }\n\n            class Interaction {\n              +date interactionDate\n              +string type\n              +string notes\n            }\n\n            class SalesRep {\n              +string name\n              +string email\n              +string employeeId\n            }\n\n            class Product {\n              +string name\n              +float price\n              +string sku\n            }\n\n            class Feedback {\n              +string content\n              +int rating\n              +date feedbackDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Education - Course Management System. Classes involved are Instructor, Course, Student, CourseMaterial, and Grade.",
        "output": "classDiagram\n            Instructor -- Course : teaches\n            Student -- Course : enrolls_in\n            CourseMaterial -- Course : included_in\n            Grade -- Student : assigned_for\n\n            class Instructor {\n              +string name\n              +string department\n            }\n\n            class Course {\n              +string title\n              +string description\n              +int credits\n            }\n\n            class Student {\n              +string name\n              +string major\n              +string studentId\n            }\n\n            class CourseMaterial {\n              +string title\n              +string format\n              +date publicationDate\n            }\n\n            class Grade {\n              +string courseTitle\n              +float score\n              +string letterGrade\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Finance - Accounting Software System. Classes involved are Accountant, Transaction, Account, Invoice, and Payment.",
        "output": "classDiagram\n            Accountant -- Transaction : records\n            Transaction -- Account : affects\n            Invoice -- Transaction : linked_to\n            Payment -- Invoice : associated_with\n\n            class Accountant {\n              +string name\n              +string certification\n            }\n\n            class Transaction {\n              +date transactionDate\n              +float amount\n              +string type\n            }\n\n            class Account {\n              +string name\n              +float balance\n            }\n\n            class Invoice {\n              +string invoiceNumber\n              +date issueDate\n              +float totalAmount\n            }\n\n            class Payment {\n              +string method\n              +date paymentDate\n              +float amount\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Environmental Management - Waste Management System. Classes involved are Household, WasteBin, WasteTruck, WasteFacility, and RecyclableMaterial.",
        "output": "classDiagram\n            Household -- WasteBin : uses\n            WasteBin -- WasteTruck : collected_by\n            WasteTruck -- WasteFacility : delivers_to\n            RecyclableMaterial -- WasteFacility : processed_at\n\n            class Household {\n              +string address\n              +int numberOfResidents\n            }\n\n            class WasteBin {\n              +string binType\n              +float capacity\n            }\n\n            class WasteTruck {\n              +string truckId\n              +string driverName\n            }\n\n            class WasteFacility {\n              +string name\n              +string location\n              +string facilityType\n            }\n\n            class RecyclableMaterial {\n              +string materialType\n              +float quantity\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Technology - IT Support Ticketing System. Classes involved are User, Ticket, ITSupport, Category, and Resolution.",
        "output": "classDiagram\n            User -- Ticket : raises\n            ITSupport -- Ticket : resolves\n            Category -- Ticket : categorized_in\n            Resolution -- Ticket : linked_to\n\n            class User {\n              +string name\n              +string department\n              +string userId\n            }\n\n            class Ticket {\n              +string ticketNumber\n              +date issueDate\n              +string status\n            }\n\n            class ITSupport {\n              +string name\n              +string specialization\n              +string supportLevel\n            }\n\n            class Category {\n              +string name\n              +string description\n            }\n\n            class Resolution {\n              +string resolutionDetails\n              +date resolutionDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Marketing - Social Media Analytics. Classes involved are Campaign, Post, Metric, Report, and Analyst.",
        "output": "classDiagram\n            Campaign -- Post : includes\n            Post -- Metric : generates\n            Metric -- Report : summarized_in\n            Analyst -- Report : interprets\n\n            class Campaign {\n              +string name\n              +date startDate\n              +date endDate\n              +float budget\n            }\n\n            class Post {\n              +string content\n              +date postDate\n              +int engagement\n            }\n\n            class Metric {\n              +string name\n              +int value\n            }\n\n            class Report {\n              +string title\n              +date reportDate\n            }\n\n            class Analyst {\n              +string name\n              +string role\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Transportation - Shipping Logistics. Classes involved are Shipment, Container, Item, Ship, and Port.",
        "output": "classDiagram\n            Shipment -- Container : includes\n            Container -- Item : stores\n            Ship -- Shipment : carries\n            Port -- Ship : docks_at\n\n            class Shipment {\n              +string shipmentId\n              +date departureDate\n              +date arrivalDate\n            }\n\n            class Container {\n              +string containerId\n              +float weight\n              +float volume\n            }\n\n            class Item {\n              +string itemName\n              +float weight\n              +int quantity\n            }\n\n            class Ship {\n              +string shipName\n              +string capacity\n            }\n\n            class Port {\n              +string portName\n              +string location\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Tourism - Tour Management System. Classes involved are TourGuide, Tour, Tourist, Booking, and Itinerary.",
        "output": "classDiagram\n            TourGuide -- Tour : leads\n            Tourist -- Tour : participates_in\n            Booking -- Tour : associated_with\n            Itinerary -- Tour : follows\n\n            class TourGuide {\n              +string name\n              +string language\n            }\n\n            class Tour {\n              +string tourName\n              +date startDate\n              +date endDate\n            }\n\n            class Tourist {\n              +string name\n              +string nationality\n            }\n\n            class Booking {\n              +string bookingId\n              +date bookingDate\n              +float totalCost\n            }\n\n            class Itinerary {\n              +string location\n              +date visitDate\n              +string description\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Finance - Budget Management System. Classes involved are Budget, Expense, Category, Report, and Manager.",
        "output": "classDiagram\n            Budget -- Expense : includes\n            Expense -- Category : categorized_in\n            Report -- Budget : summarizes\n            Manager -- Budget : oversees\n\n            class Budget {\n              +string budgetId\n              +float totalAmount\n              +date startDate\n              +date endDate\n            }\n\n            class Expense {\n              +string expenseId\n              +float amount\n              +date expenseDate\n            }\n\n            class Category {\n              +string categoryName\n              +string description\n            }\n\n            class Report {\n              +string reportId\n              +date reportDate\n              +string summary\n            }\n\n            class Manager {\n              +string name\n              +string department\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Healthcare - Emergency Room Management. Classes involved are Patient, ERVisit, TriageNurse, Doctor, and MedicalRecord.",
        "output": "classDiagram\n            Patient -- ERVisit : undergoes\n            TriageNurse -- ERVisit : assesses\n            Doctor -- ERVisit : treats\n            MedicalRecord -- ERVisit : updated_with\n\n            class Patient {\n              +string name\n              +string dob\n              +string medicalHistory\n            }\n\n            class ERVisit {\n              +date visitDate\n              +string reasonForVisit\n              +string outcome\n            }\n\n            class TriageNurse {\n              +string name\n              +string qualifications\n            }\n\n            class Doctor {\n              +string name\n              +string specialty\n            }\n\n            class MedicalRecord {\n              +string recordId\n              +string history\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Real Estate - Property Listing System. Classes involved are Agent, Listing, Property, Buyer, and Offer.",
        "output": "classDiagram\n            Agent -- Listing : creates\n            Listing -- Property : describes\n            Buyer -- Listing : inquires_about\n            Offer -- Listing : associated_with\n\n            class Agent {\n              +string name\n              +string agency\n            }\n\n            class Listing {\n              +string listingId\n              +date datePosted\n              +float price\n            }\n\n            class Property {\n              +string address\n              +float area\n              +string type\n            }\n\n            class Buyer {\n              +string name\n              +string contactInfo\n            }\n\n            class Offer {\n              +float offerPrice\n              +date offerDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Technology - Cloud Storage System. Classes involved are User, File, Folder, StoragePlan, and AccessLog.",
        "output": "classDiagram\n            User -- File : uploads\n            Folder -- File : contains\n            StoragePlan -- User : associated_with\n            AccessLog -- File : recorded_in\n\n            class User {\n              +string name\n              +string email\n              +string userId\n            }\n\n            class File {\n              +string fileName\n              +float fileSize\n              +date uploadDate\n            }\n\n            class Folder {\n              +string folderName\n              +date creationDate\n            }\n\n            class StoragePlan {\n              +string planName\n              +float storageLimit\n              +float cost\n            }\n\n            class AccessLog {\n              +date accessDate\n              +string action\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Retail - Loyalty Program Management. Classes involved are Customer, LoyaltyAccount, Purchase, Reward, and Transaction.",
        "output": "classDiagram\n            Customer -- LoyaltyAccount : has\n            Purchase -- LoyaltyAccount : linked_to\n            Reward -- LoyaltyAccount : redeemed_by\n            Transaction -- Purchase : associated_with\n\n            class Customer {\n              +string name\n              +string contactInfo\n              +string loyaltyId\n            }\n\n            class LoyaltyAccount {\n              +int points\n              +date lastActivity\n            }\n\n            class Purchase {\n              +float amount\n              +date purchaseDate\n            }\n\n            class Reward {\n              +string rewardName\n              +int pointsRequired\n            }\n\n            class Transaction {\n              +string transactionId\n              +date transactionDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Logistics - Freight Forwarding System. Classes involved are Consignor, ShipmentOrder, Carrier, Freight, and Delivery.",
        "output": "classDiagram\n            Consignor -- ShipmentOrder : creates\n            ShipmentOrder -- Carrier : assigned_to\n            Freight -- ShipmentOrder : includes\n            Delivery -- ShipmentOrder : results_in\n\n            class Consignor {\n              +string name\n              +string contactInfo\n            }\n\n            class ShipmentOrder {\n              +string orderId\n              +date orderDate\n              +string status\n            }\n\n            class Carrier {\n              +string name\n              +string vehicleType\n            }\n\n            class Freight {\n              +string description\n              +float weight\n              +string dimensions\n            }\n\n            class Delivery {\n              +date deliveryDate\n              +string deliveryStatus\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Healthcare - Dental Clinic Management. Classes involved are Dentist, Appointment, Patient, Treatment, and Billing.",
        "output": "classDiagram\n            Dentist -- Appointment : attends\n            Patient -- Appointment : schedules\n            Treatment -- Appointment : includes\n            Billing -- Appointment : associated_with\n\n            class Dentist {\n              +string name\n              +string specialization\n            }\n\n            class Appointment {\n              +date appointmentDate\n              +string reason\n              +string status\n            }\n\n            class Patient {\n              +string name\n              +string contactInfo\n            }\n\n            class Treatment {\n              +string treatmentType\n              +float cost\n            }\n\n            class Billing {\n              +float totalAmount\n              +date billingDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Education - Virtual Classroom System. Classes involved are Teacher, Session, Student, LessonMaterial, and Assignment.",
        "output": "classDiagram\n            Teacher -- Session : conducts\n            Student -- Session : attends\n            LessonMaterial -- Session : associated_with\n            Assignment -- LessonMaterial : based_on\n\n            class Teacher {\n              +string name\n              +string subject\n            }\n\n            class Session {\n              +string sessionId\n              +date sessionDate\n              +string topic\n            }\n\n            class Student {\n              +string name\n              +string studentId\n            }\n\n            class LessonMaterial {\n              +string materialTitle\n              +string format\n              +date publicationDate\n            }\n\n            class Assignment {\n              +string title\n              +date dueDate\n              +string description\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Business - Payroll Management System. Classes involved are Employee, Payroll, Payslip, TaxDeduction, and SalaryComponent.",
        "output": "classDiagram\n            Employee -- Payroll : receives\n            Payroll -- Payslip : includes\n            TaxDeduction -- Payroll : associated_with\n            SalaryComponent -- Payroll : calculated_from\n\n            class Employee {\n              +string name\n              +string employeeId\n              +string department\n            }\n\n            class Payroll {\n              +date payrollDate\n              +float grossPay\n              +float netPay\n            }\n\n            class Payslip {\n              +string payslipId\n              +date issueDate\n              +float totalAmount\n            }\n\n            class TaxDeduction {\n              +string taxType\n              +float amount\n            }\n\n            class SalaryComponent {\n              +string componentName\n              +float amount\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Finance - Mortgage Management System. Classes involved are Customer, Mortgage, Property, Payment, and InterestRate.",
        "output": "classDiagram\n            Customer -- Mortgage : applies_for\n            Mortgage -- Property : secured_by\n            Payment -- Mortgage : associated_with\n            InterestRate -- Mortgage : calculated_on\n\n            class Customer {\n              +string name\n              +string contactInfo\n            }\n\n            class Mortgage {\n              +string mortgageId\n              +float loanAmount\n              +date startDate\n            }\n\n            class Property {\n              +string address\n              +float value\n            }\n\n            class Payment {\n              +float amount\n              +date paymentDate\n            }\n\n            class InterestRate {\n              +float rate\n              +date effectiveDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Logistics - Inventory Tracking System. Classes involved are Warehouse, InventoryItem, Supplier, StockLevel, and RestockOrder.",
        "output": "classDiagram\n            Warehouse -- InventoryItem : contains\n            InventoryItem -- Supplier : supplied_by\n            StockLevel -- InventoryItem : tracks\n            RestockOrder -- InventoryItem : triggers\n\n            class Warehouse {\n              +string warehouseId\n              +string location\n            }\n\n            class InventoryItem {\n              +string itemId\n              +string name\n              +int quantity\n            }\n\n            class Supplier {\n              +string name\n              +string contactInfo\n            }\n\n            class StockLevel {\n              +int currentLevel\n              +int reorderThreshold\n            }\n\n            class RestockOrder {\n              +date orderDate\n              +int quantityOrdered\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Tourism - Cruise Management System. Classes involved are Passenger, Booking, Cabin, Activity, and Destination.",
        "output": "classDiagram\n            Passenger -- Booking : makes\n            Cabin -- Booking : associated_with\n            Activity -- Cruise : offers\n            Destination -- Cruise : visits\n\n            class Passenger {\n              +string name\n              +string nationality\n              +date dob\n            }\n\n            class Booking {\n              +string bookingId\n              +date bookingDate\n              +float totalCost\n            }\n\n            class Cabin {\n              +string cabinNumber\n              +string type\n            }\n\n            class Activity {\n              +string activityName\n              +date activityDate\n            }\n\n            class Destination {\n              +string location\n              +date arrivalDate\n              +date departureDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Retail - Product Return Management. Classes involved are Customer, ReturnRequest, Product, Refund, and Restock.",
        "output": "classDiagram\n            Customer -- ReturnRequest : submits\n            ReturnRequest -- Product : involves\n            Refund -- ReturnRequest : associated_with\n            Restock -- Product : triggers\n\n            class Customer {\n              +string name\n              +string orderId\n              +string contactInfo\n            }\n\n            class ReturnRequest {\n              +string requestId\n              +date requestDate\n              +string reason\n            }\n\n            class Product {\n              +string productId\n              +string name\n              +float price\n            }\n\n            class Refund {\n              +float amount\n              +date refundDate\n            }\n\n            class Restock {\n              +date restockDate\n              +int quantityRestocked\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Technology - DevOps Pipeline System. Classes involved are Developer, CodeRepository, Build, Test, and Deployment.",
        "output": "classDiagram\n            Developer -- CodeRepository : commits_to\n            Build -- Pipeline : initiated_by\n            Test -- Pipeline : executed_in\n            Deployment -- Pipeline : results_in\n\n            class Developer {\n              +string name\n              +string role\n            }\n\n            class CodeRepository {\n              +string repoName\n              +date creationDate\n            }\n\n            class Build {\n              +string buildId\n              +date buildDate\n              +string status\n            }\n\n            class Test {\n              +string testName\n              +date testDate\n              +string result\n            }\n\n            class Deployment {\n              +string deploymentId\n              +date deploymentDate\n              +string environment\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Finance - Tax Filing System. Classes involved are Taxpayer, TaxReturn, Income, Deduction, and Payment.",
        "output": "classDiagram\n            Taxpayer -- TaxReturn : files\n            TaxReturn -- Income : reports\n            Deduction -- TaxReturn : associated_with\n            Payment -- TaxReturn : related_to\n\n            class Taxpayer {\n              +string name\n              +string ssn\n              +string filingStatus\n            }\n\n            class TaxReturn {\n              +string returnId\n              +date filingDate\n              +float taxDue\n            }\n\n            class Income {\n              +string source\n              +float amount\n              +date receivedDate\n            }\n\n            class Deduction {\n              +string deductionType\n              +float amount\n            }\n\n            class Payment {\n              +float amount\n              +date paymentDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Healthcare - Medical Imaging System. Classes involved are Radiologist, ImagingOrder, Patient, Scan, and Report.",
        "output": "classDiagram\n            Radiologist -- ImagingOrder : reviews\n            Patient -- ImagingOrder : undergoes\n            Scan -- ImagingOrder : produces\n            Report -- Scan : associated_with\n\n            class Radiologist {\n              +string name\n              +string specialty\n            }\n\n            class ImagingOrder {\n              +string orderId\n              +date orderDate\n              +string imagingType\n            }\n\n            class Patient {\n              +string name\n              +string dob\n              +string contactInfo\n            }\n\n            class Scan {\n              +string scanId\n              +date scanDate\n              +string scanType\n            }\n\n            class Report {\n              +string reportId\n              +date reportDate\n              +string findings\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Transportation - Vehicle Maintenance System. Classes involved are Vehicle, MaintenanceRecord, Technician, Service, and Part.",
        "output": "classDiagram\n            Vehicle -- MaintenanceRecord : associated_with\n            Technician -- MaintenanceRecord : creates\n            Service -- MaintenanceRecord : includes\n            Part -- Service : required_for\n\n            class Vehicle {\n              +string vin\n              +string make\n              +string model\n              +int year\n            }\n\n            class MaintenanceRecord {\n              +string recordId\n              +date serviceDate\n              +string description\n            }\n\n            class Technician {\n              +string name\n              +string certification\n            }\n\n            class Service {\n              +string serviceName\n              +float cost\n            }\n\n            class Part {\n              +string partName\n              +string partNumber\n              +float cost\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Tourism - Museum Management System. Classes involved are Visitor, Ticket, Exhibit, Artifact, and Guide.",
        "output": "classDiagram\n            Visitor -- Ticket : purchases\n            Exhibit -- Ticket : grants_access_to\n            Artifact -- Exhibit : contains\n            Guide -- Exhibit : provides_tour_for\n\n            class Visitor {\n              +string name\n              +string contactInfo\n            }\n\n            class Ticket {\n              +string ticketId\n              +date issueDate\n              +float price\n            }\n\n            class Exhibit {\n              +string exhibitName\n              +date startDate\n              +date endDate\n            }\n\n            class Artifact {\n              +string artifactName\n              +string origin\n              +date acquisitionDate\n            }\n\n            class Guide {\n              +string name\n              +string specialty\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Retail - Warehouse Automation System. Classes involved are Robot, Task, Product, Conveyor, and Sensor.",
        "output": "classDiagram\n            Robot -- Task : performs\n            Task -- Product : associated_with\n            Conveyor -- Product : transports\n            Sensor -- Robot : guides\n\n            class Robot {\n              +string robotId\n              +string model\n              +string manufacturer\n            }\n\n            class Task {\n              +string taskId\n              +string description\n              +date assignedDate\n            }\n\n            class Product {\n              +string productId\n              +string name\n              +float weight\n            }\n\n            class Conveyor {\n              +string conveyorId\n              +string location\n            }\n\n            class Sensor {\n              +string sensorType\n              +string manufacturer\n              +string model\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Finance - Investment Portfolio Management. Classes involved are Investor, Portfolio, Asset, Trade, and PerformanceReport.",
        "output": "classDiagram\n            Investor -- Portfolio : owns\n            Portfolio -- Asset : contains\n            Trade -- Asset : results_in\n            PerformanceReport -- Portfolio : summarized_in\n\n            class Investor {\n              +string name\n              +string contactInfo\n              +string investorId\n            }\n\n            class Portfolio {\n              +string portfolioId\n              +float totalValue\n              +string riskLevel\n            }\n\n            class Asset {\n              +string assetName\n              +string assetType\n              +float marketValue\n            }\n\n            class Trade {\n              +string tradeId\n              +date tradeDate\n              +string tradeType\n              +float tradeValue\n            }\n\n            class PerformanceReport {\n              +string reportId\n              +date reportDate\n              +string summary\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Education - Scholarship Management System. Classes involved are Student, Application, Scholarship, Committee, and Award.",
        "output": "classDiagram\n            Student -- Application : submits\n            Application -- Scholarship : applies_for\n            Committee -- Application : reviews\n            Award -- Scholarship : granted_by\n\n            class Student {\n              +string name\n              +string studentId\n              +string major\n            }\n\n            class Application {\n              +string applicationId\n              +date submissionDate\n              +string status\n            }\n\n            class Scholarship {\n              +string scholarshipName\n              +float amount\n              +date awardDate\n            }\n\n            class Committee {\n              +string committeeName\n              +string members\n            }\n\n            class Award {\n              +string awardId\n              +float amount\n              +date disbursementDate\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Transportation - Railway Reservation System. Classes involved are Passenger, Reservation, Train, Seat, and Ticket.",
        "output": "classDiagram\n            Passenger -- Reservation : makes\n            Train -- Reservation : associated_with\n            Seat -- Train : assigned_to\n            Ticket -- Reservation : linked_to\n\n            class Passenger {\n              +string name\n              +string contactInfo\n            }\n\n            class Reservation {\n              +string reservationId\n              +date reservationDate\n              +float totalCost\n            }\n\n            class Train {\n              +string trainNumber\n              +string route\n              +date departureDate\n            }\n\n            class Seat {\n              +string seatNumber\n              +string class\n              +float fare\n            }\n\n            class Ticket {\n              +string ticketNumber\n              +date issueDate\n              +float price\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Healthcare - Telehealth Consultation System. Classes involved are Patient, Consultation, Doctor, Diagnosis, and Prescription.",
        "output": "classDiagram\n            Patient -- Consultation : books\n            Doctor -- Consultation : provides\n            Diagnosis -- Consultation : results_in\n            Prescription -- Diagnosis : associated_with\n\n            class Patient {\n              +string name\n              +string contactInfo\n              +date dob\n            }\n\n            class Consultation {\n              +string consultationId\n              +date consultationDate\n              +string status\n            }\n\n            class Doctor {\n              +string name\n              +string specialty\n            }\n\n            class Diagnosis {\n              +string diagnosisId\n              +string condition\n              +string notes\n            }\n\n            class Prescription {\n              +string prescriptionId\n              +date issueDate\n              +string medication\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Real Estate - Property Appraisal System. Classes involved are Appraiser, Appraisal, Property, Client, and Report.",
        "output": "classDiagram\n            Appraiser -- Appraisal : conducts\n            Property -- Appraisal : linked_to\n            Client -- Appraisal : requests\n            Report -- Appraisal : generated_for\n\n            class Appraiser {\n              +string name\n              +string certification\n              +string contactInfo\n            }\n\n            class Appraisal {\n              +string appraisalId\n              +date appraisalDate\n              +float appraisedValue\n            }\n\n            class Property {\n              +string propertyId\n              +string address\n              +float marketValue\n            }\n\n            class Client {\n              +string name\n              +string contactInfo\n            }\n\n            class Report {\n              +string reportId\n              +date reportDate\n              +string findings\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Technology - Cybersecurity Incident Management. Classes involved are Incident, Report, Analyst, Threat, and Mitigation.",
        "output": "classDiagram\n            Incident -- Report : documented_in\n            Analyst -- Report : analyzes\n            Threat -- Incident : identified_in\n            Mitigation -- Threat : results_in\n\n            class Incident {\n              +string incidentId\n              +date incidentDate\n              +string description\n            }\n\n            class Report {\n              +string reportId\n              +date reportDate\n              +string findings\n            }\n\n            class Analyst {\n              +string name\n              +string role\n            }\n\n            class Threat {\n              +string threatType\n              +string severity\n            }\n\n            class Mitigation {\n              +string mitigationId\n              +date mitigationDate\n              +string actionsTaken\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Logistics - Vehicle Routing System. Classes involved are Driver, Vehicle, Route, Delivery, and Customer.",
        "output": "classDiagram\n            Driver -- Vehicle : operates\n            Vehicle -- Route : follows\n            Route -- Delivery : linked_to\n            Delivery -- Customer : received_by\n\n            class Driver {\n              +string name\n              +string licenseNumber\n            }\n\n            class Vehicle {\n              +string vehicleId\n              +string model\n              +int capacity\n            }\n\n            class Route {\n              +string routeId\n              +string origin\n              +string destination\n            }\n\n            class Delivery {\n              +string deliveryId\n              +date deliveryDate\n              +string status\n            }\n\n            class Customer {\n              +string name\n              +string address\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Tourism - Adventure Tour Management. Classes involved are AdventureGuide, Tour, Participant, Equipment, and SafetyBriefing.",
        "output": "classDiagram\n            AdventureGuide -- Tour : leads\n            Participant -- Tour : joins\n            Equipment -- Tour : required_for\n            SafetyBriefing -- Tour : conducted_for\n\n            class AdventureGuide {\n              +string name\n              +string certification\n            }\n\n            class Tour {\n              +string tourId\n              +date tourDate\n              +string location\n            }\n\n            class Participant {\n              +string name\n              +string contactInfo\n            }\n\n            class Equipment {\n              +string equipmentName\n              +int quantity\n              +string condition\n            }\n\n            class SafetyBriefing {\n              +string briefingId\n              +date briefingDate\n              +string content\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Education - Alumni Management System. Classes involved are Alumni, Event, Organizer, Donation, and Newsletter.",
        "output": "classDiagram\n            Alumni -- Event : participates_in\n            Event -- Organizer : coordinated_by\n            Donation -- Alumni : contributes_to\n            Newsletter -- Alumni : subscribed_to\n\n            class Alumni {\n              +string name\n              +string graduationYear\n              +string contactInfo\n            }\n\n            class Event {\n              +string eventId\n              +date eventDate\n              +string location\n            }\n\n            class Organizer {\n              +string name\n              +string role\n            }\n\n            class Donation {\n              +string donationId\n              +float amount\n              +date donationDate\n            }\n\n            class Newsletter {\n              +string newsletterId\n              +date issueDate\n              +string content\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Finance - Credit Card Management System. Classes involved are Cardholder, CreditCard, Transaction, Statement, and Payment.",
        "output": "classDiagram\n            Cardholder -- CreditCard : owns\n            CreditCard -- Transaction : linked_to\n            Statement -- CreditCard : generates\n            Payment -- Statement : associated_with\n\n            class Cardholder {\n              +string name\n              +string contactInfo\n              +string cardholderId\n            }\n\n            class CreditCard {\n              +string cardNumber\n              +string expiryDate\n              +float creditLimit\n            }\n\n            class Transaction {\n              +string transactionId\n              +date transactionDate\n              +float amount\n            }\n\n            class Statement {\n              +string statementId\n              +date issueDate\n              +float balance\n            }\n\n            class Payment {\n              +string paymentId\n              +date paymentDate\n              +float amount\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Healthcare - Mental Health Counseling System. Classes involved are Counselor, Session, Patient, TreatmentPlan, and ProgressNote.",
        "output": "classDiagram\n            Counselor -- Session : conducts\n            Patient -- Session : attends\n            TreatmentPlan -- Patient : associated_with\n            ProgressNote -- Session : results_in\n\n            class Counselor {\n              +string name\n              +string licenseNumber\n              +string specialization\n            }\n\n            class Session {\n              +string sessionId\n              +date sessionDate\n              +string topic\n            }\n\n            class Patient {\n              +string name\n              +date dob\n              +string contactInfo\n            }\n\n            class TreatmentPlan {\n              +string planId\n              +string diagnosis\n              +string goals\n            }\n\n            class ProgressNote {\n              +string noteId\n              +date noteDate\n              +string observations\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Real Estate - Commercial Leasing System. Classes involved are Business, LeaseAgreement, PropertyManager, CommercialProperty, and Payment.",
        "output": "classDiagram\n            Business -- LeaseAgreement : enters_into\n            PropertyManager -- LeaseAgreement : oversees\n            CommercialProperty -- LeaseAgreement : linked_to\n            Payment -- LeaseAgreement : associated_with\n\n            class Business {\n              +string name\n              +string industry\n              +string contactInfo\n            }\n\n            class LeaseAgreement {\n              +string agreementId\n              +date startDate\n              +date endDate\n              +float rent\n            }\n\n            class PropertyManager {\n              +string name\n              +string contactInfo\n            }\n\n            class CommercialProperty {\n              +string propertyId\n              +string address\n              +float area\n            }\n\n            class Payment {\n              +string paymentId\n              +date paymentDate\n              +float amount\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Technology - Blockchain Transaction System. Classes involved are User, Wallet, Transaction, Blockchain, and Node.",
        "output": "classDiagram\n            User -- Wallet : owns\n            Wallet -- Transaction : initiates\n            Transaction -- Blockchain : recorded_on\n            Node -- Blockchain : participates_in\n\n            class User {\n              +string name\n              +string email\n              +string userId\n            }\n\n            class Wallet {\n              +string walletId\n              +float balance\n              +string currency\n            }\n\n            class Transaction {\n              +string transactionId\n              +date transactionDate\n              +float amount\n            }\n\n            class Blockchain {\n              +string blockchainId\n              +int blockCount\n              +date creationDate\n            }\n\n            class Node {\n              +string nodeId\n              +string location\n              +string status\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Retail - Online Food Delivery System. Classes involved are Customer, Order, Restaurant, DeliveryDriver, and FoodItem.",
        "output": "classDiagram\n            Customer -- Order : places\n            Order -- Restaurant : sent_to\n            DeliveryDriver -- Order : delivers\n            FoodItem -- Order : contains\n\n            class Customer {\n              +string name\n              +string address\n              +string contactInfo\n            }\n\n            class Order {\n              +string orderId\n              +date orderDate\n              +float totalCost\n            }\n\n            class Restaurant {\n              +string name\n              +string location\n              +string cuisineType\n            }\n\n            class DeliveryDriver {\n              +string name\n              +string licenseNumber\n              +string contactInfo\n            }\n\n            class FoodItem {\n              +string itemName\n              +float price\n              +int quantity\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Logistics - Air Cargo Management System. Classes involved are Shipment, Cargo, Airplane, Airport, and CargoHandler.",
        "output": "classDiagram\n            Shipment -- Cargo : contains\n            Airplane -- Cargo : transports\n            Airport -- Airplane : services\n            CargoHandler -- Cargo : manages\n\n            class Shipment {\n              +string shipmentId\n              +date shipmentDate\n              +string status\n            }\n\n            class Cargo {\n              +string cargoId\n              +float weight\n              +string description\n            }\n\n            class Airplane {\n              +string airplaneId\n              +string model\n              +float cargoCapacity\n            }\n\n            class Airport {\n              +string name\n              +string location\n              +string code\n            }\n\n            class CargoHandler {\n              +string name\n              +string contactInfo\n              +string role\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML class diagram for the following scenario: Healthcare - Medical Supply Inventory System. Classes involved are Supplier, MedicalSupply, Inventory, Request, and Department.",
        "output": "classDiagram\n            Supplier -- MedicalSupply : provides\n            MedicalSupply -- Inventory : stored_in\n            Request -- Inventory : allocated_from\n            Department -- Request : submits\n\n            class Supplier {\n              +string name\n              +string contactInfo\n              +string certification\n            }\n\n            class MedicalSupply {\n              +string supplyId\n              +string name\n              +int quantity\n            }\n\n            class Inventory {\n              +string inventoryId\n              +string location\n              +int stockLevel\n            }\n\n            class Request {\n              +string requestId\n              +date requestDate\n              +int quantityRequested\n            }\n\n            class Department {\n              +string departmentName\n              +string contactInfo\n            }\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A patient visits a hospital, interacts with a receptionist, consults a doctor, undergoes a test in the lab, receives a prescription, and gets discharged.",
        "output": "\n        sequenceDiagram\n            participant Patient\n            participant Receptionist\n            participant Doctor\n            participant Lab\n            participant Pharmacy\n\n            Patient->>Receptionist: Registers\n            Receptionist->>Doctor: Schedules appointment\n            Doctor->>Patient: Consults\n            Doctor->>Lab: Orders test\n            Lab->>Doctor: Sends test results\n            Doctor->>Pharmacy: Prescribes medication\n            Pharmacy->>Patient: Dispenses medication\n            Doctor->>Patient: Discharge\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A student registers for a course, attends classes, submits assignments, takes exams, and receives grades.",
        "output": "\n        sequenceDiagram\n            participant Student\n            participant Registrar\n            participant Instructor\n            participant ExamSystem\n            participant GradingSystem\n\n            Student->>Registrar: Registers for course\n            Registrar->>Instructor: Enrolls student\n            Student->>Instructor: Attends classes\n            Student->>Instructor: Submits assignments\n            Instructor->>ExamSystem: Schedules exams\n            Student->>ExamSystem: Takes exams\n            ExamSystem->>Instructor: Sends exam results\n            Instructor->>GradingSystem: Submits final grades\n            GradingSystem->>Student: Receives grades\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A company processes an order, checks inventory, dispatches goods, issues an invoice, and updates the customer on the delivery status.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant Sales\n            participant Inventory\n            participant Dispatch\n            participant Billing\n            participant Delivery\n\n            Customer->>Sales: Places order\n            Sales->>Inventory: Checks availability\n            Inventory-->>Sales: Confirms stock\n            Sales->>Dispatch: Requests dispatch\n            Dispatch->>Billing: Notifies dispatch\n            Billing->>Customer: Issues invoice\n            Dispatch->>Delivery: Ships goods\n            Delivery->>Customer: Updates delivery status\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A tourist books a flight, checks into a hotel, attends a tour, and returns home.",
        "output": "\n        sequenceDiagram\n            participant Tourist\n            participant Airline\n            participant Hotel\n            participant TourOperator\n\n            Tourist->>Airline: Books flight\n            Airline->>Tourist: Sends ticket\n            Tourist->>Hotel: Checks in\n            Tourist->>TourOperator: Attends tour\n            TourOperator->>Tourist: Provides tour service\n            Tourist->>Hotel: Checks out\n            Tourist->>Airline: Takes return flight\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A company conducts a market research, gathers data, analyzes it, and presents the findings.",
        "output": "\n        sequenceDiagram\n            participant Company\n            participant ResearchTeam\n            participant DataAnalyst\n            participant PresentationTeam\n\n            Company->>ResearchTeam: Commissions market research\n            ResearchTeam->>DataAnalyst: Gathers data\n            DataAnalyst->>ResearchTeam: Analyzes data\n            ResearchTeam->>PresentationTeam: Prepares report\n            PresentationTeam->>Company: Presents findings\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A patient books an appointment, meets with a specialist, undergoes surgery, stays in recovery, and then gets discharged.",
        "output": "\n        sequenceDiagram\n            participant Patient\n            participant Reception\n            participant Specialist\n            participant SurgeryTeam\n            participant Recovery\n            participant Billing\n\n            Patient->>Reception: Books appointment\n            Reception->>Specialist: Schedules consultation\n            Patient->>Specialist: Consults specialist\n            Specialist->>SurgeryTeam: Orders surgery\n            SurgeryTeam->>Recovery: Transfers patient post-surgery\n            Recovery->>Patient: Monitors recovery\n            Recovery->>Billing: Sends discharge notice\n            Billing->>Patient: Processes payment\n            Billing->>Patient: Discharges patient\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A new employee joins a company, goes through orientation, gets assigned a project, completes tasks, and submits a final report.",
        "output": "\n        sequenceDiagram\n            participant Employee\n            participant HR\n            participant IT\n            participant Manager\n            participant ProjectTeam\n\n            Employee->>HR: Completes paperwork\n            HR->>IT: Requests system access\n            IT->>Employee: Provides access\n            HR->>Manager: Notifies of new hire\n            Manager->>ProjectTeam: Assigns project\n            Employee->>ProjectTeam: Starts tasks\n            ProjectTeam->>Manager: Monitors progress\n            Employee->>Manager: Submits final report\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A bank customer applies for a loan, the bank processes the application, approves it, disburses funds, and the customer makes repayments.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant Bank\n            participant LoanOfficer\n            participant Underwriting\n            participant Disbursement\n            participant Repayment\n\n            Customer->>Bank: Applies for loan\n            Bank->>LoanOfficer: Reviews application\n            LoanOfficer->>Underwriting: Conducts risk assessment\n            Underwriting->>LoanOfficer: Approves loan\n            LoanOfficer->>Disbursement: Initiates disbursement\n            Disbursement->>Customer: Transfers funds\n            Repayment->>Customer: Sets up repayment schedule\n            Customer->>Repayment: Makes payments\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A public health team tracks an outbreak, collects data, analyzes trends, and implements control measures.",
        "output": "\n        sequenceDiagram\n            participant PublicHealthTeam\n            participant FieldAgents\n            participant DataAnalyst\n            participant Epidemiologist\n            participant ResponseTeam\n\n            PublicHealthTeam->>FieldAgents: Deploys to affected area\n            FieldAgents->>DataAnalyst: Collects data\n            DataAnalyst->>Epidemiologist: Analyzes trends\n            Epidemiologist->>PublicHealthTeam: Recommends measures\n            PublicHealthTeam->>ResponseTeam: Implements control measures\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A car manufacturer designs a new model, tests prototypes, launches production, markets the car, and sells to customers.",
        "output": "\n        sequenceDiagram\n            participant DesignTeam\n            participant TestingTeam\n            participant Production\n            participant Marketing\n            participant Sales\n            participant Customer\n\n            DesignTeam->>TestingTeam: Submits prototypes\n            TestingTeam->>DesignTeam: Sends feedback\n            DesignTeam->>Production: Finalizes design\n            Production->>Marketing: Begins production\n            Marketing->>Sales: Launches campaign\n            Sales->>Customer: Sells cars\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A disaster management team monitors weather conditions, issues warnings, coordinates evacuations, and provides relief to affected populations.",
        "output": "\n        sequenceDiagram\n            participant MonitoringTeam\n            participant WeatherService\n            participant EmergencyServices\n            participant EvacuationTeam\n            participant ReliefTeam\n\n            MonitoringTeam->>WeatherService: Receives weather data\n            WeatherService->>MonitoringTeam: Issues alerts\n            MonitoringTeam->>EmergencyServices: Coordinates response\n            EmergencyServices->>EvacuationTeam: Organizes evacuations\n            ReliefTeam->>EmergencyServices: Provides relief\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A software company develops a new application, tests it, deploys it to production, and provides ongoing support.",
        "output": "\n        sequenceDiagram\n            participant DevelopmentTeam\n            participant TestingTeam\n            participant Operations\n            participant SupportTeam\n            participant Customer\n\n            DevelopmentTeam->>TestingTeam: Delivers software build\n            TestingTeam->>DevelopmentTeam: Reports bugs\n            DevelopmentTeam->>TestingTeam: Fixes bugs\n            TestingTeam->>Operations: Approves release\n            Operations->>Customer: Deploys application\n            Customer->>SupportTeam: Reports issues\n            SupportTeam->>DevelopmentTeam: Escalates issues\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: An insurance company processes a claim, reviews documents, assesses damage, approves the claim, and disburses funds.",
        "output": "\n        sequenceDiagram\n            participant Policyholder\n            participant ClaimsDepartment\n            participant DocumentReview\n            participant AssessmentTeam\n            participant Approvals\n            participant Disbursement\n\n            Policyholder->>ClaimsDepartment: Submits claim\n            ClaimsDepartment->>DocumentReview: Reviews documents\n            DocumentReview->>AssessmentTeam: Assesses damage\n            AssessmentTeam->>Approvals: Recommends approval\n            Approvals->>Disbursement: Approves claim\n            Disbursement->>Policyholder: Disburses funds\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A logistics company receives an order, picks and packs goods, ships them, and delivers to the customer.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant OrderProcessing\n            participant Warehouse\n            participant Shipping\n            participant Delivery\n\n            Customer->>OrderProcessing: Places order\n            OrderProcessing->>Warehouse: Requests fulfillment\n            Warehouse->>Shipping: Picks and packs goods\n            Shipping->>Delivery: Ships goods\n            Delivery->>Customer: Delivers order\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A research team submits a grant proposal, gets approval, conducts research, publishes results, and presents findings at a conference.",
        "output": "\n        sequenceDiagram\n            participant ResearchTeam\n            participant FundingAgency\n            participant ReviewBoard\n            participant Journal\n            participant Conference\n\n            ResearchTeam->>FundingAgency: Submits grant proposal\n            FundingAgency->>ReviewBoard: Requests review\n            ReviewBoard->>FundingAgency: Approves grant\n            FundingAgency->>ResearchTeam: Provides funding\n            ResearchTeam->>Journal: Submits research findings\n            Journal->>ResearchTeam: Publishes paper\n            ResearchTeam->>Conference: Presents findings\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A university processes student applications, evaluates them, admits students, and conducts orientation.",
        "output": "\n        sequenceDiagram\n            participant Applicant\n            participant Admissions\n            participant Evaluation\n            participant Registrar\n            participant Orientation\n\n            Applicant->>Admissions: Submits application\n            Admissions->>Evaluation: Reviews application\n            Evaluation->>Admissions: Recommends admission\n            Admissions->>Registrar: Admits student\n            Registrar->>Orientation: Schedules orientation\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A pharmaceutical company develops a new drug, conducts clinical trials, gets regulatory approval, and launches the drug in the market.",
        "output": "\n        sequenceDiagram\n            participant R&D\n            participant ClinicalTrials\n            participant RegulatoryAgency\n            participant Marketing\n            participant Sales\n\n            R&D->>ClinicalTrials: Submits drug for trials\n            ClinicalTrials->>R&D: Reports results\n            R&D->>RegulatoryAgency: Seeks approval\n            RegulatoryAgency->>R&D: Grants approval\n            R&D->>Marketing: Initiates launch campaign\n            Marketing->>Sales: Launches drug\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A customer orders a product online, the e-commerce platform processes payment, the warehouse prepares the order, and a courier service delivers it.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant ECommercePlatform\n            participant PaymentGateway\n            participant Warehouse\n            participant CourierService\n\n            Customer->>ECommercePlatform: Places order\n            ECommercePlatform->>PaymentGateway: Processes payment\n            PaymentGateway->>ECommercePlatform: Confirms payment\n            ECommercePlatform->>Warehouse: Sends order details\n            Warehouse->>CourierService: Prepares and ships order\n            CourierService->>Customer: Delivers package\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A project manager initiates a project, allocates resources, tracks progress, and delivers the final product to the client.",
        "output": "\n        sequenceDiagram\n            participant ProjectManager\n            participant TeamLeads\n            participant Resources\n            participant Client\n\n            ProjectManager->>TeamLeads: Allocates resources\n            TeamLeads->>Resources: Utilizes resources\n            Resources->>ProjectManager: Provides updates\n            ProjectManager->>Client: Delivers final product\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A city plans a new infrastructure project, conducts public consultations, secures funding, and begins construction.",
        "output": "\n        sequenceDiagram\n            participant CityPlanning\n            participant Public\n            participant FinanceDepartment\n            participant ConstructionTeam\n\n            CityPlanning->>Public: Holds consultations\n            Public->>CityPlanning: Provides feedback\n            CityPlanning->>FinanceDepartment: Secures funding\n            FinanceDepartment->>CityPlanning: Approves budget\n            CityPlanning->>ConstructionTeam: Begins construction\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A retailer orders goods from a supplier, receives them, stocks inventory, and sells to customers.",
        "output": "\n        sequenceDiagram\n            participant Retailer\n            participant Supplier\n            participant Inventory\n            participant Customer\n\n            Retailer->>Supplier: Places order\n            Supplier->>Retailer: Ships goods\n            Retailer->>Inventory: Stocks goods\n            Customer->>Retailer: Purchases products\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A healthcare provider administers a vaccination program, records data, and reports to health authorities.",
        "output": "\n        sequenceDiagram\n            participant HealthcareProvider\n            participant Patient\n            participant DataEntry\n            participant HealthAuthorities\n\n            HealthcareProvider->>Patient: Administers vaccine\n            Patient->>DataEntry: Provides information\n            DataEntry->>HealthcareProvider: Records vaccination data\n            HealthcareProvider->>HealthAuthorities: Reports vaccination data\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A customer visits a website, adds items to the cart, checks out, and receives order confirmation.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant Website\n            participant ShoppingCart\n            participant Checkout\n            participant Confirmation\n\n            Customer->>Website: Browses items\n            Website->>ShoppingCart: Adds items to cart\n            ShoppingCart->>Checkout: Proceeds to checkout\n            Checkout->>Customer: Processes payment\n            Checkout->>Confirmation: Sends order confirmation\n            Confirmation->>Customer: Confirms order\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A publishing house reviews a manuscript, edits it, designs the cover, prints the book, and distributes it.",
        "output": "\n        sequenceDiagram\n            participant Author\n            participant Editor\n            participant DesignTeam\n            participant Printing\n            participant Distribution\n\n            Author->>Editor: Submits manuscript\n            Editor->>Author: Provides feedback\n            Author->>Editor: Revises manuscript\n            Editor->>DesignTeam: Requests cover design\n            DesignTeam->>Editor: Delivers cover\n            Editor->>Printing: Sends final manuscript\n            Printing->>Distribution: Prints and ships books\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A tech company launches a new product, conducts marketing campaigns, gathers customer feedback, and updates the product.",
        "output": "\n        sequenceDiagram\n            participant TechCompany\n            participant Marketing\n            participant Customer\n            participant DevelopmentTeam\n            participant SupportTeam\n\n            TechCompany->>Marketing: Launches campaign\n            Marketing->>Customer: Collects feedback\n            Customer->>SupportTeam: Provides feedback\n            SupportTeam->>DevelopmentTeam: Suggests updates\n            DevelopmentTeam->>TechCompany: Releases updates\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A government agency collects census data, analyzes it, and publishes reports for policy-making.",
        "output": "\n        sequenceDiagram\n            participant CensusBureau\n            participant FieldAgents\n            participant DataAnalyst\n            participant PolicyMakers\n\n            CensusBureau->>FieldAgents: Conducts surveys\n            FieldAgents->>CensusBureau: Submits data\n            CensusBureau->>DataAnalyst: Analyzes data\n            DataAnalyst->>PolicyMakers: Publishes reports\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A film production company creates a movie, distributes it to theaters, and streams it online.",
        "output": "\n        sequenceDiagram\n            participant ProductionCompany\n            participant Theaters\n            participant StreamingService\n            participant Audience\n\n            ProductionCompany->>Theaters: Distributes movie\n            Theaters->>Audience: Screens movie\n            ProductionCompany->>StreamingService: Streams movie\n            Audience->>StreamingService: Watches movie online\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A bank opens a new account, issues a debit card, and enables online banking for the customer.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant Bank\n            participant AccountOpening\n            participant CardIssuance\n            participant OnlineBanking\n\n            Customer->>Bank: Requests account opening\n            Bank->>AccountOpening: Processes application\n            AccountOpening->>Customer: Opens account\n            AccountOpening->>CardIssuance: Issues debit card\n            CardIssuance->>Customer: Sends card\n            AccountOpening->>OnlineBanking: Activates online banking\n            OnlineBanking->>Customer: Provides access\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A travel agency books flights, reserves hotel rooms, and arranges local tours for a group of tourists.",
        "output": "\n        sequenceDiagram\n            participant TravelAgency\n            participant Airline\n            participant Hotel\n            participant TourOperator\n            participant Tourist\n\n            TravelAgency->>Airline: Books flights\n            Airline->>TravelAgency: Sends flight details\n            TravelAgency->>Hotel: Reserves rooms\n            Hotel->>TravelAgency: Confirms reservation\n            TravelAgency->>TourOperator: Arranges tours\n            TourOperator->>Tourist: Provides tour services\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A food delivery service receives an order, prepares the food, and delivers it to the customer.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant FoodApp\n            participant Restaurant\n            participant DeliveryDriver\n\n            Customer->>FoodApp: Places order\n            FoodApp->>Restaurant: Sends order details\n            Restaurant->>DeliveryDriver: Prepares order\n            DeliveryDriver->>Customer: Delivers food\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A university professor assigns a research project, students conduct research, submit reports, and receive grades.",
        "output": "\n        sequenceDiagram\n            participant Professor\n            participant Students\n            participant ResearchTeam\n            participant GradingSystem\n\n            Professor->>Students: Assigns project\n            Students->>ResearchTeam: Conducts research\n            ResearchTeam->>Students: Provides guidance\n            Students->>Professor: Submits reports\n            Professor->>GradingSystem: Assigns grades\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A manufacturing plant receives raw materials, processes them, assembles products, and ships them to distributors.",
        "output": "\n        sequenceDiagram\n            participant Supplier\n            participant Receiving\n            participant Processing\n            participant Assembly\n            participant Shipping\n            participant Distributor\n\n            Supplier->>Receiving: Delivers raw materials\n            Receiving->>Processing: Transfers materials\n            Processing->>Assembly: Passes processed components\n            Assembly->>Shipping: Prepares finished products\n            Shipping->>Distributor: Ships products\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A political candidate runs a campaign, holds rallies, debates opponents, and wins the election.",
        "output": "\n        sequenceDiagram\n            participant Candidate\n            participant CampaignTeam\n            participant Voters\n            participant Opponents\n            participant ElectionCommission\n\n            Candidate->>CampaignTeam: Plans campaign\n            CampaignTeam->>Voters: Organizes rallies\n            Candidate->>Opponents: Participates in debates\n            Voters->>ElectionCommission: Casts votes\n            ElectionCommission->>Candidate: Declares winner\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: An online store manages product listings, processes customer orders, handles returns, and manages inventory.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant OnlineStore\n            participant ProductListing\n            participant OrderProcessing\n            participant Returns\n            participant Inventory\n\n            Customer->>OnlineStore: Browses products\n            OnlineStore->>ProductListing: Manages listings\n            Customer->>OrderProcessing: Places order\n            OrderProcessing->>Customer: Processes order\n            Customer->>Returns: Requests return\n            Returns->>Inventory: Restocks item\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A corporate event planner organizes a conference, books a venue, arranges speakers, and coordinates with vendors.",
        "output": "\n        sequenceDiagram\n            participant EventPlanner\n            participant Venue\n            participant Speakers\n            participant Vendors\n\n            EventPlanner->>Venue: Books venue\n            Venue->>EventPlanner: Confirms booking\n            EventPlanner->>Speakers: Arranges speakers\n            Speakers->>EventPlanner: Confirms participation\n            EventPlanner->>Vendors: Coordinates services\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A bank processes credit card applications, issues cards, and manages customer transactions.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant Bank\n            participant CreditDepartment\n            participant CardIssuance\n            participant Transactions\n\n            Customer->>Bank: Applies for credit card\n            Bank->>CreditDepartment: Evaluates application\n            CreditDepartment->>Bank: Approves credit limit\n            Bank->>CardIssuance: Issues card\n            CardIssuance->>Customer: Sends credit card\n            Customer->>Transactions: Makes purchases\n            Transactions->>Bank: Processes transactions\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A healthcare facility manages patient records, schedules appointments, conducts tests, and updates medical history.",
        "output": "\n        sequenceDiagram\n            participant Patient\n            participant RecordsManagement\n            participant AppointmentSystem\n            participant Lab\n            participant Doctor\n\n            Patient->>AppointmentSystem: Schedules appointment\n            AppointmentSystem->>RecordsManagement: Updates records\n            Patient->>Doctor: Attends appointment\n            Doctor->>Lab: Orders tests\n            Lab->>Doctor: Sends results\n            Doctor->>RecordsManagement: Updates medical history\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A supply chain system orders raw materials, manufactures products, stores inventory, and ships to retailers.",
        "output": "\n        sequenceDiagram\n            participant Supplier\n            participant Manufacturer\n            participant InventoryManagement\n            participant Logistics\n            participant Retailer\n\n            Supplier->>Manufacturer: Delivers raw materials\n            Manufacturer->>InventoryManagement: Stores finished products\n            InventoryManagement->>Logistics: Arranges shipment\n            Logistics->>Retailer: Delivers products\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: An advertising agency develops a marketing campaign, creates content, and distributes it across various media channels.",
        "output": "\n        sequenceDiagram\n            participant Client\n            participant AdAgency\n            participant CreativeTeam\n            participant MediaChannels\n\n            Client->>AdAgency: Commissions campaign\n            AdAgency->>CreativeTeam: Develops content\n            CreativeTeam->>MediaChannels: Distributes content\n            MediaChannels->>Client: Runs campaign\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A software team develops a feature, integrates it with the existing system, tests it, and deploys it to production.",
        "output": "\n        sequenceDiagram\n            participant ProductOwner\n            participant DevelopmentTeam\n            participant IntegrationTeam\n            participant TestingTeam\n            participant Operations\n\n            ProductOwner->>DevelopmentTeam: Defines feature\n            DevelopmentTeam->>IntegrationTeam: Integrates with system\n            IntegrationTeam->>TestingTeam: Requests testing\n            TestingTeam->>Operations: Approves for deployment\n            Operations->>Production: Deploys feature\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A social media company launches a new feature, collects user feedback, and updates the feature based on feedback.",
        "output": "\n        sequenceDiagram\n            participant ProductTeam\n            participant Users\n            participant FeedbackSystem\n            participant DevelopmentTeam\n\n            ProductTeam->>Users: Launches new feature\n            Users->>FeedbackSystem: Provides feedback\n            FeedbackSystem->>DevelopmentTeam: Suggests improvements\n            DevelopmentTeam->>ProductTeam: Updates feature\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A pharmaceutical company conducts clinical trials, submits results to regulatory agencies, and gets approval for a new drug.",
        "output": "\n        sequenceDiagram\n            participant ResearchTeam\n            participant ClinicalTrials\n            participant RegulatoryAgency\n            participant ApprovalCommittee\n\n            ResearchTeam->>ClinicalTrials: Conducts trials\n            ClinicalTrials->>ResearchTeam: Reports results\n            ResearchTeam->>RegulatoryAgency: Submits findings\n            RegulatoryAgency->>ApprovalCommittee: Reviews and approves\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A retail chain launches a new store, hires staff, stocks inventory, and opens for business.",
        "output": "\n        sequenceDiagram\n            participant RetailChain\n            participant HR\n            participant InventoryTeam\n            participant Customers\n\n            RetailChain->>HR: Hires staff\n            HR->>RetailChain: Recruits and trains\n            RetailChain->>InventoryTeam: Stocks store\n            InventoryTeam->>Customers: Opens for business\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: An automotive company recalls a defective vehicle, repairs it, and returns it to the customer.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant AutoCompany\n            participant ServiceCenter\n            participant RepairTeam\n\n            AutoCompany->>Customer: Issues recall notice\n            Customer->>ServiceCenter: Schedules repair\n            ServiceCenter->>RepairTeam: Fixes defect\n            RepairTeam->>Customer: Returns vehicle\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A government agency issues a new regulation, businesses comply, and the agency monitors adherence.",
        "output": "\n        sequenceDiagram\n            participant GovAgency\n            participant Business\n            participant ComplianceDept\n\n            GovAgency->>Business: Issues regulation\n            Business->>ComplianceDept: Ensures compliance\n            ComplianceDept->>GovAgency: Reports adherence\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A car rental service processes a booking, prepares the vehicle, and hands it over to the customer.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant RentalService\n            participant FleetManagement\n            participant VehiclePreparation\n\n            Customer->>RentalService: Books vehicle\n            RentalService->>FleetManagement: Assigns vehicle\n            FleetManagement->>VehiclePreparation: Prepares car\n            VehiclePreparation->>Customer: Hands over vehicle\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A social science researcher designs a study, collects data, analyzes results, and publishes a paper.",
        "output": "\n        sequenceDiagram\n            participant Researcher\n            participant StudyParticipants\n            participant DataAnalyst\n            participant Journal\n\n            Researcher->>StudyParticipants: Conducts study\n            StudyParticipants->>Researcher: Provides data\n            Researcher->>DataAnalyst: Analyzes results\n            DataAnalyst->>Researcher: Reports findings\n            Researcher->>Journal: Publishes paper\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A medical team receives a patient in the emergency room, diagnoses the condition, treats the patient, and updates the medical record.",
        "output": "\n        sequenceDiagram\n            participant Patient\n            participant ERTeam\n            participant DiagnosisTeam\n            participant TreatmentTeam\n            participant MedicalRecords\n\n            Patient->>ERTeam: Admitted to ER\n            ERTeam->>DiagnosisTeam: Diagnoses condition\n            DiagnosisTeam->>TreatmentTeam: Prescribes treatment\n            TreatmentTeam->>MedicalRecords: Updates records\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A news agency covers an event, edits the footage, and broadcasts it on television.",
        "output": "\n        sequenceDiagram\n            participant Reporter\n            participant Editor\n            participant BroadcastTeam\n            participant Viewers\n\n            Reporter->>Editor: Sends footage\n            Editor->>BroadcastTeam: Finalizes content\n            BroadcastTeam->>Viewers: Broadcasts event\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A restaurant takes an order, prepares the food, and serves it to the customer.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant Waiter\n            participant Kitchen\n            participant Cashier\n\n            Customer->>Waiter: Places order\n            Waiter->>Kitchen: Sends order to kitchen\n            Kitchen->>Waiter: Prepares food\n            Waiter->>Customer: Serves food\n            Customer->>Cashier: Pays bill\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A hotel processes a booking, checks in the guest, provides services, and checks out the guest.",
        "output": "\n        sequenceDiagram\n            participant Guest\n            participant BookingSystem\n            participant Reception\n            participant Housekeeping\n            participant Billing\n\n            Guest->>BookingSystem: Makes reservation\n            BookingSystem->>Reception: Confirms booking\n            Guest->>Reception: Checks in\n            Reception->>Housekeeping: Provides services\n            Guest->>Billing: Checks out\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: An online learning platform registers a student, enrolls them in a course, delivers lessons, and assesses performance.",
        "output": "\n        sequenceDiagram\n            participant Student\n            participant LearningPlatform\n            participant EnrollmentSystem\n            participant Instructor\n            participant Assessment\n\n            Student->>LearningPlatform: Registers on platform\n            LearningPlatform->>EnrollmentSystem: Enrolls in course\n            EnrollmentSystem->>Instructor: Informs about new student\n            Instructor->>LearningPlatform: Delivers lessons\n            LearningPlatform->>Assessment: Conducts assessments\n            Assessment->>Student: Provides feedback\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A construction company wins a contract, designs the building, constructs it, and hands it over to the client.",
        "output": "\n        sequenceDiagram\n            participant ConstructionCompany\n            participant Client\n            participant DesignTeam\n            participant ConstructionTeam\n            participant Inspection\n\n            Client->>ConstructionCompany: Awards contract\n            ConstructionCompany->>DesignTeam: Designs building\n            DesignTeam->>ConstructionTeam: Provides plans\n            ConstructionTeam->>Inspection: Completes construction\n            Inspection->>Client: Passes inspection\n            ConstructionTeam->>Client: Hands over building\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A fashion designer creates a new collection, showcases it at a fashion show, and sells it to buyers.",
        "output": "\n        sequenceDiagram\n            participant Designer\n            participant ProductionTeam\n            participant FashionShow\n            participant Buyers\n\n            Designer->>ProductionTeam: Designs collection\n            ProductionTeam->>Designer: Produces garments\n            Designer->>FashionShow: Showcases collection\n            Buyers->>Designer: Places orders\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: An educational institution hires a new teacher, assigns classes, and evaluates their performance.",
        "output": "\n        sequenceDiagram\n            participant Institution\n            participant HR\n            participant Teacher\n            participant Students\n            participant Evaluation\n\n            Institution->>HR: Recruits teacher\n            HR->>Teacher: Onboards new hire\n            Institution->>Teacher: Assigns classes\n            Teacher->>Students: Teaches classes\n            Evaluation->>Institution: Assesses performance\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A tech startup develops a mobile app, tests it, launches it on app stores, and gathers user feedback.",
        "output": "\n        sequenceDiagram\n            participant Startup\n            participant DevelopmentTeam\n            participant TestingTeam\n            participant AppStore\n            participant Users\n\n            Startup->>DevelopmentTeam: Develops app\n            DevelopmentTeam->>TestingTeam: Submits for testing\n            TestingTeam->>DevelopmentTeam: Reports issues\n            DevelopmentTeam->>AppStore: Launches app\n            AppStore->>Users: Provides access\n            Users->>Startup: Gives feedback\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A courier company receives a package, sorts it, transports it, and delivers it to the recipient.",
        "output": "\n        sequenceDiagram\n            participant Sender\n            participant CourierCompany\n            participant SortingFacility\n            participant DeliveryDriver\n            participant Recipient\n\n            Sender->>CourierCompany: Hands over package\n            CourierCompany->>SortingFacility: Sorts package\n            SortingFacility->>DeliveryDriver: Assigns for delivery\n            DeliveryDriver->>Recipient: Delivers package\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A telecommunication company installs a new internet connection, configures the router, and activates the service for the customer.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant TelecomCompany\n            participant Technician\n            participant Router\n            participant ActivationTeam\n\n            Customer->>TelecomCompany: Requests new connection\n            TelecomCompany->>Technician: Schedules installation\n            Technician->>Router: Configures equipment\n            Technician->>ActivationTeam: Requests activation\n            ActivationTeam->>Customer: Activates service\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: An e-commerce platform launches a new product line, markets it, and manages customer orders.",
        "output": "\n        sequenceDiagram\n            participant ECommercePlatform\n            participant Marketing\n            participant Customers\n            participant OrderManagement\n\n            ECommercePlatform->>Marketing: Launches product line\n            Marketing->>Customers: Promotes product\n            Customers->>OrderManagement: Places orders\n            OrderManagement->>Customers: Processes orders\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: An online bank processes a loan application, approves the loan, and disburses the funds.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant OnlineBank\n            participant LoanProcessing\n            participant ApprovalTeam\n            participant Disbursement\n\n            Customer->>OnlineBank: Submits loan application\n            OnlineBank->>LoanProcessing: Reviews application\n            LoanProcessing->>ApprovalTeam: Seeks approval\n            ApprovalTeam->>Disbursement: Approves loan\n            Disbursement->>Customer: Disburses funds\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A government department launches a public awareness campaign, distributes informational materials, and tracks its impact.",
        "output": "\n        sequenceDiagram\n            participant Government\n            participant CampaignTeam\n            participant Public\n            participant ImpactAssessment\n\n            Government->>CampaignTeam: Launches campaign\n            CampaignTeam->>Public: Distributes materials\n            Public->>ImpactAssessment: Provides feedback\n            ImpactAssessment->>Government: Tracks impact\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: An airport handles flight arrivals, manages baggage, and facilitates passenger transfers.",
        "output": "\n        sequenceDiagram\n            participant Flight\n            participant Airport\n            participant BaggageHandling\n            participant Passengers\n            participant TransferService\n\n            Flight->>Airport: Arrives at gate\n            Airport->>BaggageHandling: Manages baggage\n            BaggageHandling->>Passengers: Delivers baggage\n            Airport->>TransferService: Facilitates transfers\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A law firm takes on a new client, conducts legal research, files a lawsuit, and represents the client in court.",
        "output": "\n        sequenceDiagram\n            participant Client\n            participant LawFirm\n            participant ResearchTeam\n            participant Court\n\n            Client->>LawFirm: Engages services\n            LawFirm->>ResearchTeam: Conducts research\n            ResearchTeam->>LawFirm: Provides findings\n            LawFirm->>Court: Files lawsuit\n            Court->>LawFirm: Schedules hearing\n            LawFirm->>Client: Represents in court\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A recruitment agency sources candidates, conducts interviews, and places them in jobs.",
        "output": "\n        sequenceDiagram\n            participant Employer\n            participant RecruitmentAgency\n            participant Candidates\n            participant Interviewer\n            participant HR\n\n            Employer->>RecruitmentAgency: Requests candidates\n            RecruitmentAgency->>Candidates: Sources candidates\n            Candidates->>Interviewer: Attends interviews\n            Interviewer->>HR: Selects candidates\n            HR->>Employer: Places candidates\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A hospital schedules a surgery, prepares the operating room, performs the surgery, and monitors post-operative recovery.",
        "output": "\n        sequenceDiagram\n            participant Patient\n            participant SurgeryScheduling\n            participant OperatingRoom\n            participant SurgeryTeam\n            participant RecoveryRoom\n\n            Patient->>SurgeryScheduling: Schedules surgery\n            SurgeryScheduling->>OperatingRoom: Prepares room\n            SurgeryTeam->>Patient: Performs surgery\n            OperatingRoom->>RecoveryRoom: Transfers patient\n            RecoveryRoom->>Patient: Monitors recovery\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A charity organization launches a fundraising campaign, receives donations, and distributes aid to beneficiaries.",
        "output": "\n        sequenceDiagram\n            participant Charity\n            participant Donors\n            participant FundraisingTeam\n            participant Beneficiaries\n\n            Charity->>FundraisingTeam: Launches campaign\n            FundraisingTeam->>Donors: Requests donations\n            Donors->>Charity: Sends funds\n            Charity->>Beneficiaries: Distributes aid\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: An energy company sets up a new solar plant, connects it to the grid, and supplies electricity to consumers.",
        "output": "\n        sequenceDiagram\n            participant EnergyCompany\n            participant ConstructionTeam\n            participant GridOperator\n            participant Consumers\n\n            EnergyCompany->>ConstructionTeam: Builds solar plant\n            ConstructionTeam->>GridOperator: Connects to grid\n            GridOperator->>Consumers: Supplies electricity\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A sports team recruits new players, conducts training sessions, and participates in a tournament.",
        "output": "\n        sequenceDiagram\n            participant TeamManager\n            participant Recruiter\n            participant Players\n            participant Coaches\n            participant TournamentOrganizers\n\n            TeamManager->>Recruiter: Identifies players\n            Recruiter->>Players: Recruits players\n            TeamManager->>Coaches: Plans training\n            Coaches->>Players: Conducts training\n            TeamManager->>TournamentOrganizers: Registers team\n            Players->>TournamentOrganizers: Participates in matches\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A healthcare system manages patient admissions, provides treatment, and discharges patients.",
        "output": "\n        sequenceDiagram\n            participant Patient\n            participant AdmissionDesk\n            participant TreatmentTeam\n            participant Billing\n            participant DischargeDesk\n\n            Patient->>AdmissionDesk: Admits to hospital\n            AdmissionDesk->>TreatmentTeam: Provides treatment plan\n            TreatmentTeam->>Billing: Sends treatment costs\n            Billing->>Patient: Processes payment\n            DischargeDesk->>Patient: Discharges from hospital\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A music label signs a new artist, records an album, and releases it on streaming platforms.",
        "output": "\n        sequenceDiagram\n            participant Artist\n            participant MusicLabel\n            participant RecordingStudio\n            participant StreamingPlatforms\n            participant Listeners\n\n            MusicLabel->>Artist: Signs contract\n            Artist->>RecordingStudio: Records album\n            RecordingStudio->>MusicLabel: Delivers album\n            MusicLabel->>StreamingPlatforms: Releases album\n            Listeners->>StreamingPlatforms: Streams music\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A financial institution offers investment advice, manages portfolios, and reports on performance to clients.",
        "output": "\n        sequenceDiagram\n            participant Client\n            participant FinancialAdvisor\n            participant PortfolioManager\n            participant ReportingTeam\n\n            Client->>FinancialAdvisor: Seeks investment advice\n            FinancialAdvisor->>PortfolioManager: Allocates investments\n            PortfolioManager->>ReportingTeam: Tracks performance\n            ReportingTeam->>Client: Provides reports\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A supermarket restocks shelves, manages checkout, and processes payments for customers.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant Supermarket\n            participant StockRoom\n            participant Cashier\n            participant PaymentGateway\n\n            Supermarket->>StockRoom: Restocks shelves\n            Customer->>Supermarket: Selects products\n            Customer->>Cashier: Proceeds to checkout\n            Cashier->>PaymentGateway: Processes payment\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A gaming company develops a new game, tests it, launches it, and supports players with updates.",
        "output": "\n        sequenceDiagram\n            participant GameStudio\n            participant TestingTeam\n            participant Marketing\n            participant Players\n            participant SupportTeam\n\n            GameStudio->>TestingTeam: Develops game\n            TestingTeam->>GameStudio: Reports bugs\n            GameStudio->>Marketing: Launches game\n            Marketing->>Players: Promotes game\n            Players->>SupportTeam: Requests support\n            SupportTeam->>GameStudio: Suggests updates\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A ride-sharing app connects drivers with passengers, tracks the ride, and processes payments.",
        "output": "\n        sequenceDiagram\n            participant Passenger\n            participant RideSharingApp\n            participant Driver\n            participant PaymentSystem\n\n            Passenger->>RideSharingApp: Requests ride\n            RideSharingApp->>Driver: Assigns ride\n            Driver->>Passenger: Picks up passenger\n            RideSharingApp->>Passenger: Tracks ride\n            Passenger->>PaymentSystem: Pays for ride\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A cybersecurity firm detects a threat, analyzes it, and deploys countermeasures to protect client data.",
        "output": "\n        sequenceDiagram\n            participant Client\n            participant CyberSecurity\n            participant ThreatDetection\n            participant ResponseTeam\n            participant ClientData\n\n            Client->>CyberSecurity: Engages security services\n            ThreatDetection->>CyberSecurity: Detects threat\n            CyberSecurity->>ResponseTeam: Analyzes and deploys countermeasures\n            ResponseTeam->>ClientData: Protects data\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A telecom company rolls out a 5G network, upgrades infrastructure, and provides services to customers.",
        "output": "\n        sequenceDiagram\n            participant TelecomCompany\n            participant NetworkTeam\n            participant Infrastructure\n            participant Customers\n\n            TelecomCompany->>NetworkTeam: Initiates 5G rollout\n            NetworkTeam->>Infrastructure: Upgrades network\n            Infrastructure->>TelecomCompany: Confirms upgrade\n            TelecomCompany->>Customers: Provides 5G services\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A robotics company designs a new robot, prototypes it, conducts testing, and begins mass production.",
        "output": "\n        sequenceDiagram\n            participant RoboticsCompany\n            participant DesignTeam\n            participant Prototyping\n            participant TestingTeam\n            participant Production\n\n            RoboticsCompany->>DesignTeam: Designs new robot\n            DesignTeam->>Prototyping: Builds prototype\n            Prototyping->>TestingTeam: Conducts testing\n            TestingTeam->>Production: Approves for mass production\n            Production->>RoboticsCompany: Begins production\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A cosmetics brand develops a new product, tests it for safety, and markets it globally.",
        "output": "\n        sequenceDiagram\n            participant CosmeticsBrand\n            participant R&D\n            participant TestingTeam\n            participant Marketing\n            participant GlobalDistributors\n\n            CosmeticsBrand->>R&D: Develops new product\n            R&D->>TestingTeam: Tests for safety\n            TestingTeam->>CosmeticsBrand: Approves product\n            CosmeticsBrand->>Marketing: Plans global campaign\n            Marketing->>GlobalDistributors: Distributes product\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: An automotive service center schedules a vehicle for maintenance, performs the service, and returns the vehicle to the customer.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant ServiceCenter\n            participant MaintenanceTeam\n            participant Billing\n\n            Customer->>ServiceCenter: Schedules maintenance\n            ServiceCenter->>MaintenanceTeam: Assigns service\n            MaintenanceTeam->>Billing: Completes service\n            Billing->>Customer: Processes payment\n            MaintenanceTeam->>Customer: Returns vehicle\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A city council proposes a new zoning law, holds public hearings, and implements the law.",
        "output": "\n        sequenceDiagram\n            participant CityCouncil\n            participant Public\n            participant LegalTeam\n            participant Enforcement\n\n            CityCouncil->>Public: Proposes new zoning law\n            Public->>CityCouncil: Participates in hearings\n            CityCouncil->>LegalTeam: Drafts final law\n            LegalTeam->>Enforcement: Implements law\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A university manages applications for a PhD program, reviews them, and admits students.",
        "output": "\n        sequenceDiagram\n            participant Applicant\n            participant AdmissionsCommittee\n            participant ReviewBoard\n            participant University\n\n            Applicant->>University: Submits application\n            University->>ReviewBoard: Sends for review\n            ReviewBoard->>AdmissionsCommittee: Recommends admissions\n            AdmissionsCommittee->>University: Admits students\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A postal service processes incoming mail, sorts it, and delivers it to recipients.",
        "output": "\n        sequenceDiagram\n            participant Sender\n            participant PostalService\n            participant SortingFacility\n            participant MailCarrier\n            participant Recipient\n\n            Sender->>PostalService: Sends mail\n            PostalService->>SortingFacility: Sorts mail\n            SortingFacility->>MailCarrier: Assigns for delivery\n            MailCarrier->>Recipient: Delivers mail\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A luxury car brand customizes a vehicle, assembles it, and delivers it to the customer.",
        "output": "\n        sequenceDiagram\n            participant Customer\n            participant SalesConsultant\n            participant DesignTeam\n            participant AssemblyLine\n            participant DeliveryService\n\n            Customer->>SalesConsultant: Requests customization\n            SalesConsultant->>DesignTeam: Finalizes design\n            DesignTeam->>AssemblyLine: Sends to production\n            AssemblyLine->>DeliveryService: Prepares for delivery\n            DeliveryService->>Customer: Delivers custom car\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A technology firm develops an AI model, trains it on data, and deploys it for business use.",
        "output": "\n        sequenceDiagram\n            participant TechFirm\n            participant AIResearchTeam\n            participant DataEngineers\n            participant BusinessUnit\n\n            TechFirm->>AIResearchTeam: Develops AI model\n            AIResearchTeam->>DataEngineers: Provides data\n            DataEngineers->>AIResearchTeam: Trains model\n            AIResearchTeam->>BusinessUnit: Deploys model\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A logistics company optimizes routes, loads cargo, and delivers shipments on schedule.",
        "output": "\n        sequenceDiagram\n            participant LogisticsCompany\n            participant RoutePlanner\n            participant LoadingDock\n            participant DeliveryDriver\n            participant Customer\n\n            LogisticsCompany->>RoutePlanner: Optimizes routes\n            RoutePlanner->>LoadingDock: Loads cargo\n            LoadingDock->>DeliveryDriver: Assigns delivery\n            DeliveryDriver->>Customer: Delivers shipment\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A non-profit organization organizes a charity auction, receives bids, and awards items to the highest bidders.",
        "output": "\n        sequenceDiagram\n            participant NonProfit\n            participant Auctioneer\n            participant Bidders\n            participant Winners\n\n            NonProfit->>Auctioneer: Organizes auction\n            Bidders->>Auctioneer: Places bids\n            Auctioneer->>Winners: Awards items\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A real estate developer acquires land, designs a housing project, builds homes, and sells them to buyers.",
        "output": "\n        sequenceDiagram\n            participant Developer\n            participant LandOwner\n            participant Architect\n            participant ConstructionTeam\n            participant Buyers\n\n            Developer->>LandOwner: Acquires land\n            Developer->>Architect: Designs housing project\n            Architect->>ConstructionTeam: Provides plans\n            ConstructionTeam->>Developer: Builds homes\n            Buyers->>Developer: Purchases homes\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A government conducts a national census, collects data, and publishes population statistics.",
        "output": "\n        sequenceDiagram\n            participant Government\n            participant CensusBureau\n            participant FieldAgents\n            participant DataAnalysts\n            participant Public\n\n            Government->>CensusBureau: Organizes census\n            CensusBureau->>FieldAgents: Collects data\n            FieldAgents->>DataAnalysts: Submits data\n            DataAnalysts->>Government: Analyzes results\n            Government->>Public: Publishes statistics\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A cloud service provider provisions servers, deploys applications, and monitors performance for clients.",
        "output": "\n        sequenceDiagram\n            participant Client\n            participant CloudProvider\n            participant ServerProvisioning\n            participant DeploymentTeam\n            participant Monitoring\n\n            Client->>CloudProvider: Requests servers\n            CloudProvider->>ServerProvisioning: Provisions servers\n            ServerProvisioning->>DeploymentTeam: Deploys applications\n            Monitoring->>Client: Monitors performance\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: An airline manages flight bookings, processes check-in, and handles baggage for passengers.",
        "output": "\n        sequenceDiagram\n            participant Passenger\n            participant BookingSystem\n            participant CheckIn\n            participant BaggageHandling\n\n            Passenger->>BookingSystem: Books flight\n            BookingSystem->>CheckIn: Confirms booking\n            Passenger->>CheckIn: Checks in\n            CheckIn->>BaggageHandling: Sends baggage\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML sequence diagram for the following scenario: A government agency monitors air quality, analyzes data, and enforces environmental regulations.",
        "output": "\n        sequenceDiagram\n            participant GovernmentAgency\n            participant MonitoringStation\n            participant DataAnalyst\n            participant EnvironmentalRegulations\n\n            MonitoringStation->>GovernmentAgency: Sends air quality data\n            GovernmentAgency->>DataAnalyst: Analyzes data\n            DataAnalyst->>GovernmentAgency: Reports findings\n            GovernmentAgency->>EnvironmentalRegulations: Enforces regulations\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A public bus transportation system where buses start from a terminal, move to different stops, pick up\/drop off passengers, and return to the terminal.",
        "output": "\n        stateDiagram-v2\n            [*] --> Terminal\n            Terminal --> BusStop1 : Move to Stop 1\n            BusStop1 --> BusStop2 : Move to Stop 2\n            BusStop2 --> BusStop3 : Move to Stop 3\n            BusStop3 --> Terminal : Return to Terminal\n            BusStop1 --> Terminal : Return to Terminal\n            BusStop2 --> Terminal : Return to Terminal\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A student registration process where a student applies for a course, gets reviewed, gets accepted or rejected, and then proceeds to enroll or apply again.",
        "output": "\n        stateDiagram-v2\n            [*] --> Apply\n            Apply --> Review\n            Review --> Accept : Application Approved\n            Review --> Reject : Application Denied\n            Accept --> Enroll : Proceed to Enrollment\n            Reject --> Apply : Reapply\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A hospital patient management system where a patient checks in, undergoes diagnosis, receives treatment, and then gets discharged or referred for further treatment.",
        "output": "\n        stateDiagram-v2\n            [*] --> CheckIn\n            CheckIn --> Diagnosis\n            Diagnosis --> Treatment : Diagnosis Completed\n            Treatment --> Discharge : Treatment Successful\n            Treatment --> Referral : Further Treatment Needed\n            Referral --> Diagnosis : Additional Diagnosis Required\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A bank loan approval process where an applicant submits an application, it is reviewed, and then it is either approved, rejected, or requires additional documentation.",
        "output": "\n        stateDiagram-v2\n            [*] --> SubmitApplication\n            SubmitApplication --> Review\n            Review --> Approved : Application Approved\n            Review --> Rejected : Application Rejected\n            Review --> AdditionalDocs : More Documents Needed\n            AdditionalDocs --> Review : Resubmit with Documents\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A pandemic response system where an outbreak is detected, response strategies are developed, measures are implemented, and the situation is monitored until resolved or escalated.",
        "output": "\n        stateDiagram-v2\n            [*] --> OutbreakDetected\n            OutbreakDetected --> DevelopResponse\n            DevelopResponse --> ImplementMeasures : Response Plan Created\n            ImplementMeasures --> MonitorSituation : Measures in Place\n            MonitorSituation --> Resolved : Situation Under Control\n            MonitorSituation --> Escalate : Situation Worsens\n            Escalate --> DevelopResponse : Revise Response Plan\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A university course management system where courses are created, students enroll, classes are conducted, and students either pass or fail.",
        "output": "\n        stateDiagram-v2\n            [*] --> CourseCreation\n            CourseCreation --> Enrollment : Courses Available\n            Enrollment --> ConductClasses : Students Enrolled\n            ConductClasses --> Pass : Successful Completion\n            ConductClasses --> Fail : Unsuccessful Completion\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A disaster management system where a disaster is identified, emergency services are deployed, relief is provided, and recovery efforts are initiated.",
        "output": "\n        stateDiagram-v2\n            [*] --> DisasterIdentified\n            DisasterIdentified --> DeployServices : Emergency Declared\n            DeployServices --> ProvideRelief : Services in Action\n            ProvideRelief --> RecoveryEfforts : Immediate Needs Met\n            RecoveryEfforts --> Normalcy : Recovery Completed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A hotel booking system where a guest searches for a room, makes a reservation, checks in, stays, and checks out.",
        "output": "\n        stateDiagram-v2\n            [*] --> SearchRoom\n            SearchRoom --> Reservation : Room Available\n            Reservation --> CheckIn : Reservation Confirmed\n            CheckIn --> Stay : Guest Checked In\n            Stay --> CheckOut : Stay Completed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A marketing campaign process where a campaign is planned, launched, monitored, and evaluated for success or adjustments.",
        "output": "\n        stateDiagram-v2\n            [*] --> PlanCampaign\n            PlanCampaign --> Launch : Campaign Ready\n            Launch --> Monitor : Campaign Live\n            Monitor --> EvaluateSuccess : Campaign Monitored\n            EvaluateSuccess --> Success : Campaign Successful\n            EvaluateSuccess --> Adjust : Campaign Needs Improvement\n            Adjust --> Monitor : Re-launch Campaign\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A product development process where ideas are generated, prototypes are created, products are tested, and then either approved for production or sent back for redesign.",
        "output": "\n        stateDiagram-v2\n            [*] --> IdeaGeneration\n            IdeaGeneration --> PrototypeCreation : Idea Selected\n            PrototypeCreation --> Testing : Prototype Ready\n            Testing --> Approval : Testing Successful\n            Testing --> Redesign : Testing Failed\n            Redesign --> PrototypeCreation : Redesign Completed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A flight booking system where a customer searches for flights, books a ticket, checks in, boards the flight, and either takes off or the flight is delayed.",
        "output": "\n        stateDiagram-v2\n            [*] --> SearchFlight\n            SearchFlight --> BookTicket : Flight Available\n            BookTicket --> CheckIn : Ticket Booked\n            CheckIn --> Board : Checked In\n            Board --> TakeOff : Flight On Time\n            Board --> Delay : Flight Delayed\n            Delay --> TakeOff : Delayed Flight Takes Off\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A retail store inventory system where products are stocked, items are sold, inventory is checked, and orders are placed to restock.",
        "output": "\n        stateDiagram-v2\n            [*] --> StockInventory\n            StockInventory --> SellItems : Items Available\n            SellItems --> CheckInventory : Sales Completed\n            CheckInventory --> Restock : Inventory Low\n            Restock --> StockInventory : Order Received\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A food delivery app where a customer places an order, the restaurant prepares the food, the delivery is picked up, and the food is delivered to the customer.",
        "output": "\n        stateDiagram-v2\n            [*] --> PlaceOrder\n            PlaceOrder --> PrepareFood : Order Received\n            PrepareFood --> PickupDelivery : Food Ready\n            PickupDelivery --> Deliver : Delivery Picked Up\n            Deliver --> Complete : Food Delivered\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: An online shopping system where a customer browses products, adds items to the cart, checks out, makes payment, and receives the order.",
        "output": "\n        stateDiagram-v2\n            [*] --> BrowseProducts\n            BrowseProducts --> AddToCart : Items Selected\n            AddToCart --> Checkout : Ready to Purchase\n            Checkout --> MakePayment : Payment Information Provided\n            MakePayment --> ReceiveOrder : Order Placed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A healthcare appointment scheduling system where a patient books an appointment, receives a confirmation, attends the appointment, and provides feedback.",
        "output": "\n        stateDiagram-v2\n            [*] --> BookAppointment\n            BookAppointment --> ConfirmAppointment : Slot Available\n            ConfirmAppointment --> AttendAppointment : Appointment Confirmed\n            AttendAppointment --> ProvideFeedback : Appointment Completed\n            ProvideFeedback --> [*] : Feedback Submitted\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A university grading system where a student submits an assignment, it is graded by the instructor, the grade is posted, and the student views the grade.",
        "output": "\n        stateDiagram-v2\n            [*] --> SubmitAssignment\n            SubmitAssignment --> GradeAssignment : Assignment Received\n            GradeAssignment --> PostGrade : Grading Completed\n            PostGrade --> ViewGrade : Grade Available\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: An airport security process where a passenger checks in, passes through security, boards the flight, and departs.",
        "output": "\n        stateDiagram-v2\n            [*] --> CheckIn\n            CheckIn --> SecurityCheck : Boarding Pass Issued\n            SecurityCheck --> Boarding : Cleared Security\n            Boarding --> Departure : Boarded Flight\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: An event planning process where an event is planned, logistics are arranged, the event is conducted, and feedback is collected.",
        "output": "\n        stateDiagram-v2\n            [*] --> PlanEvent\n            PlanEvent --> ArrangeLogistics : Event Details Finalized\n            ArrangeLogistics --> ConductEvent : Logistics in Place\n            ConductEvent --> CollectFeedback : Event Completed\n            CollectFeedback --> [*] : Feedback Received\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A banking transaction where a customer initiates a transfer, the bank processes the transfer, the funds are transferred, and the customer receives confirmation.",
        "output": "\n        stateDiagram-v2\n            [*] --> InitiateTransfer\n            InitiateTransfer --> ProcessTransfer : Transfer Details Provided\n            ProcessTransfer --> TransferFunds : Transfer Authorized\n            TransferFunds --> ConfirmTransfer : Funds Transferred\n            ConfirmTransfer --> [*] : Confirmation Sent\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A construction project management system where a project is initiated, resources are allocated, work is performed, and the project is completed.",
        "output": "\n        stateDiagram-v2\n            [*] --> InitiateProject\n            InitiateProject --> AllocateResources : Project Approved\n            AllocateResources --> PerformWork : Resources Ready\n            PerformWork --> CompleteProject : Work Completed\n            CompleteProject --> [*] : Project Closed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A car rental system where a customer books a car, picks up the car, uses it, and returns it to the rental company.",
        "output": "\n        stateDiagram-v2\n            [*] --> BookCar\n            BookCar --> PickupCar : Reservation Confirmed\n            PickupCar --> UseCar : Car Collected\n            UseCar --> ReturnCar : Rental Period Completed\n            ReturnCar --> [*] : Car Returned\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A voting process where a voter registers, casts a vote, the vote is counted, and the result is announced.",
        "output": "\n        stateDiagram-v2\n            [*] --> RegisterVoter\n            RegisterVoter --> CastVote : Voter Registered\n            CastVote --> CountVote : Vote Submitted\n            CountVote --> AnnounceResult : Votes Counted\n            AnnounceResult --> [*] : Result Declared\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: An insurance claim process where a policyholder files a claim, the claim is reviewed, the claim is either approved or denied, and the policyholder is notified.",
        "output": "\n        stateDiagram-v2\n            [*] --> FileClaim\n            FileClaim --> ReviewClaim : Claim Submitted\n            ReviewClaim --> ApproveClaim : Claim Valid\n            ReviewClaim --> DenyClaim : Claim Invalid\n            ApproveClaim --> NotifyPolicyholder : Claim Approved\n            DenyClaim --> NotifyPolicyholder : Claim Denied\n            NotifyPolicyholder --> [*] : Notification Sent\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A hotel check-in process where a guest arrives, checks in, stays, and checks out.",
        "output": "\n        stateDiagram-v2\n            [*] --> Arrive\n            Arrive --> CheckIn : At Reception\n            CheckIn --> Stay : Room Assigned\n            Stay --> CheckOut : Stay Completed\n            CheckOut --> [*] : Leave Hotel\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A movie rental system where a user browses movies, rents a movie, watches it, and returns it.",
        "output": "\n        stateDiagram-v2\n            [*] --> BrowseMovies\n            BrowseMovies --> RentMovie : Movie Selected\n            RentMovie --> WatchMovie : Movie Rented\n            WatchMovie --> ReturnMovie : Movie Watched\n            ReturnMovie --> [*] : Movie Returned\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: An IT support ticket system where a user submits a ticket, the issue is diagnosed, the issue is resolved, and the ticket is closed.",
        "output": "\n        stateDiagram-v2\n            [*] --> SubmitTicket\n            SubmitTicket --> DiagnoseIssue : Ticket Created\n            DiagnoseIssue --> ResolveIssue : Issue Identified\n            ResolveIssue --> CloseTicket : Issue Resolved\n            CloseTicket --> [*] : Ticket Closed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: An employee onboarding process where an offer is extended, the employee accepts, completes paperwork, undergoes orientation, and starts work.",
        "output": "\n        stateDiagram-v2\n            [*] --> ExtendOffer\n            ExtendOffer --> AcceptOffer : Offer Sent\n            AcceptOffer --> CompletePaperwork : Offer Accepted\n            CompletePaperwork --> Orientation : Paperwork Completed\n            Orientation --> StartWork : Orientation Done\n            StartWork --> [*] : Employee Starts\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A patient discharge process where a patient completes treatment, receives discharge instructions, schedules a follow-up, and leaves the hospital.",
        "output": "\n        stateDiagram-v2\n            [*] --> CompleteTreatment\n            CompleteTreatment --> DischargeInstructions : Treatment Successful\n            DischargeInstructions --> ScheduleFollowUp : Instructions Given\n            ScheduleFollowUp --> LeaveHospital : Follow-up Scheduled\n            LeaveHospital --> [*] : Discharged\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A public transportation ticketing system where a passenger selects a route, purchases a ticket, uses the ticket, and the ticket expires after the trip.",
        "output": "\n        stateDiagram-v2\n            [*] --> SelectRoute\n            SelectRoute --> PurchaseTicket : Route Selected\n            PurchaseTicket --> UseTicket : Ticket Purchased\n            UseTicket --> TripComplete : Ticket Validated\n            TripComplete --> TicketExpires : Trip Finished\n            TicketExpires --> [*] : Ticket Expired\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A healthcare triage system where a patient arrives, is assessed, treatment is prioritized, and the patient is treated or referred.",
        "output": "\n        stateDiagram-v2\n            [*] --> ArriveAtHospital\n            ArriveAtHospital --> Assessment : Patient Arrived\n            Assessment --> PrioritizeTreatment : Severity Evaluated\n            PrioritizeTreatment --> TreatPatient : Immediate Treatment\n            PrioritizeTreatment --> Referral : Referred for Further Care\n            TreatPatient --> [*] : Treatment Completed\n            Referral --> [*] : Referred\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A travel itinerary planning system where a user selects destinations, books accommodations, plans activities, and starts the trip.",
        "output": "\n        stateDiagram-v2\n            [*] --> SelectDestinations\n            SelectDestinations --> BookAccommodations : Destinations Chosen\n            BookAccommodations --> PlanActivities : Accommodations Booked\n            PlanActivities --> StartTrip : Activities Planned\n            StartTrip --> [*] : Trip Started\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A hotel housekeeping process where rooms are cleaned, supplies are restocked, inspections are conducted, and rooms are marked as ready.",
        "output": "\n        stateDiagram-v2\n            [*] --> CleanRoom\n            CleanRoom --> RestockSupplies : Room Cleaned\n            RestockSupplies --> ConductInspection : Supplies Restocked\n            ConductInspection --> MarkAsReady : Room Inspected\n            MarkAsReady --> [*] : Room Ready\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: An e-commerce return process where a customer initiates a return, ships the item, the item is received, and the refund is processed.",
        "output": "\n        stateDiagram-v2\n            [*] --> InitiateReturn\n            InitiateReturn --> ShipItem : Return Authorized\n            ShipItem --> ReceiveItem : Item Shipped\n            ReceiveItem --> ProcessRefund : Item Received\n            ProcessRefund --> [*] : Refund Issued\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A ride-sharing app where a rider requests a ride, the driver is assigned, the ride is completed, and the rider provides feedback.",
        "output": "\n        stateDiagram-v2\n            [*] --> RequestRide\n            RequestRide --> AssignDriver : Ride Requested\n            AssignDriver --> CompleteRide : Driver Assigned\n            CompleteRide --> ProvideFeedback : Ride Completed\n            ProvideFeedback --> [*] : Feedback Provided\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A job application process where a candidate submits an application, the application is reviewed, interviews are conducted, and a decision is made.",
        "output": "\n        stateDiagram-v2\n            [*] --> SubmitApplication\n            SubmitApplication --> ReviewApplication : Application Received\n            ReviewApplication --> ConductInterviews : Application Shortlisted\n            ConductInterviews --> MakeDecision : Interviews Conducted\n            MakeDecision --> OfferJob : Offer Extended\n            MakeDecision --> RejectCandidate : Application Rejected\n            OfferJob --> [*] : Job Offered\n            RejectCandidate --> [*] : Rejection Notified\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A vehicle maintenance process where a vehicle is brought in for service, the service is performed, the vehicle is inspected, and then returned to the owner.",
        "output": "\n        stateDiagram-v2\n            [*] --> BringVehicle\n            BringVehicle --> PerformService : Vehicle Arrived\n            PerformService --> InspectVehicle : Service Completed\n            InspectVehicle --> ReturnVehicle : Inspection Passed\n            ReturnVehicle --> [*] : Vehicle Returned\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A financial investment process where an investor researches options, invests in a portfolio, monitors performance, and adjusts the portfolio as needed.",
        "output": "\n        stateDiagram-v2\n            [*] --> ResearchOptions\n            ResearchOptions --> InvestPortfolio : Options Analyzed\n            InvestPortfolio --> MonitorPerformance : Investment Made\n            MonitorPerformance --> AdjustPortfolio : Performance Evaluated\n            AdjustPortfolio --> MonitorPerformance : Portfolio Adjusted\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A library book borrowing system where a user searches for a book, checks it out, reads it, and returns it.",
        "output": "\n        stateDiagram-v2\n            [*] --> SearchBook\n            SearchBook --> CheckoutBook : Book Found\n            CheckoutBook --> ReadBook : Book Borrowed\n            ReadBook --> ReturnBook : Reading Completed\n            ReturnBook --> [*] : Book Returned\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A restaurant order process where a customer places an order, the order is prepared, the order is served, and the customer pays the bill.",
        "output": "\n        stateDiagram-v2\n            [*] --> PlaceOrder\n            PlaceOrder --> PrepareOrder : Order Taken\n            PrepareOrder --> ServeOrder : Food Prepared\n            ServeOrder --> PayBill : Food Served\n            PayBill --> [*] : Payment Completed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: An employee performance review process where an employee is evaluated, feedback is given, goals are set, and the review is completed.",
        "output": "\n        stateDiagram-v2\n            [*] --> EvaluatePerformance\n            EvaluatePerformance --> GiveFeedback : Evaluation Done\n            GiveFeedback --> SetGoals : Feedback Provided\n            SetGoals --> CompleteReview : Goals Agreed\n            CompleteReview --> [*] : Review Completed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A project management system where a project is planned, tasks are assigned, progress is tracked, and the project is completed.",
        "output": "\n        stateDiagram-v2\n            [*] --> PlanProject\n            PlanProject --> AssignTasks : Project Plan Ready\n            AssignTasks --> TrackProgress : Tasks Distributed\n            TrackProgress --> CompleteProject : All Tasks Done\n            CompleteProject --> [*] : Project Closed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A clinical trial process where participants are enrolled, treatments are administered, data is collected, and the trial is analyzed.",
        "output": "\n        stateDiagram-v2\n            [*] --> EnrollParticipants\n            EnrollParticipants --> AdministerTreatment : Participants Enrolled\n            AdministerTreatment --> CollectData : Treatment Given\n            CollectData --> AnalyzeTrial : Data Collected\n            AnalyzeTrial --> [*] : Trial Analyzed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A website development process where requirements are gathered, design is created, development is done, testing is performed, and the site is launched.",
        "output": "\n        stateDiagram-v2\n            [*] --> GatherRequirements\n            GatherRequirements --> CreateDesign : Requirements Analyzed\n            CreateDesign --> DevelopSite : Design Approved\n            DevelopSite --> TestSite : Development Completed\n            TestSite --> LaunchSite : Testing Successful\n            LaunchSite --> [*] : Site Launched\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A sales process where a lead is generated, a sales pitch is made, the deal is negotiated, and the sale is closed.",
        "output": "\n        stateDiagram-v2\n            [*] --> GenerateLead\n            GenerateLead --> MakePitch : Lead Identified\n            MakePitch --> NegotiateDeal : Pitch Delivered\n            NegotiateDeal --> CloseSale : Agreement Reached\n            CloseSale --> [*] : Sale Completed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A customer support process where a customer contacts support, the issue is diagnosed, a solution is provided, and the case is closed.",
        "output": "\n        stateDiagram-v2\n            [*] --> ContactSupport\n            ContactSupport --> DiagnoseIssue : Support Contacted\n            DiagnoseIssue --> ProvideSolution : Issue Identified\n            ProvideSolution --> CloseCase : Solution Provided\n            CloseCase --> [*] : Case Closed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A logistics process where a shipment is scheduled, the package is picked up, it is transported, and it is delivered.",
        "output": "\n        stateDiagram-v2\n            [*] --> ScheduleShipment\n            ScheduleShipment --> PickupPackage : Shipment Scheduled\n            PickupPackage --> TransportPackage : Package Picked Up\n            TransportPackage --> DeliverPackage : Package In Transit\n            DeliverPackage --> [*] : Package Delivered\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: An emergency response system where an emergency is reported, first responders are dispatched, the situation is assessed, and the emergency is resolved.",
        "output": "\n        stateDiagram-v2\n            [*] --> ReportEmergency\n            ReportEmergency --> DispatchResponders : Emergency Reported\n            DispatchResponders --> AssessSituation : Responders On Scene\n            AssessSituation --> ResolveEmergency : Situation Assessed\n            ResolveEmergency --> [*] : Emergency Resolved\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A public health vaccination campaign where a target population is identified, vaccines are distributed, vaccinations are administered, and coverage is monitored.",
        "output": "\n        stateDiagram-v2\n            [*] --> IdentifyPopulation\n            IdentifyPopulation --> DistributeVaccines : Population Targeted\n            DistributeVaccines --> AdministerVaccinations : Vaccines Distributed\n            AdministerVaccinations --> MonitorCoverage : Vaccinations Completed\n            MonitorCoverage --> [*] : Campaign Monitored\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A sports event organization process where teams are invited, the venue is prepared, the event is held, and results are announced.",
        "output": "\n        stateDiagram-v2\n            [*] --> InviteTeams\n            InviteTeams --> PrepareVenue : Teams Confirmed\n            PrepareVenue --> HoldEvent : Venue Ready\n            HoldEvent --> AnnounceResults : Event Completed\n            AnnounceResults --> [*] : Results Declared\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A water treatment process where water is collected, treated, tested, and distributed.",
        "output": "\n        stateDiagram-v2\n            [*] --> CollectWater\n            CollectWater --> TreatWater : Water Collected\n            TreatWater --> TestWater : Water Treated\n            TestWater --> DistributeWater : Testing Passed\n            DistributeWater --> [*] : Water Distributed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A software deployment process where code is developed, tested, deployed to staging, approved, and deployed to production.",
        "output": "\n        stateDiagram-v2\n            [*] --> DevelopCode\n            DevelopCode --> TestCode : Code Written\n            TestCode --> DeployStaging : Tests Passed\n            DeployStaging --> ApproveDeployment : Staging Successful\n            ApproveDeployment --> DeployProduction : Approval Given\n            DeployProduction --> [*] : Code in Production\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A construction permit process where a permit application is submitted, reviewed, approved, and the permit is issued.",
        "output": "\n        stateDiagram-v2\n            [*] --> SubmitApplication\n            SubmitApplication --> ReviewApplication : Application Received\n            ReviewApplication --> ApprovePermit : Requirements Met\n            ApprovePermit --> IssuePermit : Permit Approved\n            IssuePermit --> [*] : Permit Issued\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A patient referral system where a primary care doctor refers a patient to a specialist, the patient schedules an appointment, attends the appointment, and the specialist provides feedback.",
        "output": "\n        stateDiagram-v2\n            [*] --> DoctorReferral\n            DoctorReferral --> ScheduleAppointment : Referral Made\n            ScheduleAppointment --> AttendAppointment : Appointment Scheduled\n            AttendAppointment --> SpecialistFeedback : Appointment Completed\n            SpecialistFeedback --> [*] : Feedback Provided\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A school admissions process where a student applies, the application is reviewed, an interview is conducted, and the student is either admitted or rejected.",
        "output": "\n        stateDiagram-v2\n            [*] --> ApplyToSchool\n            ApplyToSchool --> ReviewApplication : Application Submitted\n            ReviewApplication --> ConductInterview : Shortlisted\n            ConductInterview --> AdmitStudent : Interview Successful\n            ConductInterview --> RejectApplication : Interview Unsuccessful\n            AdmitStudent --> [*] : Admission Granted\n            RejectApplication --> [*] : Application Rejected\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A pharmaceutical drug approval process where a new drug is researched, clinical trials are conducted, regulatory approval is sought, and the drug is launched.",
        "output": "\n        stateDiagram-v2\n            [*] --> ResearchDrug\n            ResearchDrug --> ConductTrials : Research Completed\n            ConductTrials --> SeekApproval : Trials Successful\n            SeekApproval --> LaunchDrug : Approval Granted\n            LaunchDrug --> [*] : Drug Launched\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: An educational course creation process where a course is designed, content is developed, the course is reviewed, and the course is published.",
        "output": "\n        stateDiagram-v2\n            [*] --> DesignCourse\n            DesignCourse --> DevelopContent : Course Framework Created\n            DevelopContent --> ReviewCourse : Content Completed\n            ReviewCourse --> PublishCourse : Review Passed\n            PublishCourse --> [*] : Course Published\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A logistics supply chain process where raw materials are sourced, products are manufactured, items are distributed, and products reach customers.",
        "output": "\n        stateDiagram-v2\n            [*] --> SourceMaterials\n            SourceMaterials --> ManufactureProducts : Materials Received\n            ManufactureProducts --> DistributeItems : Products Manufactured\n            DistributeItems --> ReachCustomers : Items Shipped\n            ReachCustomers --> [*] : Products Delivered\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A job training process where new hires are oriented, training is conducted, progress is evaluated, and certification is granted.",
        "output": "\n        stateDiagram-v2\n            [*] --> Orientation\n            Orientation --> ConductTraining : New Hires Oriented\n            ConductTraining --> EvaluateProgress : Training Completed\n            EvaluateProgress --> GrantCertification : Evaluation Passed\n            GrantCertification --> [*] : Certification Granted\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A property rental process where a property is listed, prospective tenants inquire, viewings are scheduled, and the property is rented out.",
        "output": "\n        stateDiagram-v2\n            [*] --> ListProperty\n            ListProperty --> Inquiries : Property Listed\n            Inquiries --> ScheduleViewing : Interested Tenants\n            ScheduleViewing --> RentProperty : Viewings Completed\n            RentProperty --> [*] : Property Rented\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A disaster recovery plan where a disaster is declared, recovery steps are initiated, resources are mobilized, and normalcy is restored.",
        "output": "\n        stateDiagram-v2\n            [*] --> DeclareDisaster\n            DeclareDisaster --> InitiateRecovery : Disaster Declared\n            InitiateRecovery --> MobilizeResources : Recovery Plan Activated\n            MobilizeResources --> RestoreNormalcy : Resources Deployed\n            RestoreNormalcy --> [*] : Normalcy Restored\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: An online payment system where a user initiates a payment, the payment is processed, verified, and the transaction is completed.",
        "output": "\n        stateDiagram-v2\n            [*] --> InitiatePayment\n            InitiatePayment --> ProcessPayment : Payment Started\n            ProcessPayment --> VerifyPayment : Payment Processing\n            VerifyPayment --> CompleteTransaction : Verification Successful\n            CompleteTransaction --> [*] : Payment Completed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A mobile app development process where an idea is conceived, the app is designed, developed, tested, and launched.",
        "output": "\n        stateDiagram-v2\n            [*] --> ConceiveIdea\n            ConceiveIdea --> DesignApp : Idea Finalized\n            DesignApp --> DevelopApp : Design Approved\n            DevelopApp --> TestApp : Development Completed\n            TestApp --> LaunchApp : Testing Successful\n            LaunchApp --> [*] : App Launched\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A healthcare insurance enrollment process where a user applies for insurance, the application is reviewed, coverage options are chosen, and the user is enrolled.",
        "output": "\n        stateDiagram-v2\n            [*] --> ApplyForInsurance\n            ApplyForInsurance --> ReviewApplication : Application Submitted\n            ReviewApplication --> ChooseCoverage : Application Approved\n            ChooseCoverage --> EnrollUser : Coverage Selected\n            EnrollUser --> [*] : User Enrolled\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A customer feedback process where feedback is collected, analyzed, actions are taken, and improvements are implemented.",
        "output": "\n        stateDiagram-v2\n            [*] --> CollectFeedback\n            CollectFeedback --> AnalyzeFeedback : Feedback Received\n            AnalyzeFeedback --> TakeAction : Analysis Completed\n            TakeAction --> ImplementImprovements : Action Taken\n            ImplementImprovements --> [*] : Improvements Implemented\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A hotel reservation cancellation process where a guest requests cancellation, the request is processed, fees are calculated, and the reservation is canceled.",
        "output": "\n        stateDiagram-v2\n            [*] --> RequestCancellation\n            RequestCancellation --> ProcessRequest : Cancellation Requested\n            ProcessRequest --> CalculateFees : Request Reviewed\n            CalculateFees --> CancelReservation : Fees Confirmed\n            CancelReservation --> [*] : Reservation Canceled\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A utility service setup process where a user requests service, installation is scheduled, the service is set up, and billing begins.",
        "output": "\n        stateDiagram-v2\n            [*] --> RequestService\n            RequestService --> ScheduleInstallation : Service Requested\n            ScheduleInstallation --> SetupService : Installation Scheduled\n            SetupService --> BeginBilling : Service Set Up\n            BeginBilling --> [*] : Billing Started\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A business merger process where two companies agree to merge, due diligence is conducted, legal approvals are obtained, and the merger is completed.",
        "output": "\n        stateDiagram-v2\n            [*] --> AgreeToMerge\n            AgreeToMerge --> ConductDueDiligence : Merger Announced\n            ConductDueDiligence --> ObtainApprovals : Due Diligence Done\n            ObtainApprovals --> CompleteMerger : Approvals Granted\n            CompleteMerger --> [*] : Merger Completed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A supply chain management system where orders are placed, items are produced, shipments are arranged, and products are delivered.",
        "output": "\n        stateDiagram-v2\n            [*] --> PlaceOrder\n            PlaceOrder --> ProduceItems : Order Received\n            ProduceItems --> ArrangeShipment : Items Ready\n            ArrangeShipment --> DeliverProducts : Shipment Arranged\n            DeliverProducts --> [*] : Products Delivered\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: An academic research process where a topic is selected, research is conducted, findings are analyzed, and a paper is published.",
        "output": "\n        stateDiagram-v2\n            [*] --> SelectTopic\n            SelectTopic --> ConductResearch : Topic Finalized\n            ConductResearch --> AnalyzeFindings : Data Collected\n            AnalyzeFindings --> PublishPaper : Analysis Completed\n            PublishPaper --> [*] : Paper Published\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A warranty claim process where a customer files a claim, the claim is reviewed, repairs are authorized, and the product is repaired.",
        "output": "\n        stateDiagram-v2\n            [*] --> FileClaim\n            FileClaim --> ReviewClaim : Claim Submitted\n            ReviewClaim --> AuthorizeRepairs : Claim Valid\n            AuthorizeRepairs --> RepairProduct : Repairs Authorized\n            RepairProduct --> [*] : Product Repaired\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A business expansion process where market research is conducted, a location is selected, operations are set up, and the business is launched.",
        "output": "\n        stateDiagram-v2\n            [*] --> ConductResearch\n            ConductResearch --> SelectLocation : Research Completed\n            SelectLocation --> SetupOperations : Location Chosen\n            SetupOperations --> LaunchBusiness : Operations Ready\n            LaunchBusiness --> [*] : Business Launched\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A non-profit fundraising event where an event is planned, sponsors are secured, the event is held, and funds are raised.",
        "output": "\n        stateDiagram-v2\n            [*] --> PlanEvent\n            PlanEvent --> SecureSponsors : Event Planned\n            SecureSponsors --> HoldEvent : Sponsors Confirmed\n            HoldEvent --> RaiseFunds : Event Held\n            RaiseFunds --> [*] : Funds Raised\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A new employee training process where the training is scheduled, sessions are conducted, assessments are given, and the employee is certified.",
        "output": "\n        stateDiagram-v2\n            [*] --> ScheduleTraining\n            ScheduleTraining --> ConductSessions : Training Planned\n            ConductSessions --> GiveAssessments : Sessions Conducted\n            GiveAssessments --> CertifyEmployee : Assessments Passed\n            CertifyEmployee --> [*] : Employee Certified\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A customer loyalty program where customers enroll, points are earned, rewards are redeemed, and the program is renewed annually.",
        "output": "\n        stateDiagram-v2\n            [*] --> EnrollProgram\n            EnrollProgram --> EarnPoints : Customer Enrolled\n            EarnPoints --> RedeemRewards : Points Accumulated\n            RedeemRewards --> RenewProgram : Rewards Redeemed\n            RenewProgram --> [*] : Program Renewed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A real estate transaction process where a property is listed, buyers are interested, offers are made, and the sale is completed.",
        "output": "\n        stateDiagram-v2\n            [*] --> ListProperty\n            ListProperty --> InterestBuyers : Property Marketed\n            InterestBuyers --> MakeOffers : Buyers Interested\n            MakeOffers --> CompleteSale : Offer Accepted\n            CompleteSale --> [*] : Sale Closed\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: An environmental impact assessment process where the impact is studied, reports are compiled, public consultations are held, and approval is granted.",
        "output": "\n        stateDiagram-v2\n            [*] --> StudyImpact\n            StudyImpact --> CompileReports : Research Done\n            CompileReports --> PublicConsultation : Reports Ready\n            PublicConsultation --> GrantApproval : Consultation Held\n            GrantApproval --> [*] : Approval Granted\n        "
    },
    {
        "instruction": "Create a Mermaid JS UML state diagram for the following scenario: A charity donation process where a donor makes a donation, the donation is processed, a receipt is issued, and the funds are allocated.",
        "output": "\n        stateDiagram-v2\n            [*] --> MakeDonation\n            MakeDonation --> ProcessDonation : Donation Received\n            ProcessDonation --> IssueReceipt : Donation Processed\n            IssueReceipt --> AllocateFunds : Receipt Issued\n            AllocateFunds --> [*] : Funds Allocated\n        "
    },
    {
        "instruction": "How can I define the global attributes, actions, and behaviors in a model in gaml?",
        "output": "\nglobal {\n    \/\/ Define global attributes here \n    int global_attr1;\n    float global_attr2;\n    \/\/ ...\n\n    \/\/ Define global actions here    \n    init {\n        \/\/ Implementation details\n        create something;\n    }\n    \n    action global_action {\n        \/\/ Implementation details\n    }\n    \/\/ ...\n}\n"
    },
    {
        "instruction": "How can I define the species attributes, actions, and behaviors in a model in gaml?",
        "output": "\nspecies {\n    \/\/ Define species attributes here\n    \n    \/\/ Define species actions here\n    \n    \/\/ Define species behaviors here\n}\n"
    },
    {
        "instruction": "How can I define the experiment attributes, actions, and behaviors in a model in gaml?",
        "output": "\nexperiment {\n    \/\/ Define species attributes here\n    \n    \/\/ Define species actions here\n    \n    \/\/ Define species behaviors here\n}\n"
    },
    {
        "instruction": "How can you declare and initialize the variable \"nb_preys_init\" to the value 200 in the global section of a GAML model?",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "How would you modify the provided GAML code to change the initial number of preys from 200 to a different value? Provide the modified code.",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "What coding approach would you adopt to declare and set the value of \"nb_preys_init\" to 200 within the global segment of a GAML model?",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "If you wanted to establish the variable \"nb_preys_init\" with an initial value of 200, how would you do so in the global section of a GAML model?",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "Provide the code snippet that demonstrates the declaration and initialization of the variable \"nb_preys_init\" to 200 in the global section of a GAML model.",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "In the global section of a GAML model, what specific coding conventions would you follow to declare and set the value of \"nb_preys_init\" to 200?",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "What is the correct syntax for defining and giving the variable \"nb_preys_init\" an initial value of 200 in the global section of a GAML model?",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "Describe the process of setting up and assigning the value 200 to the variable \"nb_preys_init\" in the global portion of a GAML model.",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "If you wanted to establish the variable \"nb_preys_init\" with an initial value of 200, how would you do so in the global section of a GAML model?",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "How can you declare and initialize the variable \"nb_predators_init\" to the value 500 in the global section of a GAML model?",
        "output": "\nglobal {\n\tint nb_predators_init <- 500;\n\tinit {\n\t\tcreate prey number: nb_predators_init;\n\t}\n}\n"
    },
    {
        "instruction": "In the global section of a GAML model, how would you go about declaring and assigning the value 600 to the variable \"nb_predators_init\"?",
        "output": "\nglobal {\n        int nb_predators_init <- 600;\n        init {\n                create prey number: nb_predators_init;\n        }\n}\n"
    },
    {
        "instruction": "Could you provide instructions on initializing the variable \"nb_predators_init\" to 700 within the global context of a GAML model?",
        "output": "\nglobal {\n        int nb_predators_init <- 700;\n        init {\n                create prey number: nb_predators_init;\n        }\n}\n"
    },
    {
        "instruction": "If you wanted to establish the variable \"nb_predators_init\" with an initial value of 800, how would you do so in the global section of a GAML model?",
        "output": "\nglobal {\n        int nb_predators_init <- 800;\n        init {\n                create prey number: nb_predators_init;\n        }\n}\n"
    },
    {
        "instruction": "Provide the code snippet that demonstrates the declaration and initialization of the variable \"nb_predators_init\" to 900 in the global section of a GAML model.",
        "output": "\nglobal {\n        int nb_predators_init <- 900;\n        init {\n                create prey number: nb_predators_init;\n        }\n}\n"
    },
    {
        "instruction": "What coding approach would you adopt to declare and set the value of \"nb_predators_init\" to 50 within the global segment of a GAML model?",
        "output": "\nglobal {\n        int nb_predators_init <- 50;\n        init {\n                create prey number: nb_predators_init;\n        }\n}\n"
    },
    {
        "instruction": "Generate a gaml code snippet for species",
        "output": "\nspecies {\n    \/\/ Define species attributes here\n    \n    \/\/ Define species actions here\n    \n    \/\/ Define species behaviors here\n}\n"
    },
    {
        "instruction": "How would you instruct a text-to-code model to generate a GAML code snippet for a species called \"Prey,\" incorporating attributes such as \"preyID,\" \"posX,\" and \"posY,\" along with an initialization block and an action named \"Move\"?",
        "output": "\nspecies Prey {\n    int preyID;\n    float posX, posY;\n    \n    init {\n        preyID <- rnd(1, 1000);\n        posX <- rnd(-50, 50);\n        posY <- rnd(-50, 50);\n    }\n    \n    action Move {\n        posX <- posX + rnd(-5, 5);\n        posY <- posY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "Outline the instructions for a text-to-code model to produce a GAML code snippet featuring a species named \"Prey\" with attributes like \"preyID,\" \"posX,\" and \"posY,\" alongside an initialization block and an action called \"Move.\"",
        "output": "\nspecies Prey {\n    int preyID;\n    float posX, posY;\n    \n    init {\n        preyID <- rnd(1, 1000);\n        posX <- rnd(-50, 50);\n        posY <- rnd(-50, 50);\n    }\n    \n    action Move {\n        posX <- posX + rnd(-5, 5);\n        posY <- posY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "Describe the steps to guide a text-to-code model in generating a GAML code snippet that defines a species named \"Prey,\" including attributes such as \"preyID,\" \"posX,\" and \"posY,\" along with an initialization block and an action named \"Move.\"",
        "output": "\nspecies Prey {\n    int preyID;\n    float posX, posY;\n    \n    init {\n        preyID <- rnd(1, 1000);\n        posX <- rnd(-50, 50);\n        posY <- rnd(-50, 50);\n    }\n    \n    action Move {\n        posX <- posX + rnd(-5, 5);\n        posY <- posY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "Create a GAML code snippet depicting a species named \"Prey,\" incorporating attributes like \"preyID,\" \"posX,\" and \"posY,\" as well as an initialization block and an action named \"Move.\"",
        "output": "\nspecies Prey {\n    int preyID;\n    float posX, posY;\n    \n    init {\n        preyID <- rnd(1, 1000);\n        posX <- rnd(-50, 50);\n        posY <- rnd(-50, 50);\n    }\n    \n    action Move {\n        posX <- posX + rnd(-5, 5);\n        posY <- posY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "Generate a GAML code snippet that introduces a species named \"Prey,\" comprising attributes such as \"preyID,\" \"posX,\" and \"posY,\" along with an initialization block and an action called \"Move.\"",
        "output": "\nspecies Prey {\n    int preyID;\n    float posX, posY;\n    \n    init {\n        preyID <- rnd(1, 1000);\n        posX <- rnd(-50, 50);\n        posY <- rnd(-50, 50);\n    }\n    \n    action Move {\n        posX <- posX + rnd(-5, 5);\n        posY <- posY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "generate a gaml code snippet that introduces a species named \"Prey,\" comprising attributes such as \"preyID,\" \"posX,\" and \"posY,\" along with an initialization block and an action called \"Move.\"",
        "output": "\nspecies Prey {\n    int preyID;\n    float posX, posY;\n    \n    init {\n        preyID <- rnd(1, 1000);\n        posX <- rnd(-50, 50);\n        posY <- rnd(-50, 50);\n    }\n    \n    action Move {\n        posX <- posX + rnd(-5, 5);\n        posY <- posY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "Generate a GAML code snippet that defines a species named \"Hunter,\" incorporating attributes such as \"hunterID,\" \"posX,\" and \"posY,\" along with an initialization block and an action named \"Track.\"",
        "output": "\nspecies Hunter {\n    int hunterID;\n    float posX, posY;\n    \n    init {\n        hunterID <- rnd(1, 1000);\n        posX <- rnd(-50, 50);\n        posY <- rnd(-50, 50);\n    }\n    \n    action Track {\n        posX <- posX + rnd(-5, 5);\n        posY <- posY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "Develop a GAML code snippet presenting a species named \"Explorer,\" featuring attributes like \"explorerID,\" \"latitude,\" and \"longitude,\" along with an initialization block and an action named \"Navigate.\"",
        "output": "\nspecies Explorer {\n    int explorerID;\n    float latitude, longitude;\n    \n    init {\n        explorerID <- rnd(1, 1000);\n        latitude <- rnd(-90, 90);\n        longitude <- rnd(-180, 180);\n    }\n    \n    action Navigate {\n        latitude <- latitude + rnd(-2, 2);\n        longitude <- longitude + rnd(-2, 2);\n    }\n}\n"
    },
    {
        "instruction": "Create a GAML code snippet introducing a species named \"Robot,\" containing attributes such as \"robotID,\" \"positionX,\" and \"positionY,\" along with an initialization block and an action named \"MoveForward.\"",
        "output": "\nspecies Robot {\n    int robotID;\n    float positionX, positionY;\n    \n    init {\n        robotID <- rnd(1, 1000);\n        positionX <- rnd(-50, 50);\n        positionY <- rnd(-50, 50);\n    }\n    \n    action MoveForward {\n        positionX <- positionX + rnd(-5, 5);\n        positionY <- positionY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "Generate a GAML code snippet defining a species named \"Fish,\" featuring attributes like \"fishID,\" \"depth,\" and \"swimDirection,\" alongside an initialization block and an action called \"Swim.\"",
        "output": "\nspecies Fish {\n    int fishID;\n    float depth, swimDirection;\n    \n    init {\n        fishID <- rnd(1, 1000);\n        depth <- rnd(1, 100);\n        swimDirection <- rnd(0, 360);\n    }\n    \n    action Swim {\n        depth <- depth + rnd(-5, 5);\n        swimDirection <- rnd(0, 360);\n    }\n}\n"
    },
    {
        "instruction": "Develop a GAML code snippet for a species named \"Bird,\" including attributes such as \"birdID,\" \"altitude,\" and \"flightDirection,\" along with an initialization block and an action named \"Fly.\"",
        "output": "\nspecies Bird {\n    int birdID;\n    float altitude, flightDirection;\n    \n    init {\n        birdID <- rnd(1, 1000);\n        altitude <- rnd(1, 50);\n        flightDirection <- rnd(0, 360);\n    }\n    \n    action Fly {\n        altitude <- altitude + rnd(-2, 2);\n        flightDirection <- rnd(0, 360);\n    }\n}\n"
    },
    {
        "instruction": "Create a GAML code snippet for a species named \"Vehicle,\" containing attributes like \"vehicleID,\" \"speed,\" and \"position,\" alongside an initialization block and an action named \"MoveForward.\"",
        "output": "\nspecies Vehicle {\n    int vehicleID;\n    float speed, position;\n    \n    init {\n        vehicleID <- rnd(1, 1000);\n        speed <- rnd(30, 120);\n        position <- rnd(-100, 100);\n    }\n    \n    action MoveForward {\n        position <- position + speed * rnd(0.8, 1.2);\n    }\n}\n"
    },
    {
        "instruction": "Develop a GAML code snippet for a species named \"Human,\" with attributes like \"humanID,\" \"age,\" and \"location,\" along with an initialization block and an action named \"Walk.\"",
        "output": "\nspecies Human {\n    int humanID;\n    int age;\n    float location;\n    \n    init {\n        humanID <- rnd(1, 1000);\n        age <- rnd(1, 100);\n        location <- rnd(-10, 10);\n    }\n    \n    action Walk {\n        location <- location + rnd(-2, 2);\n    }\n}\n"
    },
    {
        "instruction": "Generate a GAML code snippet for a species named \"Building,\" featuring attributes such as \"buildingID,\" \"height,\" and \"location,\" alongside an initialization block and an action named \"Collapse.\"",
        "output": "\nspecies Building {\n    int buildingID;\n    float height, location;\n    \n    init {\n        buildingID <- rnd(1, 1000);\n        height <- rnd(10, 100);\n        location <- rnd(-100, 100);\n    }\n    \n    action Collapse {\n        height <- 0;\n    }\n}\n"
    },
    {
        "instruction": "Create a GAML code snippet introducing a species named \"Plant,\" including attributes like \"plantID,\" \"growthRate,\" and \"nutrientLevel,\" along with an initialization block and an action named \"Grow.\"",
        "output": "\nspecies Plant {\n    int plantID;\n    float growthRate, nutrientLevel;\n    \n    init {\n        plantID <- rnd(1, 1000);\n        growthRate <- rnd(0.1, 1.0);\n        nutrientLevel <- rnd(0, 100);\n    }\n    \n    action Grow {\n        nutrientLevel <- nutrientLevel + growthRate * rnd(0.8, 1.2);\n    }\n}\n"
    },
    {
        "instruction": "Develop a GAML code snippet for a species named \"Insect,\" comprising attributes like \"insectID,\" \"wingColor,\" and \"position,\" along with an initialization block and an action named \"Fly.\"",
        "output": "\nspecies Insect {\n    int insectID;\n    string wingColor;\n    float position;\n    \n    init {\n        insectID <- rnd(1, 1000);\n        wingColor <- choose(\"Red\", \"Green\", \"Blue\");\n        position <- rnd(-10, 10);\n    }\n    \n    action Fly {\n        position <- position + rnd(-2, 2);\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, defining attributes such as \"nb_preys_init,\" \"prey_max_energy,\" \"prey_max_transfer,\" and \"prey_energy_consum,\" along with an initialization block that creates a specified number of preys?",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        float prey_max_energy <- 1.0;\n        float prey_max_transfer <- 0.1;\n        float prey_energy_consum <- 0.05;\n        \n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "Develop a GAML code snippet for the global section of a model, defining attributes like \"nb_species_init,\" \"species_max_energy,\" \"species_max_transfer,\" and \"species_energy_consumption,\" along with an initialization block that creates a specific number of species.",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        float prey_max_energy <- 1.0;\n        float prey_max_transfer <- 0.1;\n        float prey_energy_consum <- 0.05;\n        \n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "Provide instructions for generating a GAML code snippet in the global section of a model, introducing variables such as \"nb_cells_init,\" \"cell_max_energy,\" \"cell_max_transfer,\" and \"cell_energy_consumption,\" along with an initialization block creating a designated number of cells.",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        float prey_max_energy <- 1.0;\n        float prey_max_transfer <- 0.1;\n        float prey_energy_consum <- 0.05;\n        \n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "Direct the generation of a GAML code snippet for the global section of a model, defining parameters like \"nb_agents_init,\" \"agent_max_energy,\" \"agent_max_transfer,\" and \"agent_energy_consumption,\" along with an initialization block creating a specified number of agents.",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        float prey_max_energy <- 1.0;\n        float prey_max_transfer <- 0.1;\n        float prey_energy_consum <- 0.05;\n        \n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "",
        "output": "\nglobal {\n    int nb_entities_init <- 100;\n    float entity_max_energy <- 10.0;\n    float entity_max_transfer <- 1.0;\n    float entity_energy_consumption <- 0.1;\n\n    init {\n        create entity number: nb_entities_init;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, defining variables such as \"nb_agents_init,\" \"agent_max_energy,\" \"agent_max_transfer,\" and \"agent_energy_consumption,\" along with an initialization block that creates a predetermined number of agents",
        "output": "\nglobal {\n    int nb_agents_init <- 150;\n    float agent_max_energy <- 8.0;\n    float agent_max_transfer <- 0.8;\n    float agent_energy_consumption <- 0.15;\n\n    init {\n        create agent number: nb_agents_init;\n    }\n}\n"
    },
    {
        "instruction": "produce a GAML code snippet for the global section of a model, defining attributes such as \"nb_cells_init,\" \"cell_max_energy,\" \"cell_max_transfer,\" and \"cell_energy_consumption,\" accompanied by an initialization block creating a specific number of cells",
        "output": "\nglobal {\n    int nb_cells_init <- 120;\n    float cell_max_energy <- 12.0;\n    float cell_max_transfer <- 1.2;\n    float cell_energy_consumption <- 0.12;\n\n    init {\n        create cell number: nb_cells_init;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, outlining variables like \"nb_species_init,\" \"species_max_energy,\" \"species_max_transfer,\" and \"species_energy_consumption,\" with an initialization block that creates a specified number of species",
        "output": "\nglobal {\n    int nb_species_init <- 80;\n    float species_max_energy <- 6.0;\n    float species_max_transfer <- 0.6;\n    float species_energy_consumption <- 0.18;\n\n    init {\n        create species number: nb_species_init;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, defining variables like \"nb_species_init,\" \"species_max_energy,\" and \"species_type\" with data types \"int,\" \"float,\" and \"string\" respectively, accompanied by an initialization block that creates a specified number of species?",
        "output": "\nglobal {\n    int nb_species_init <- 80;\n    float species_max_energy <- 6.0;\n    string species_type <- \"Mammal\";\n    \n    init {\n        create species number: nb_species_init;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, specifying variables such as \"species_name\" with data type \"string,\" \"species_max_transfer,\" and \"species_energy_consumption\" with data type \"float,\" accompanied by an initialization block that creates a designated number of species?",
        "output": "\nglobal {\n    string species_name <- \"Bird\";\n    float species_max_transfer <- 0.6;\n    float species_energy_consumption <- 0.18;\n\n    init {\n        create species number <- 50;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, defining variables like \"species_name\" with data type \"string,\" \"species_max_transfer,\" and \"species_energy_consumption\" with data type \"float,\" along with an initialization block that creates a specified number of species?",
        "output": "\nglobal {\n    string species_name <- \"Bird\";\n    float species_max_transfer <- 0.6;\n    float species_energy_consumption <- 0.18;\n\n    init {\n        create species number <- 50;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, specifying variables such as \"nb_species_init\" with data type \"int\" and \"species_family\" with data type \"string,\" accompanied by an initialization block that creates a predetermined number of species",
        "output": "\nglobal {\n    int nb_species_init <- 80;\n    string species_family <- \"Reptile\";\n    \n    init {\n        create species number: nb_species_init;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, defining variables such as \"nb_species_init\" with data type \"int\" and \"species_family\" with data type \"string,\" where \"nb_species_init\" is initialized with a random value between 40 and 50, accompanied by an initialization block that creates a specified number of species",
        "output": "\nglobal {\n    int nb_species_init <- rnd(40,50);\n    string species_family <- \"Reptile\";\n    \n    init {\n        create species number: nb_species_init;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, defining variables like \"nb_species_init\" with data type \"int\" and \"species_density\" with data type \"float,\" where \"nb_species_init\" is initialized with a random value between 30 and 60, accompanied by an initialization block that creates a specified number of species",
        "output": "\nglobal {\n    int nb_species_init <- rnd(30, 60);\n    float species_density <- 0.5;\n    \n    init {\n        create species number: nb_species_init;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, specifying variables such as \"nb_species_init\" with data type \"float\" and \"species_type\" with data type \"string,\" where \"nb_species_init\" is initialized with a random value between 40 and 50, accompanied by an initialization block that creates a specified number of species",
        "output": "\nglobal {\n    float nb_species_init <- rnd(40, 50);\n    string species_type <- \"Amphibian\";\n    \n    init {\n        create species number: int(nb_species_init);\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, defining variables like \"nb_species_init\" with data type \"float\" and \"species_type\" with data type \"string,\" where \"nb_species_init\" is initialized with a random value between 40 and 50, accompanied by an initialization block that creates a specified number of species?",
        "output": "\nglobal {\n    float nb_species_init <- rnd(40, 50);\n    string species_type <- \"Amphibian\";\n    \n    init {\n        create species number: int(nb_species_init);\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet that input data from file \"..\/includes\/building.shp\", \"..\/includes\/road.shp\", \"..\/includes\/bounds.shp\" to create buildings and roads",
        "output": "\nglobal {\n        file shape_file_buildings <- file(\"..\/includes\/building.shp\");\n        file shape_file_roads <- file(\"..\/includes\/road.shp\");\n        file shape_file_bounds <- file(\"..\/includes\/bounds.shp\");\n        geometry shape <- envelope(shape_file_bounds);\n        float step <- 10 #mn;\n        \n        init {\n                create building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n                        if type=\"Industrial\" {\n                                color <- #blue ;\n                        }\n                }\n                create road from: shape_file_roads ;\n        }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet that uses a shapefile ('..\/includes\/agriculture.shp') to create fields, focusing on areas labeled as 'Crop' and assigning them a distinctive color, such as #green",
        "output": "\nglobal {\n        file shape_file_agriculture <- file(\"..\/includes\/agriculture.shp\");\n        geometry shape <- envelope(shape_file_bounds);\n        \n        init {\n                create field from: shape_file_agriculture with: [type::string(read (\"AGRICULTURE\"))] {\n                        if type=\"Crop\" {\n                                color <- #green ;\n                        }\n                }\n        }\n}\n"
    },
    {
        "instruction": "generating a GAML code snippet similar to the provided example? The objective is to create houses based on a shapefile ('..\/includes\/residential.shp'), specifically differentiating between 'Apartment' and 'House' types and assigning distinctive colors (#yellow for apartments, #orange for houses).",
        "output": "\nglobal {\n        file shape_file_residential <- file(\"..\/includes\/residential.shp\");\n        geometry shape <- envelope(shape_file_bounds);\n        \n        init {\n                create house from: shape_file_residential with: [type::string(read (\"RESIDENTIAL\"))] {\n                        if type=\"Apartment\" {\n                                color <- #yellow ;\n                        }\n                        else if type=\"House\" {\n                                color <- #orange ;\n                        }\n                }\n        }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet akin to the provided example? The goal is to utilize a shapefile ('..\/includes\/commercial.shp') to create shops, distinguishing between 'Retail' and 'Office' types and assigning distinctive colors (#purple for retail, #pink for office)",
        "output": "\nglobal {\n        file shape_file_commercial <- file(\"..\/includes\/commercial.shp\");\n        geometry shape <- envelope(shape_file_bounds);\n        \n        init {\n                create shop from: shape_file_commercial with: [type::string(read (\"COMMERCIAL\"))] {\n                        if type=\"Retail\" {\n                                color <- #purple ;\n                        }\n                        else if type=\"Office\" {\n                                color <- #pink ;\n                        }\n                }\n        }\n}\n"
    },
    {
        "instruction": "generating a GAML code snippet similar to the provided example? The objective is to create buildings and roads based on shapefiles ('..\/includes\/building.shp' and '..\/includes\/road.shp' respectively), with specific conditions for 'Industrial' buildings to be colored #blue. Additionally, residential buildings are identified, and a specified number of people (nb_people) are created within these residential buildings",
        "output": "\nglobal {\n        file shape_file_buildings <- file(\"..\/includes\/building.shp\");\n        file shape_file_roads <- file(\"..\/includes\/road.shp\");\n        file shape_file_bounds <- file(\"..\/includes\/bounds.shp\");\n        geometry shape <- envelope(shape_file_bounds);\n        float step <- 10 #mn;\n        int nb_people <- 100;\n        \n        init {\n                create building from: shape_file_buildings with: [type::string(read (\"NATURE\"))] {\n                        if type=\"Industrial\" {\n                                color <- #blue ;\n                        }\n                }\n                create road from: shape_file_roads ;\n                \n                list<building> residential_buildings <- building where (each.type=\"Residential\");\n                create people number: nb_people {\n                        location <- any_location_in (one_of (residential_buildings));\n                }\n        }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet that utilizes a shapefile ('..\/includes\/education.shp') to create educational facilities, specifically schools with an assigned color of #orange. Additionally, a certain number of students (nb_students) should be created and located within buildings labeled as 'School' based on the provided shapefile.",
        "output": "\nglobal {\n        file shape_file_education <- file(\"..\/includes\/education.shp\");\n        geometry shape <- envelope(shape_file_bounds);\n        int nb_students <- 200;\n        \n        init {\n                create school from: shape_file_education with: [type::string(read (\"EDUCATION\"))] {\n                        color <- #orange;\n                }\n                \n                list<building> school_buildings <- building where (each.type=\"School\");\n                create students number: nb_students {\n                        location <- any_location_in (one_of (school_buildings));\n                }\n        }\n}\n"
    },
    {
        "instruction": "Generate GAML code using the shapefile '..\/includes\/healthcare.shp' to create hospitals (#red), and generate a specified number of patients located within buildings labeled 'Hospital.'",
        "output": "\nglobal {\n        file shape_file_healthcare <- file(\"..\/includes\/healthcare.shp\");\n        geometry shape <- envelope(shape_file_bounds);\n        int nb_patients <- 150;\n        \n        init {\n                create hospital from: shape_file_healthcare with: [type::string(read (\"HEALTHCARE\"))] {\n                        color <- #red;\n                }\n                \n                list<building> hospital_buildings <- building where (each.type=\"Hospital\");\n                create patients number: nb_patients {\n                        location <- any_location_in (one_of (hospital_buildings));\n                }\n        }\n}\n"
    },
    {
        "instruction": "Generate GAML code using the shapefile '..\/includes\/commercial.shp' to create commercial spaces, differentiating between 'Retail' and 'Office' types with colors #purple and #pink, respectively.",
        "output": "\nglobal {\n        file shape_file_commercial <- file(\"..\/includes\/commercial.shp\");\n        geometry shape <- envelope(shape_file_bounds);\n        \n        init {\n                create shop from: shape_file_commercial with: [type::string(read (\"COMMERCIAL\"))] {\n                        if type=\"Retail\" {\n                                color <- #purple ;\n                        }\n                        else if type=\"Office\" {\n                                color <- #pink ;\n                        }\n                }\n        }\n}\n"
    },
    {
        "instruction": "create parks using a shapefile ('..\/includes\/parks.shp'), assigning a distinctive color (#green). Specify the necessary components, conditions, and parameters to be included in the GAML code during the generation process.",
        "output": "\nglobal {\n        file shape_file_parks <- file(\"..\/includes\/parks.shp\");\n        geometry shape <- envelope(shape_file_bounds);\n        \n        init {\n                create park from: shape_file_parks with: [type::string(read (\"PARK\"))] {\n                        color <- #green;\n                }\n        }\n}\n"
    },
    {
        "instruction": " generate a GAML code structure with distinct sections for global, species, and an experiment section",
        "output": "\nglobal {\n    \/\/ Define global attributes here \n\n    \/\/ Define global actions here    \n    \n    \/\/ Define global behaviors here\n\n}\n\nspecies {\n    \/\/ Define species attributes here\n    \n    \/\/ Define species actions here\n    \n    \/\/ Define species behaviors here\n}\n\nexperiment {\n    \/\/ Define species attributes here\n    \n    \/\/ Define species actions here\n    \n    \/\/ Define species behaviors here\n}\n"
    },
    {
        "instruction": "How can I define the species attributes, actions, and behaviors in a model in gaml?",
        "output": "\nspecies {\n    \/\/ Define species attributes here \n    int species_attr1;\n    float species_attr2;\n    \/\/ ...\n\n    \/\/ Define species actions here    \n    init {\n        \/\/ Implementation details\n        create something;\n    }\n    \n    action species_action {\n        \/\/ Implementation details\n    }\n    \/\/ ...\n}\n"
    },
    {
        "instruction": "generate experiment code snippet in GAML to display species building, road, people that we define before",
        "output": "\nexperiment road_traffic type: gui {\n        parameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;\n        parameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;\n        parameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;\n        parameter \"Number of people agents\" var: nb_people category: \"People\" ;\n        \n        output {\n                display city_display type:3d {\n                        species building aspect: base ;\n                        species road aspect: base ;\n                        species people aspect: base ;\n                }\n        }\n}\n"
    },
    {
        "instruction": "generate experiment code snippet in GAML to display species prey with aspect we define in species",
        "output": "\nexperiment prey_predator type: gui {\n        parameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\";\n        output {\n                display main_display {\n                        species prey aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "generate a GAML experiment code snippet that involves a species named 'herbivore,' with a defined aspect, and includes parameters for the initial number of herbivores in a GUI output display?",
        "output": "\nexperiment herbivore_feeding type: gui {\n    parameter \"Initial number of herbivores: \" var: nb_herbivores_init min: 1 max: 1000 category: \"Herbivore\";\n    output {\n        display main_display {\n            species herbivore aspect: base;\n        }\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML experiment code snippet featuring a species named 'bird' with a defined aspect, and include parameters for the initial number of birds in a GUI output display",
        "output": "\nexperiment bird_flying type: gui {\n    parameter \"Initial number of birds: \" var: nb_birds_init min: 1 max: 1000 category: \"Bird\";\n    output {\n        display main_display {\n            species birds aspect: draw_bird;\n        }\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML experiment code snippet to display a species named 'fish' with a defined aspect, incorporating parameters for the initial number of fish in a GUI output display",
        "output": "\nexperiment fish_swimming type: gui {\n    parameter \"Initial number of fish: \" var: nb_fish_init min: 1 max: 1000 category: \"Fish\";\n    output {\n        display main_display {\n            species fish aspect: drawing_fish;\n        }\n    }\n}\n"
    },
    {
        "instruction": "generate for me a model for a species predator and an experiment to display it in GAML",
        "output": "\nspecies predator {\n        float size <- 2.0;\n        rgb color <- #red;\n                \n        aspect base {\n                draw square(size) color: color;\n        }\n}\n\nexperiment predator_hunting type: gui {\n        parameter \"Initial number of predators: \" var: nb_predators_init min: 1 max: 1000 category: \"Predator\";\n        output {\n                display main_display {\n                        species predator aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "generate for me a model for a species fish and an experiment to display it in GAML",
        "output": "\nspecies fish {\n\tfloat fish_shape <- 0.3;\n\trgb color <- #cyan;\n\t\t\n\taspect display {\n\t\tdraw rectagle(fish_shape) color: color;\n\t}\n}\n\nexperiment fish_swimming type: gui {\n\tparameter \"Initial number of fish: \" var: nb_fish_init min: 1 max: 1000 category: \"Fish\";\n\toutput {\n\t\tdisplay main_display {\n\t\t\tspecies fish aspect: display;\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "give me a model for a species fish and an experiment to display it in GAML",
        "output": "\nspecies plane {\n\tfloat size <- 0.2;\n\trgb color <- #purple;\n\t\t\n\taspect base {\n\t\tdraw circle(size) color: color;\n\t}\n}\n\nexperiment insect_buzzing type: gui {\n\tparameter \"Initial number of insects: \" var: nb_insects_init min: 1 max: 1000 category: \"Insect\";\n\toutput {\n\t\tdisplay main_display {\n\t\t\tspecies insect aspect: circle;\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "give me a GAML code snippet for a grid structure named 'vegetation_cell' with a size of 50x50, considering a neighborhood of 4 cells around the current cell. The attributes include 'max_food,' 'food_prod,' 'food,' a color attribute based on food level, and a list of neighbors at a distance of 2 cells",
        "output": "\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n\tfloat max_food <- 1.0;\n\tfloat food_prod <- rnd(0.01);\n\tfloat food <- rnd(1.0) max: max_food update: food + food_prod;\n\trgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n\tlist<vegetation_cell> neighbors2  <- (self neighbors_at 2);\n}\n"
    },
    {
        "instruction": "create a GAML code for a 40x40 'water_cell' grid with a 8-cell neighborhood. Include attributes 'water_level,' 'evaporation_rate,' and 'rainfall' updated with random values. Define a color based on food level and a list of neighbors at a distance of 2 cells.\n\n\n\n\n\n",
        "output": "\ngrid water_cell width: 40 height: 40 neighbors: 8 {\n    float water_level <- 1.0;\n    float evaporation_rate <- rnd(0.01);\n    float rainfall <- rnd(1.0) max: water_level update: water_level - evaporation_rate + rainfall;\n    rgb color <- rgb(int(50 * (1 - water_level)), int(100 + 155 * water_level), int(50 * (1 - water_level))) update: rgb(int(50 * (1 - water_level)), int(100 + 155 * water_level), int(50 * (1 - water_level)));\n    list<water_cell> nearby_water_sources <- (self neighbors_at 1) if (each.water_level > 0.8);\n}\n"
    },
    {
        "instruction": "Make me a grid 'air_quality_cell' 45x45, 8-cell neighborhood, 'pollutant_concentration' and 'pollutant_dispersion' updated randomly. Color based on concentration, and list of neighbors at 1-cell distance with concentration > 0.5.",
        "output": "\ngrid air_quality_cell width: 45 height: 45 neighbors: 8 {\n    float pollutant_concentration <- rnd(0.1);\n    float pollutant_dispersion <- rnd(0.01);\n    pollutant_concentration <- pollutant_concentration - pollutant_dispersion;\n    rgb color <- rgb(int(255 * (1 - pollutant_concentration)), int(255 * pollutant_concentration), int(255 * (1 - pollutant_concentration)));\n    list<air_quality_cell> polluted_neighbors <- (self neighbors_at 1) if (each.pollutant_concentration > 0.5);\n}\n"
    },
    {
        "instruction": "Modify herbivore species to resemble 'prey_bird': 'max_energy,' 'max_transfer,' 'energy_consum,' 'proba_reproduce,' 'nb_max_offsprings,' 'energy_reproduce,' #green color. Add conditional 'energy_from_eat' on food and 'choose_cell' method for max food neighboring cell. Replace icon with 'deer.png' from '..\/includes\/data\/'.",
        "output": "\nspecies herbivore parent: generic_species {\n        rgb color <- #green;\n        float max_energy <- herbivore_max_energy;\n        float max_transfer <- herbivore_max_transfer;\n        float energy_consum <- herbivore_energy_consum;\n        float proba_reproduce <- herbivore_proba_reproduce;\n        int nb_max_offsprings <- herbivore_nb_max_offsprings;\n        float energy_reproduce <- herbivore_energy_reproduce;\n        image_file my_icon <- image_file(\"..\/includes\/data\/deer.png\");\n\n        float energy_from_eat {\n                float energy_transfer <- 0.0;\n                if(my_cell.food > 0) {\n                        energy_transfer <- min([max_transfer, my_cell.food]);\n                        my_cell.food <- my_cell.food - energy_transfer;\n                }                         \n                return energy_transfer;\n        }\n\n        vegetation_cell choose_cell {\n                return (my_cell.neighbors2) with_max_of (each.food);\n        }\n}\n"
    },
    {
        "instruction": "Modify 'prey_bird' species: 'max_energy,' 'max_transfer,' 'energy_consum,' 'proba_reproduce,' 'nb_max_offsprings,' 'energy_reproduce,' #yellow color. Include conditional 'energy_from_eat' on food and 'choose_cell' method for selecting max food neighboring cell. Replace icon with 'bird.png' from '..\/includes\/data\/'.",
        "output": "\nspecies prey_bird parent: generic_species {\n        rgb color <- #yellow;\n        float max_energy <- prey_bird_max_energy;\n        float max_transfer <- prey_bird_max_transfer;\n        float energy_consum <- prey_bird_energy_consum;\n        float proba_reproduce <- prey_bird_proba_reproduce;\n        int nb_max_offsprings <- prey_bird_nb_max_offsprings;\n        float energy_reproduce <- prey_bird_energy_reproduce;\n        image_file my_icon <- image_file(\"..\/includes\/data\/bird.png\");\n\n        float energy_from_eat {\n                float energy_transfer <- 0.0;\n                if(my_cell.food > 0) {\n                        energy_transfer <- min([max_transfer, my_cell.food]);\n                        my_cell.food <- my_cell.food - energy_transfer;\n                }                         \n                return energy_transfer;\n        }\n\n        vegetation_cell choose_cell {\n                return (my_cell.neighbors2) with_max_of (each.food);\n        }\n}\n"
    },
    {
        "instruction": "make for me a 'prey' species: 'max_energy,' 'max_transfer,' 'energy_consum,' 'proba_reproduce,' 'nb_max_offsprings,' 'energy_reproduce,' #blue color. Include conditional 'energy_from_eat' on food and 'choose_cell' method for selecting max food neighboring cell. Replace icon with 'sheep.png' from '..\/includes\/data\/'.",
        "output": "\nspecies prey parent: generic_species {\n        rgb color <- #blue;\n        float max_energy <- prey_max_energy;\n        float max_transfer <- prey_max_transfer;\n        float energy_consum <- prey_energy_consum;\n        float proba_reproduce <- prey_proba_reproduce;\n        int nb_max_offsprings <- prey_nb_max_offsprings;\n        float energy_reproduce <- prey_energy_reproduce;\n        image_file my_icon <- image_file(\"..\/includes\/data\/sheep.png\");\n\n        float energy_from_eat {\n                float energy_transfer <- 0.0;\n                if(my_cell.food > 0) {\n                        energy_transfer <- min([max_transfer, my_cell.food]);\n                        my_cell.food <- my_cell.food - energy_transfer;\n                }                         \n                return energy_transfer;\n        }\n\n        vegetation_cell choose_cell {\n                return (my_cell.neighbors2) with_max_of (each.food);\n        }\n}\n"
    },
    {
        "instruction": "create a GAML code for 'prey_bird': 'max_energy,' 'max_transfer,' 'energy_consum,' 'proba_reproduce,' 'nb_max_offsprings,' 'energy_reproduce,' #yellow color. Conditional 'energy_from_eat' on food. Method 'choose_cell' selects max food neighboring cell. Icon: 'bird.png' from '..\/includes\/data\/'.",
        "output": "\nspecies prey_bird parent: generic_species {\n\trgb color <- #yellow;\n\tfloat max_energy <- prey_bird_max_energy, max_transfer <- prey_bird_max_transfer, energy_consum <- prey_bird_energy_consum, proba_reproduce <- prey_bird_proba_reproduce;\n\tint nb_max_offsprings <- prey_bird_nb_max_offsprings;\n\tfloat energy_reproduce <- prey_bird_energy_reproduce;\n\timage_file my_icon <- image_file(\"..\/includes\/data\/bird.png\");\n\n\tfloat energy_from_eat {\n\t\treturn (my_cell.food > 0) ? min([max_transfer, my_cell.food]) : 0.0;\n\t}\n\n\tvegetation_cell choose_cell {\n\t\treturn (my_cell.neighbors2) with_max_of (each.food);\n\t}\n}\n"
    },
    {
        "instruction": "Create a GAML code snippet for the parent species \"generic_species\" with shared attributes. Other species inheriting from \"generic_species\" can access these common attributes.",
        "output": "\nspecies generic_species {\n\tfloat size <- 1.0;\n        rgb color;\n        float max_energy;\n        float energy_consum; \n        float proba_reproduce;\n        float energy_reproduce;\n        int nb_max_offsprings;\n        image_file my_icon;\n        vegetation_cell my_cell <- one_of(vegetation_cell);\n        float energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n\n        init {\n                location <- my_cell.location;\n        }\n\n        reflex basic_move {\n                my_cell <- choose_cell();\n                location <- my_cell.location;\n        }\n\n        reflex eat {\n                energy <- energy + energy_from_eat();                \n        }\n\n        reflex die when: energy <= 0 {\n                do die;\n        }\n\n        reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n                int nb_offsprings <- rnd(1, nb_max_offsprings);\n                create species(self) number: nb_offsprings {\n                        my_cell <- myself.my_cell;\n                        location <- my_cell.location;\n                        energy <- myself.energy \/ nb_offsprings;\n                }\n\n                energy <- energy \/ nb_offsprings;\n        }\n\n        float energy_from_eat {\n                return 0.0;\n        }\n\n        vegetation_cell choose_cell {\n                return nil;\n        }\n        aspect icon {\n                draw my_icon size: 2 * size;\n        }\n\n        aspect info {\n                draw square(size) color: color;\n                draw string(energy with_precision 2) size: 3 color: #black;\n        }\n}\n"
    },
    {
        "instruction": "Create a GAML code snippet for the parent species \"cars\" with shared attributes. Other species inheriting from \"cars\" can access these common attributes.",
        "output": "\nspecies cars {\n    float size <- 1.0;\n    rgb color;\n    float max_speed;\n    float acceleration;\n    float proba_reproduce;\n    float energy_reproduce;\n    int nb_max_offsprings;\n    road_cell my_cell <- one_of(road_cell);\n    float energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n\n    init {\n        location <- my_cell.location;\n    }\n\n    reflex move {\n        my_cell <- choose_cell();\n        location <- my_cell.location;\n    }\n\n    reflex refuel when: energy <= max_energy \/ 2 {\n        energy <- energy + energy_refuel();\n    }\n\n    reflex die when: energy <= 0 {\n        do die;\n    }\n\n    reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n        int nb_offsprings <- rnd(1, nb_max_offsprings);\n        create species(self) number: nb_offsprings {\n            my_cell <- myself.my_cell;\n            location <- my_cell.location;\n            energy <- myself.energy \/ nb_offsprings;\n        }\n        energy <- energy \/ nb_offsprings;\n    }\n\n    float energy_refuel {\n        return max_energy - energy;\n    }\n\n    road_cell choose_cell {\n        return nil; \/\/ Replace with your logic for choosing a road cell\n    }\n\n    aspect info {\n        draw square(size) color: color;\n        draw string(energy with_precision 2) size: 3 color: #black;\n    }\n}\n"
    },
    {
        "instruction": "generate parent species named boat in GAML which contains all common attributes of \"boat\" for other species with type boat to inheritant",
        "output": "\nspecies boats  {\n    float size <- 1.0;\n    rgb color;\n    float max_speed, acceleration, proba_reproduce, energy_reproduce;\n    int nb_max_offsprings;\n    water_cell my_cell <- one_of(water_cell);\n    float energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n\n    init {\n        location <- my_cell.location;\n    }\n\n    reflex move {\n        my_cell <- choose_cell();\n        location <- my_cell.location;\n    }\n\n    reflex refuel when: energy <= max_energy \/ 2 {\n        energy <- energy + energy_refuel();\n    }\n\n    reflex die when: energy <= 0 {\n        do die;\n    }\n\n    reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {\n        int nb_offsprings <- rnd(1, nb_max_offsprings);\n        create species(self) number: nb_offsprings {\n            my_cell <- myself.my_cell;\n            location <- my_cell.location;\n            energy <- myself.energy \/ nb_offsprings;\n        }\n        energy <- energy \/ nb_offsprings;\n    }\n\n    float energy_refuel {\n        return max_energy - energy;\n    }\n\n    water_cell choose_cell {\n        return nil; \/\/ Replace with your logic for choosing a water cell\n    }\n\n    aspect icon {\n        draw my_icon size: 2 * size;\n    }\n\n    aspect info {\n        draw square(size) color: color;\n        draw string(energy with_precision 2) size: 3 color: #black;\n    }\n}\n"
    },
    {
        "instruction": "generate species that inheritant species boat",
        "output": "\nspecies speedboat parent: boat {\n    rgb color <- #blue; \/\/ Customize the color for speedboats\n    float max_speed <- 30.0; \/\/ Customize the maximum speed for speedboats\n    float acceleration <- 5.0; \/\/ Customize the acceleration for speedboats\n\n    reflex accelerate {\n        max_speed <- min([max_speed + acceleration, 50.0]); \/\/ Adjust the acceleration logic as needed\n    }\n\n    reflex decelerate {\n        max_speed <- max([max_speed - acceleration, 0.0]); \/\/ Adjust the deceleration logic as needed\n    }\n\n    water_cell choose_cell {\n        \/\/ Implement specific logic for choosing a water cell for speedboats\n        return nil;\n    }\n}\n"
    },
    {
        "instruction": "provide a GAML code snippet for a \"taxi\" species that inherits from the parent species \"car\". Customize attributes such as color, maximum speed, and acceleration for taxis. Additionally, implement specific behaviors like honking and choosing a road cell for taxis.",
        "output": "\nspecies taxi parent: car {\n    rgb color <- #yellow; \/\/ Customize the color for taxis\n    float max_speed <- 20.0; \/\/ Customize the maximum speed for taxis\n    float acceleration <- 3.0; \/\/ Customize the acceleration for taxis\n\n    reflex honk {\n        \/\/ Implement specific logic for honking for taxis\n        \/\/ For example, play a honking sound or increase energy consumption\n    }\n\n    road_cell choose_cell {\n        \/\/ Implement specific logic for choosing a road cell for taxis\n        return nil;\n    }\n}\n"
    },
    {
        "instruction": "make a GAML code snippet for a \"truck\" species inheriting from the parent species \"car\"? Please customize attributes such as color, maximum speed, acceleration, and cargo capacity for trucks. Additionally, implement specific behaviors like cargo loading, cargo unloading, and choosing a road cell for trucks.",
        "output": "\nspecies truck parent: car {\n    rgb color <- #gray; \/\/ Customize the color for trucks\n    float max_speed <- 15.0; \/\/ Customize the maximum speed for trucks\n    float acceleration <- 2.0; \/\/ Customize the acceleration for trucks\n    float cargo_capacity <- 100.0; \/\/ Customize the cargo capacity for trucks\n\n    reflex load_cargo {\n        \/\/ Implement specific logic for loading cargo into trucks\n        \/\/ Adjust energy consumption or other parameters accordingly\n    }\n\n    reflex unload_cargo {\n        \/\/ Implement specific logic for unloading cargo from trucks\n        \/\/ Adjust energy consumption or other parameters accordingly\n    }\n\n    road_cell choose_cell {\n        \/\/ Implement specific logic for choosing a road cell for trucks\n        return nil;\n    }\n}\n"
    },
    {
        "instruction": "give me a GAML code snippet name nissan inheritant from species name \"car\"",
        "output": "\nspecies nissan parent: car {\n    rgb color <- #silver; \/\/ Customize the color for Nissans\n    float max_speed <- 25.0; \/\/ Customize the maximum speed for Nissans\n    float acceleration <- 4.0; \/\/ Customize the acceleration for Nissans\n\n    reflex play_music {\n        \/\/ Implement specific logic for playing music in Nissans\n        \/\/ Adjust energy consumption or other parameters accordingly\n    }\n\n    road_cell choose_cell {\n        \/\/ Implement specific logic for choosing a road cell for Nissans\n        return nil;\n    }\n}\n"
    },
    {
        "instruction": "give me a full model code snippet in GAML for example",
        "output": "\nmodel prey_predator\nglobal {\n        int nb_preys_init <- 150; \/\/ Fewer initial preys\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n\nspecies prey {\n        float size <- 1.0;\n        rgb color <- #blue;\n                 \n        aspect base {\n                draw circle(size) color: color;\n        }\n} \n\nexperiment prey_predator_5 type: gui {\n        parameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\";\n        output {\n                display main_display {\n                        species prey aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "generate a model name 'cars_simulation' in GAML",
        "output": "\nmodel cars_simulation\n\nglobal {\n        int nb_cars_init <- 30; \/\/ Fewer initial cars\n        init {\n                create car number: nb_cars_init;\n        }\n}\n\nspecies car {\n        float size <- 1.0;\n        rgb color <- #yellow;\n                \n        aspect base {\n                draw rectangle(size, size\/2) color: color;\n        }\n} \n\nexperiment cars_simulation_4 type: gui {\n        parameter \"Initial number of cars: \" var: nb_cars_init min: 1 max: 500 category: \"Cars\";\n        output {\n                display main_display {\n                        species car aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "give me a model name 'city_traffic_simulation' in GAML",
        "output": "\nmodel city_traffic_simulation\n\nglobal {\n        int nb_cars_init <- 40; \/\/ Adjusted initial cars\n        init {\n                create car number: nb_cars_init;\n        }\n}\n\nspecies car {\n        float size <- 1.0;\n        rgb color <- #purple; \/\/ Different color\n                \n        aspect base {\n                draw rectangle(size, size\/2) color: color;\n        }\n} \n\nexperiment city_traffic_simulation type: gui {\n        parameter \"Initial number of cars: \" var: nb_cars_init min: 1 max: 500 category: \"Cars\";\n        output {\n                display main_display {\n                        species car aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "make model that modeling air pollution data in GAML",
        "output": "\nmodel air_pollution\n\nglobal {\n        int nb_pollutants_init <- 5; \/\/ Initial number of pollutants\n        init {\n                create pollutant number: nb_pollutants_init;\n        }\n}\n\nspecies pollutant {\n        float size <- 1.0;\n        rgb color <- #gray; \/\/ Color representing pollutants\n                \n        aspect base {\n                draw circle(size) color: color;\n        }\n} \n\nexperiment air_pollution_simulation type: gui {\n        parameter \"Initial number of pollutants: \" var: nb_pollutants_init min: 1 max: 100 category: \"Pollutants\";\n        output {\n                display main_display {\n                        species pollutant aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "make a model in GAML to simulate data to manage the number of sick people",
        "output": "\nmodel sickness_spread\n\nglobal {\n        int nb_people_init <- 50; \/\/ Initial number of people\n        init {\n                create person number: nb_people_init;\n        }\n}\n\nspecies person {\n        float size <- 1.0;\n        rgb color <- #red; \/\/ Color representing people\n                \n        aspect base {\n                draw circle(size) color: color;\n        }\n} \n\nexperiment sickness_spread_simulation type: gui {\n        parameter \"Initial number of people: \" var: nb_people_init min: 1 max: 500 category: \"People\";\n        output {\n                display main_display {\n                        species person aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "from model sickness_spread in GAML before, make species 'mosquito'",
        "output": "\nmodel sickness_spread\n\nglobal {\n        int nb_people_init <- 50; \/\/ Initial number of people\n        int nb_mosquitoes_init <- 20; \/\/ Initial number of mosquitoes\n        init {\n                create person number: nb_people_init;\n                create mosquito number: nb_mosquitoes_init;\n        }\n}\n\nspecies person {\n        float size <- 1.0;\n        rgb color <- #red; \/\/ Color representing people\n                \n        aspect base {\n                draw circle(size) color: color;\n        }\n} \n\nspecies mosquito {\n        float size <- 0.5;\n        rgb color <- #brown; \/\/ Color representing mosquitoes\n                \n        aspect base {\n                draw circle(size) color: color;\n        }\n} \n\nexperiment sickness_spread_simulation type: gui {\n        parameter \"Initial number of people: \" var: nb_people_init min: 1 max: 500 category: \"People\";\n        parameter \"Initial number of mosquitoes: \" var: nb_mosquitoes_init min: 1 max: 100 category: \"Mosquitoes\";\n        output {\n                display main_display {\n                        species person aspect: base;\n                        species mosquito aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "from the previous model air_pollution in GAML, make a species 'car'",
        "output": "\nmodel air_pollution_simulation\n\nglobal {\n        int nb_pollutants_init <- 5; \/\/ Initial number of pollutants\n        int nb_cars_init <- 10; \/\/ Initial number of cars\n        init {\n                create pollutant number: nb_pollutants_init;\n                create car number: nb_cars_init;\n        }\n}\n\nspecies pollutant {\n        float size <- 1.0;\n        rgb color <- #gray; \/\/ Color representing pollutants\n                \n        aspect base {\n                draw circle(size) color: color;\n        }\n} \n\nspecies car {\n        float size <- 1.0;\n        rgb color <- #blue; \/\/ Color representing cars\n                \n        aspect base {\n                draw rectangle(size, size\/2) color: color;\n        }\n} \n\nexperiment air_pollution_simulation type: gui {\n        parameter \"Initial number of pollutants: \" var: nb_pollutants_init min: 1 max: 100 category: \"Pollutants\";\n        parameter \"Initial number of cars: \" var: nb_cars_init min: 1 max: 50 category: \"Cars\";\n        output {\n                display main_display {\n                        species pollutant aspect: base;\n                        species car aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "make a model prey in GAML. Define species prey and an environment with vegetation for it to simulate its environment in real life",
        "output": "\nmodel prey\n\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n\nspecies prey {\n        float size <- 1.0;\n        rgb color <- #blue;\n        vegetation_cell my_cell <- one_of (vegetation_cell);\n                \n        init {\n                location <- my_cell.location;\n        }\n\n        aspect base {\n                draw circle(size) color: color;\n        }\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n        float max_food <- 1.0;\n        float food_prod <- rnd(0.01);\n        float food <- rnd(1.0) max: max_food update: food + food_prod;\n        rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n}\n\nexperiment prey_predator type: gui {\n        parameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\";\n        output {\n                display main_display {\n                        grid vegetation_cell border: #black;\n                        species prey aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "from a pollution model bafore, generate a grid name 'pollution_cell' to evaluate pollution on each area in GAML",
        "output": "\nmodel pollution\n\nglobal {\n        int nb_pollutants_init <- 50;\n        init {\n                create pollutant number: nb_pollutants_init;\n        }\n}\n\nspecies pollutant {\n        float size <- 1.0;\n        rgb color <- #gray;\n        pollution_cell my_cell <- one_of(pollution_cell);\n                \n        init {\n                location <- my_cell.location;\n        }\n\n        aspect base {\n                draw circle(size) color: color;\n        }\n}\n\ngrid pollution_cell width: 50 height: 50 neighbors: 4 {\n        float max_pollution <- 1.0;\n        float pollution_prod <- rnd(0.01);\n        float pollution <- rnd(1.0) max: max_pollution update: pollution + pollution_prod;\n        rgb color <- rgb(int(255 * pollution), int(255 * (1 - pollution)), 0) update: rgb(int(255 * pollution), int(255 * (1 - pollution)), 0);\n}\n\nexperiment pollution type: gui {\n        parameter \"Initial number of pollutants: \" var: nb_pollutants_init min: 1 max: 500 category: \"Pollutants\";\n        output {\n                display main_display {\n                        grid pollution_cell border: #black;\n                        species pollutant aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "make a prey model which they can move aroung a grid name 'vegetation_cell' and eat vegetable from it in GAML code",
        "output": "\nmodel prey\nglobal {\n        int nb_preys_init <- 200;\n        float prey_max_energy <- 1.0;\n        float prey_max_transfer <- 0.1;\n        float prey_energy_consum <- 0.05;\n        \n        init {\n                create prey number: nb_preys_init;\n        }\n}\n\nspecies prey {\n        float size <- 1.0;\n        rgb color <- #blue;\n        float max_energy <- prey_max_energy;\n        float max_transfer <- prey_max_transfer;\n        float energy_consum <- prey_energy_consum;\n                \n        vegetation_cell my_cell <- one_of (vegetation_cell); \n        float energy <- rnd(max_energy)  update: energy - energy_consum max: max_energy;\n                \n        init { \n                location <- my_cell.location;\n        }\n\n        reflex basic_move {\n                my_cell <- one_of(my_cell.neighbors2);\n                location <- my_cell.location;\n        }\n        reflex eat when: my_cell.food > 0 { \n                float energy_transfer <- min([max_transfer, my_cell.food]);\n                my_cell.food <- my_cell.food - energy_transfer;\n                energy <- energy + energy_transfer;\n        }\n        reflex die when: energy <= 0 {\n                do die;\n        }\n\n        aspect base {\n                draw circle(size) color: color;\n        }\n}\n\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {\n        float max_food <- 1.0;\n        float food_prod <- rnd(0.01);\n        float food <- rnd(1.0) max: max_food update: food + food_prod;\n        rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n        list<vegetation_cell> neighbors2  <- (self neighbors_at 2);\n}\n\nexperiment prey_predator type: gui {\n        parameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\";\n        parameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\";\n        parameter \"Prey max transfer: \" var: prey_max_transfer  category: \"Prey\";\n        parameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\";\n        output {\n                display main_display {\n                        grid vegetation_cell border: #black;\n                        species prey aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "make a model name water_pollution by GAML, and species name vehicles in it. The more vehicles move around the grid, the more pollution in the neighborhood becomes worse. the rate of pollution bases on the density of the cell grid i",
        "output": "\nmodel water_pollution\n\nglobal {\n        int nb_vehicles_init <- 10;\n        float vehicle_max_movement <- 2.0;\n        float vehicle_pollution_rate <- 0.02;\n        \n        init {\n                create vehicle number: nb_vehicles_init;\n        }\n}\n\nspecies vehicle {\n        float size <- 0.7;\n        rgb color <- #black;\n        float max_movement <- vehicle_max_movement;\n        float pollution_rate <- vehicle_pollution_rate;\n                \n        pollution_cell my_cell <- one_of (pollution_cell); \n\n        reflex move {\n                my_cell <- one_of(my_cell.neighbors2);\n                location <- my_cell.location;\n                my_cell.pollution <- my_cell.pollution + pollution_rate;\n        }\n\n        aspect base {\n                draw circle(size) color: color;\n        }\n}\n\ngrid pollution_cell width: 50 height: 50 neighbors: 4 {\n        float max_pollution <- 1.0;\n        float pollution <- rnd(0.5) max: max_pollution;\n        rgb color <- rgb(int(255 * pollution), int(255 * (1 - pollution)), 255) update: rgb(int(255 * pollution), int(255 * (1 - pollution)), 255);\n        list<pollution_cell> neighbors2  <- (self neighbors_at 2);\n}\n\nexperiment pollution type: gui {\n        parameter \"Initial number of vehicles: \" var: nb_vehicles_init min: 1 max: 100 category: \"Vehicles\";\n        parameter \"Vehicle max movement: \" var: vehicle_max_movement category: \"Vehicles\";\n        parameter \"Vehicle pollution rate: \" var: vehicle_pollution_rate  category: \"Vehicles\";\n        output {\n                display main_display {\n                        grid pollution_cell border: #black;\n                        species vehicle aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "make a model name deforestation simulate the deforestation from reality by GAML",
        "output": "\nmodel deforestation\n\nglobal {\n        int nb_trees_init <- 50;\n        float tree_growth_rate <- 0.02;\n        \n        init {\n                create tree number: nb_trees_init;\n        }\n}\n\nspecies tree {\n        float size <- 1.0;\n        rgb color <- #green;\n        float growth_rate <- tree_growth_rate;\n                \n        soil_cell my_cell <- one_of(soil_cell); \n\n        reflex grow {\n                size <- size + growth_rate;\n        }\n\n        aspect base {\n                draw circle(size) color: color;\n        }\n}\n\ngrid soil_cell width: 50 height: 50 neighbors: 4 {\n        rgb color <- #brown;\n        list<soil_cell> neighbors2  <- (self neighbors_at 2);\n}\n\nexperiment deforestation type: gui {\n        parameter \"Initial number of trees: \" var: nb_trees_init min: 1 max: 100 category: \"Trees\";\n        parameter \"Tree growth rate: \" var: tree_growth_rate category: \"Trees\";\n        output {\n                display main_display {\n                        grid soil_cell border: #black;\n                        species tree aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "make a model simulate industrial waste by factory and people by GAML code",
        "output": "\nmodel industrial_waste_with_people\n\nglobal {\n        int nb_factories_init <- 5;\n        int nb_people_init <- 50;\n        float factory_pollution_rate <- 0.04;\n        float people_movement_rate <- 0.03;\n        \n        init {\n                create factory number: nb_factories_init;\n                create people number: nb_people_init;\n        }\n}\n\nspecies factory {\n        float size <- 1.0;\n        rgb color <- #gray;\n        float pollution_rate <- factory_pollution_rate;\n                \n        water_cell my_cell <- one_of(water_cell); \n\n        reflex pollute {\n                my_cell <- one_of(my_cell.neighbors2);\n                my_cell.water_pollution <- my_cell.water_pollution + pollution_rate;\n        }\n\n        aspect base {\n                draw circle(size) color: color;\n        }\n}\n\nspecies people {\n        float size <- 0.7;\n        rgb color <- #yellow;\n        float movement_rate <- people_movement_rate;\n                \n        water_cell my_cell <- one_of(water_cell); \n\n        reflex move {\n                my_cell <- one_of(my_cell.neighbors2);\n                location <- my_cell.location;\n        }\n\n        aspect base {\n                draw circle(size) color: color;\n        }\n}\n\ngrid water_cell width: 50 height: 50 neighbors: 4 {\n        float max_water_pollution <- 1.0;\n        float water_pollution <- rnd(0.5) max: max_water_pollution;\n        rgb color <- rgb(int(255 * water_pollution), int(255 * (1 - water_pollution)), 255) update: rgb(int(255 * water_pollution), int(255 * (1 - water_pollution)), 255);\n        list<water_cell> neighbors2  <- (self neighbors_at 2);\n}\n\nexperiment industrial_waste_with_people type: gui {\n        parameter \"Initial number of factories: \" var: nb_factories_init min: 1 max: 20 category: \"Factories\";\n        parameter \"Factory pollution rate: \" var: factory_pollution_rate category: \"Factories\";\n        parameter \"Initial number of people: \" var: nb_people_init min: 1 max: 100 category: \"People\";\n        parameter \"People movement rate: \" var: people_movement_rate category: \"People\";\n        output {\n                display main_display {\n                        grid water_cell border: #black;\n                        species factory aspect: base;\n                        species people aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "make a industrial model to simulation pollution made by factory in GAML",
        "output": "\nmodel industrial_emissions\n\nglobal {\n        int nb_factories_init <- 5;\n        float factory_pollution_rate <- 0.04;\n        \n        init {\n                create factory number: nb_factories_init;\n        }\n}\n\nspecies factory {\n        float size <- 1.0;\n        rgb color <- #gray;\n        float pollution_rate <- factory_pollution_rate;\n                \n        air_cell my_cell <- one_of(air_cell); \n\n        reflex emit_pollution {\n                my_cell <- one_of(my_cell.neighbors2);\n                my_cell.air_pollution <- my_cell.air_pollution + pollution_rate;\n        }\n\n        aspect base {\n                draw circle(size) color: color;\n        }\n}\n\ngrid air_cell width: 50 height: 50 neighbors: 4 {\n        float max_air_pollution <- 1.0;\n        float air_pollution <- rnd(0.5) max: max_air_pollution;\n        rgb color <- rgb(int(255 * air_pollution), int(255 * (1 - air_pollution)), 255) update: rgb(int(255 * air_pollution), int(255 * (1 - air_pollution)), 255);\n        list<air_cell> neighbors2  <- (self neighbors_at 2);\n}\n\nexperiment industrial_emissions type: gui {\n        parameter \"Initial number of factories: \" var: nb_factories_init min: 1 max: 20 category: \"Factories\";\n        parameter \"Factory pollution rate: \" var: factory_pollution_rate category: \"Factories\";\n        output {\n                display main_display {\n                        grid air_cell border: #black;\n                        species factory aspect: base;\n                }\n        }\n}\n"
    },
    {
        "instruction": "How can I define the global attributes, actions, and behaviors in a model in gaml?",
        "output": "\nglobal {\/\/ Define global attributes here \/\/ Define global actions here    \/\/ Define global behaviors here}\n"
    },
    {
        "instruction": "How can I define the species attributes, actions, and behaviors in a model in gaml?",
        "output": "\nspecies {\n    \/\/ Define species attributes here\n    \n    \/\/ Define species actions here\n    \n    \/\/ Define species behaviors here\n}\n"
    },
    {
        "instruction": "How can I define the experiment attributes, actions, and behaviors in a model in gaml?",
        "output": "\nexperiment {\n    \/\/ Define species attributes here\n    \n    \/\/ Define species actions here\n    \n    \/\/ Define species behaviors here\n}\n"
    },
    {
        "instruction": "How can you declare and initialize the variable \"nb_preys_init\" to the value 200 in the global section of a GAML model?",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "How would you modify the provided GAML code to change the initial number of preys from 200 to a different value? Provide the modified code.",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "What coding approach would you adopt to declare and set the value of \"nb_preys_init\" to 200 within the global segment of a GAML model?",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "If you wanted to establish the variable \"nb_preys_init\" with an initial value of 200, how would you do so in the global section of a GAML model?",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "Provide the code snippet that demonstrates the declaration and initialization of the variable \"nb_preys_init\" to 200 in the global section of a GAML model.",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "In the global section of a GAML model, what specific coding conventions would you follow to declare and set the value of \"nb_preys_init\" to 200?",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "What is the correct syntax for defining and giving the variable \"nb_preys_init\" an initial value of 200 in the global section of a GAML model?",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "Describe the process of setting up and assigning the value 200 to the variable \"nb_preys_init\" in the global portion of a GAML model.",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "If you wanted to establish the variable \"nb_preys_init\" with an initial value of 200, how would you do so in the global section of a GAML model?",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "How can you declare and initialize the variable \"nb_predators_init\" to the value 500 in the global section of a GAML model?",
        "output": "\nglobal {\n\tint nb_predators_init <- 500;\n\tinit {\n\t\tcreate prey number: nb_predators_init;\n\t}\n}\n"
    },
    {
        "instruction": "In the global section of a GAML model, how would you go about declaring and assigning the value 600 to the variable \"nb_predators_init\"?",
        "output": "\nglobal {\n        int nb_predators_init <- 600;\n        init {\n                create prey number: nb_predators_init;\n        }\n}\n"
    },
    {
        "instruction": "Could you provide instructions on initializing the variable \"nb_predators_init\" to 700 within the global context of a GAML model?",
        "output": "\nglobal {\n        int nb_predators_init <- 700;\n        init {\n                create prey number: nb_predators_init;\n        }\n}\n"
    },
    {
        "instruction": "If you wanted to establish the variable \"nb_predators_init\" with an initial value of 800, how would you do so in the global section of a GAML model?",
        "output": "\nglobal {\n        int nb_predators_init <- 800;\n        init {\n                create prey number: nb_predators_init;\n        }\n}\n"
    },
    {
        "instruction": "Provide the code snippet that demonstrates the declaration and initialization of the variable \"nb_predators_init\" to 900 in the global section of a GAML model.",
        "output": "\nglobal {\n        int nb_predators_init <- 900;\n        init {\n                create prey number: nb_predators_init;\n        }\n}\n"
    },
    {
        "instruction": "What coding approach would you adopt to declare and set the value of \"nb_predators_init\" to 50 within the global segment of a GAML model?",
        "output": "\nglobal {\n        int nb_predators_init <- 50;\n        init {\n                create prey number: nb_predators_init;\n        }\n}\n"
    },
    {
        "instruction": "Generate a gaml code snippet for species",
        "output": "\nspecies {\n    \/\/ Define species attributes here\n    \n    \/\/ Define species actions here\n    \n    \/\/ Define species behaviors here\n}\n"
    },
    {
        "instruction": "How would you instruct a text-to-code model to generate a GAML code snippet for a species called \"Prey,\" incorporating attributes such as \"preyID,\" \"posX,\" and \"posY,\" along with an initialization block and an action named \"Move\"?",
        "output": "\nspecies Prey {\n    int preyID;\n    float posX, posY;\n    \n    init {\n        preyID <- rnd(1, 1000);\n        posX <- rnd(-50, 50);\n        posY <- rnd(-50, 50);\n    }\n    \n    action Move {\n        posX <- posX + rnd(-5, 5);\n        posY <- posY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "Outline the instructions for a text-to-code model to produce a GAML code snippet featuring a species named \"Prey\" with attributes like \"preyID,\" \"posX,\" and \"posY,\" alongside an initialization block and an action called \"Move.\"",
        "output": "\nspecies Prey {\n    int preyID;\n    float posX, posY;\n    \n    init {\n        preyID <- rnd(1, 1000);\n        posX <- rnd(-50, 50);\n        posY <- rnd(-50, 50);\n    }\n    \n    action Move {\n        posX <- posX + rnd(-5, 5);\n        posY <- posY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "Describe the steps to guide a text-to-code model in generating a GAML code snippet that defines a species named \"Prey,\" including attributes such as \"preyID,\" \"posX,\" and \"posY,\" along with an initialization block and an action named \"Move.\"",
        "output": "\nspecies Prey {\n    int preyID;\n    float posX, posY;\n    \n    init {\n        preyID <- rnd(1, 1000);\n        posX <- rnd(-50, 50);\n        posY <- rnd(-50, 50);\n    }\n    \n    action Move {\n        posX <- posX + rnd(-5, 5);\n        posY <- posY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "Provide guidance on how to prompt a text-to-code model to create a GAML code snippet depicting a species named \"Prey,\" incorporating attributes like \"preyID,\" \"posX,\" and \"posY,\" as well as an initialization block and an action named \"Move.\"",
        "output": "\nspecies Prey {\n    int preyID;\n    float posX, posY;\n    \n    init {\n        preyID <- rnd(1, 1000);\n        posX <- rnd(-50, 50);\n        posY <- rnd(-50, 50);\n    }\n    \n    action Move {\n        posX <- posX + rnd(-5, 5);\n        posY <- posY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "Instruct a text-to-code model to generate a GAML code snippet that introduces a species named \"Prey,\" comprising attributes such as \"preyID,\" \"posX,\" and \"posY,\" along with an initialization block and an action called \"Move.\"",
        "output": "\nspecies Prey {\n    int preyID;\n    float posX, posY;\n    \n    init {\n        preyID <- rnd(1, 1000);\n        posX <- rnd(-50, 50);\n        posY <- rnd(-50, 50);\n    }\n    \n    action Move {\n        posX <- posX + rnd(-5, 5);\n        posY <- posY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "generate a gaml code snippet that introduces a species named \"Prey,\" comprising attributes such as \"preyID,\" \"posX,\" and \"posY,\" along with an initialization block and an action called \"Move.\"",
        "output": "\nspecies Prey {\n    int preyID;\n    float posX, posY;\n    \n    init {\n        preyID <- rnd(1, 1000);\n        posX <- rnd(-50, 50);\n        posY <- rnd(-50, 50);\n    }\n    \n    action Move {\n        posX <- posX + rnd(-5, 5);\n        posY <- posY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "Generate a GAML code snippet that defines a species named \"Hunter,\" incorporating attributes such as \"hunterID,\" \"posX,\" and \"posY,\" along with an initialization block and an action named \"Track.\"",
        "output": "\nspecies Hunter {\n    int hunterID;\n    float posX, posY;\n    \n    init {\n        hunterID <- rnd(1, 1000);\n        posX <- rnd(-50, 50);\n        posY <- rnd(-50, 50);\n    }\n    \n    action Track {\n        posX <- posX + rnd(-5, 5);\n        posY <- posY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "Develop a GAML code snippet presenting a species named \"Explorer,\" featuring attributes like \"explorerID,\" \"latitude,\" and \"longitude,\" along with an initialization block and an action named \"Navigate.\"",
        "output": "\nspecies Explorer {\n    int explorerID;\n    float latitude, longitude;\n    \n    init {\n        explorerID <- rnd(1, 1000);\n        latitude <- rnd(-90, 90);\n        longitude <- rnd(-180, 180);\n    }\n    \n    action Navigate {\n        latitude <- latitude + rnd(-2, 2);\n        longitude <- longitude + rnd(-2, 2);\n    }\n}\n"
    },
    {
        "instruction": "Create a GAML code snippet introducing a species named \"Robot,\" containing attributes such as \"robotID,\" \"positionX,\" and \"positionY,\" along with an initialization block and an action named \"MoveForward.\"",
        "output": "\nspecies Robot {\n    int robotID;\n    float positionX, positionY;\n    \n    init {\n        robotID <- rnd(1, 1000);\n        positionX <- rnd(-50, 50);\n        positionY <- rnd(-50, 50);\n    }\n    \n    action MoveForward {\n        positionX <- positionX + rnd(-5, 5);\n        positionY <- positionY + rnd(-5, 5);\n    }\n}\n"
    },
    {
        "instruction": "Generate a GAML code snippet defining a species named \"Fish,\" featuring attributes like \"fishID,\" \"depth,\" and \"swimDirection,\" alongside an initialization block and an action called \"Swim.\"",
        "output": "\nspecies Fish {\n    int fishID;\n    float depth, swimDirection;\n    \n    init {\n        fishID <- rnd(1, 1000);\n        depth <- rnd(1, 100);\n        swimDirection <- rnd(0, 360);\n    }\n    \n    action Swim {\n        depth <- depth + rnd(-5, 5);\n        swimDirection <- rnd(0, 360);\n    }\n}\n"
    },
    {
        "instruction": "Develop a GAML code snippet for a species named \"Bird,\" including attributes such as \"birdID,\" \"altitude,\" and \"flightDirection,\" along with an initialization block and an action named \"Fly.\"",
        "output": "\nspecies Bird {\n    int birdID;\n    float altitude, flightDirection;\n    \n    init {\n        birdID <- rnd(1, 1000);\n        altitude <- rnd(1, 50);\n        flightDirection <- rnd(0, 360);\n    }\n    \n    action Fly {\n        altitude <- altitude + rnd(-2, 2);\n        flightDirection <- rnd(0, 360);\n    }\n}\n"
    },
    {
        "instruction": "Create a GAML code snippet for a species named \"Vehicle,\" containing attributes like \"vehicleID,\" \"speed,\" and \"position,\" alongside an initialization block and an action named \"MoveForward.\"",
        "output": "\nspecies Vehicle {\n    int vehicleID;\n    float speed, position;\n    \n    init {\n        vehicleID <- rnd(1, 1000);\n        speed <- rnd(30, 120);\n        position <- rnd(-100, 100);\n    }\n    \n    action MoveForward {\n        position <- position + speed * rnd(0.8, 1.2);\n    }\n}\n"
    },
    {
        "instruction": "Develop a GAML code snippet for a species named \"Human,\" with attributes like \"humanID,\" \"age,\" and \"location,\" along with an initialization block and an action named \"Walk.\"",
        "output": "\nspecies Human {\n    int humanID;\n    int age;\n    float location;\n    \n    init {\n        humanID <- rnd(1, 1000);\n        age <- rnd(1, 100);\n        location <- rnd(-10, 10);\n    }\n    \n    action Walk {\n        location <- location + rnd(-2, 2);\n    }\n}\n"
    },
    {
        "instruction": "Generate a GAML code snippet for a species named \"Building,\" featuring attributes such as \"buildingID,\" \"height,\" and \"location,\" alongside an initialization block and an action named \"Collapse.\"",
        "output": "\nspecies Building {\n    int buildingID;\n    float height, location;\n    \n    init {\n        buildingID <- rnd(1, 1000);\n        height <- rnd(10, 100);\n        location <- rnd(-100, 100);\n    }\n    \n    action Collapse {\n        height <- 0;\n    }\n}\n"
    },
    {
        "instruction": "Create a GAML code snippet introducing a species named \"Plant,\" including attributes like \"plantID,\" \"growthRate,\" and \"nutrientLevel,\" along with an initialization block and an action named \"Grow.\"",
        "output": "\nspecies Plant {\n    int plantID;\n    float growthRate, nutrientLevel;\n    \n    init {\n        plantID <- rnd(1, 1000);\n        growthRate <- rnd(0.1, 1.0);\n        nutrientLevel <- rnd(0, 100);\n    }\n    \n    action Grow {\n        nutrientLevel <- nutrientLevel + growthRate * rnd(0.8, 1.2);\n    }\n}\n"
    },
    {
        "instruction": "Develop a GAML code snippet for a species named \"Insect,\" comprising attributes like \"insectID,\" \"wingColor,\" and \"position,\" along with an initialization block and an action named \"Fly.\"",
        "output": "\nspecies Insect {\n    int insectID;\n    string wingColor;\n    float position;\n    \n    init {\n        insectID <- rnd(1, 1000);\n        wingColor <- choose(\"Red\", \"Green\", \"Blue\");\n        position <- rnd(-10, 10);\n    }\n    \n    action Fly {\n        position <- position + rnd(-2, 2);\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, defining attributes such as \"nb_preys_init,\" \"prey_max_energy,\" \"prey_max_transfer,\" and \"prey_energy_consum,\" along with an initialization block that creates a specified number of preys?",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        float prey_max_energy <- 1.0;\n        float prey_max_transfer <- 0.1;\n        float prey_energy_consum <- 0.05;\n        \n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "Develop a GAML code snippet for the global section of a model, defining attributes like \"nb_species_init,\" \"species_max_energy,\" \"species_max_transfer,\" and \"species_energy_consumption,\" along with an initialization block that creates a specific number of species.",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        float prey_max_energy <- 1.0;\n        float prey_max_transfer <- 0.1;\n        float prey_energy_consum <- 0.05;\n        \n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "Provide instructions for generating a GAML code snippet in the global section of a model, introducing variables such as \"nb_cells_init,\" \"cell_max_energy,\" \"cell_max_transfer,\" and \"cell_energy_consumption,\" along with an initialization block creating a designated number of cells.",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        float prey_max_energy <- 1.0;\n        float prey_max_transfer <- 0.1;\n        float prey_energy_consum <- 0.05;\n        \n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "Direct the generation of a GAML code snippet for the global section of a model, defining parameters like \"nb_agents_init,\" \"agent_max_energy,\" \"agent_max_transfer,\" and \"agent_energy_consumption,\" along with an initialization block creating a specified number of agents.",
        "output": "\nglobal {\n        int nb_preys_init <- 200;\n        float prey_max_energy <- 1.0;\n        float prey_max_transfer <- 0.1;\n        float prey_energy_consum <- 0.05;\n        \n        init {\n                create prey number: nb_preys_init;\n        }\n}\n"
    },
    {
        "instruction": "",
        "output": "\nglobal {\n    int nb_entities_init <- 100;\n    float entity_max_energy <- 10.0;\n    float entity_max_transfer <- 1.0;\n    float entity_energy_consumption <- 0.1;\n\n    init {\n        create entity number: nb_entities_init;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, defining variables such as \"nb_agents_init,\" \"agent_max_energy,\" \"agent_max_transfer,\" and \"agent_energy_consumption,\" along with an initialization block that creates a predetermined number of agents",
        "output": "\nglobal {\n    int nb_agents_init <- 150;\n    float agent_max_energy <- 8.0;\n    float agent_max_transfer <- 0.8;\n    float agent_energy_consumption <- 0.15;\n\n    init {\n        create agent number: nb_agents_init;\n    }\n}\n"
    },
    {
        "instruction": "produce a GAML code snippet for the global section of a model, defining attributes such as \"nb_cells_init,\" \"cell_max_energy,\" \"cell_max_transfer,\" and \"cell_energy_consumption,\" accompanied by an initialization block creating a specific number of cells",
        "output": "\nglobal {\n    int nb_cells_init <- 120;\n    float cell_max_energy <- 12.0;\n    float cell_max_transfer <- 1.2;\n    float cell_energy_consumption <- 0.12;\n\n    init {\n        create cell number: nb_cells_init;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, outlining variables like \"nb_species_init,\" \"species_max_energy,\" \"species_max_transfer,\" and \"species_energy_consumption,\" with an initialization block that creates a specified number of species",
        "output": "\nglobal {\n    int nb_species_init <- 80;\n    float species_max_energy <- 6.0;\n    float species_max_transfer <- 0.6;\n    float species_energy_consumption <- 0.18;\n\n    init {\n        create species number: nb_species_init;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, defining variables like \"nb_species_init,\" \"species_max_energy,\" and \"species_type\" with data types \"int,\" \"float,\" and \"string\" respectively, accompanied by an initialization block that creates a specified number of species?",
        "output": "\nglobal {\n    int nb_species_init <- 80;\n    float species_max_energy <- 6.0;\n    string species_type <- \"Mammal\";\n    \n    init {\n        create species number: nb_species_init;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, specifying variables such as \"species_name\" with data type \"string,\" \"species_max_transfer,\" and \"species_energy_consumption\" with data type \"float,\" accompanied by an initialization block that creates a designated number of species?",
        "output": "\nglobal {\n    string species_name <- \"Bird\";\n    float species_max_transfer <- 0.6;\n    float species_energy_consumption <- 0.18;\n\n    init {\n        create species number <- 50;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, defining variables like \"species_name\" with data type \"string,\" \"species_max_transfer,\" and \"species_energy_consumption\" with data type \"float,\" along with an initialization block that creates a specified number of species?",
        "output": "\nglobal {\n    string species_name <- \"Bird\";\n    float species_max_transfer <- 0.6;\n    float species_energy_consumption <- 0.18;\n\n    init {\n        create species number <- 50;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, specifying variables such as \"nb_species_init\" with data type \"int\" and \"species_family\" with data type \"string,\" accompanied by an initialization block that creates a predetermined number of species",
        "output": "\nglobal {\n    int nb_species_init <- 80;\n    string species_family <- \"Reptile\";\n    \n    init {\n        create species number: nb_species_init;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, defining variables such as \"nb_species_init\" with data type \"int\" and \"species_family\" with data type \"string,\" where \"nb_species_init\" is initialized with a random value between 40 and 50, accompanied by an initialization block that creates a specified number of species",
        "output": "\nglobal {\n    int nb_species_init <- rnd(40,50);\n    string species_family <- \"Reptile\";\n    \n    init {\n        create species number: nb_species_init;\n    }\n}\n"
    },
    {
        "instruction": " generate a GAML code snippet for the global section of a model, defining variables like \"nb_species_init\" with data type \"int\" and \"species_density\" with data type \"float,\" where \"nb_species_init\" is initialized with a random value between 30 and 60, accompanied by an initialization block that creates a specified number of species",
        "output": "\nglobal {\n    int nb_species_init <- rnd(30, 60);\n    float species_density <- 0.5;\n    \n    init {\n        create species number: nb_species_init;\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, specifying variables such as \"nb_species_init\" with data type \"float\" and \"species_type\" with data type \"string,\" where \"nb_species_init\" is initialized with a random value between 40 and 50, accompanied by an initialization block that creates a specified number of species",
        "output": "\nglobal {\n    float nb_species_init <- rnd(40, 50);\n    string species_type <- \"Amphibian\";\n    \n    init {\n        create species number: int(nb_species_init);\n    }\n}\n"
    },
    {
        "instruction": "generate a GAML code snippet for the global section of a model, defining variables like \"nb_species_init\" with data type \"float\" and \"species_type\" with data type \"string,\" where \"nb_species_init\" is initialized with a random value between 40 and 50, accompanied by an initialization block that creates a specified number of species?",
        "output": "\nglobal {\n    float nb_species_init <- rnd(40, 50);\n    string species_type <- \"Amphibian\";\n    \n    init {\n        create species number: int(nb_species_init);\n    }\n}\n"
    },
    {
        "instruction": "create building agents from the buildings_simple.shp file located in the includes folder, and initialize the agents' height and type attributes respectively from the \"HEIGHT\" and \"NATURE\" attributes in the Shapefile.",
        "output": "create building from: shape_file(\"..\/includes\/buildings_simple.shp\") with:(height:float(get(\"HEIGHT\")), type:string(get(\"NATURE\")));"
    },
    {
        "instruction": "Create a model with one experiment called GIS_agentification to import the geometries in the buildings_simple.shp shapefile in the includes folder and agentify them as building agents, that are displayed in gray in the display city_display.",
        "output": "model simpleShapefileLoading\n\n\nglobal {\n    file shape_file_buildings <- shape_file(\\\"..\/includes\/buildings_simple.shp\\\");\n    \n    geometry shape <- envelope(shape_file_buildings);\n    init {\n        create building from: shape_file_buildings;\n    }\n}\n\nspecies building {\n\n    aspect default {\n        draw shape color: #gray;\n    }\n    \n}\n\nexperiment GIS_agentification type: gui {\n    output {\n        display city_display {\n            species building;\n        }\n    }\n}"
    },
    {
        "instruction": "define a default aspect that draws the agent as a circle with a radius of 0.5 m, red in color and with a yellow border.",
        "output": "aspect default {\n    draw circle(0.5) color: #red border: #yellow;\n}"
    },
    {
        "instruction": "Given a list l and a value v, how can I see if the list l contains the value v ?",
        "output": "bool l_contain_v <- l contains v;"
    },
    {
        "instruction": "I want my road agents to be displayed with their geometries in red by default, with a width of 5m. ",
        "output": "species road {\n\taspect default {\n\t\tdraw shape + 5.0 color: #red;\n\t}\n}\n "
    },
    {
        "instruction": "writes a model in which 'people' agents move on a 50 by 50 'cell' grid, avoiding obstacles. Each grid cell has a probability of 0.2 of being an obstacle (drawn in black - white if not). There is a 'goal' agent represented by a red circle of 0.5m radius placed at initialization on a random cell that is not an obstacle. There are 10 'people' agents, also placed at initialization on non-obstacle cell and represented by 0.5m-radius green circles. Until they arrive, people agents move at each simulation step at a speed of 3m\/s towards the goal agent, avoiding the obstacle cells.",
        "output": "model Grid\n\nglobal {\n\tinit {    \n\t\tcreate goal{\n\t\t\tlocation <- (one_of (cell where not each.is_obstacle)).location;\n\t\t}\n\t\tcreate people number: 10 {\n\t\t\ttarget <- one_of (goal);\n\t\t\tlocation <-  (one_of (cell where not each.is_obstacle)).location;\n\t\t}\n\t} \n}\n\ngrid cell width: 50 height: 50  {\n\tbool is_obstacle <- flip(0.2);\n\trgb color <- is_obstacle ? #black : #white;\n} \n\t \nspecies goal {\n\taspect default { \n\t\tdraw circle(0.5) color: #red;\n\t}\n}  \n\t\n\t  \nspecies people skills: [moving] {\n\tgoal target;\n\tfloat speed <- float(3);\n\taspect default {\n\t\tdraw circle(0.5) color: #green;\n\t}\n\t\n\treflex move when: location != target{\n\t\tdo goto (on:(cell where not each.is_obstacle), target:target, speed:speed);\n\t}\n}\n\nexperiment goto_grid type: gui {\n\toutput {\n\t\tdisplay objects_display {\n\t\t\tgrid cell border: #black;\n\t\t\tspecies goal  ;\n\t\t\tspecies people ;\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "writes a model in which 'people' agents move along a set of roads to reach a target. At initialization, a network of roads is created from the \"roads.shp\" shapefile in the \"includes\" folder.  These roads are used to build a graph called \"the_graph\". Once the graph has been calculated, 1 \"goal\" agent and 100 \"people\" agents are created, each randomly placed on one of the roads.  At each time step, the people agents move directly from the goal agent using the roads at a speed of 1m\/s. In the display, the roads are represented by their geometry drawn in black, the goal agent by a red circle with a radius of 50m and the people agents by a green circle with a radius of 50m. ",
        "output": "model Network\n\nglobal {\n\tfile shape_file_in <- file('..\/includes\/roads.shp') ;\n\tgraph the_graph; \n\tgeometry shape <- envelope(shape_file_in);\n\t\n\tint nb_people <- 100;\n\t\n\tinit {    \n\t\tcreate road from: shape_file_in ;\n\t\tthe_graph <- as_edge_graph(list(road));\n\t\n\t\tcreate goal {\n\t\t\tlocation <- any_location_in (one_of(road));\n\t\t}\n\t\tcreate people number: nb_people {\n\t\t\ttarget <- one_of (goal) ;\n\t\t\tlocation <- any_location_in (one_of(road));\n\t\t} \n\t}\n}\n\nspecies road  {\n\taspect default {\n\t\tdraw shape color: #black ;\n\t}\n} \n\t\nspecies goal {\n\taspect default {\n\t\tdraw circle(50) color: #red;\n\t}\n}\n\t\nspecies people skills: [moving] {\n\tgoal target;\n\tpath my_path; \n\t\n\taspect default {\n\t\tdraw circle(50) color: #green;\n\t}\n\treflex movement {\n\t\tdo goto on:the_graph target:target speed:1.0;\n\t}\n}\n\n\nexperiment goto_network type: gui {\n\toutput {\n\t\tdisplay objects_display {\n\t\t\tspecies road ;\n\t\t\tspecies people  ;\n\t\t\tspecies goal  ;\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Define a species of agents called \"thread_agent\" which executes every 1 second in a specific thread an action that writes the agent's name and the current time to the console. ",
        "output": "species thread_agent skills: [thread] {\n\tinit {\n\t\tdo run_thread every: 1#s;\n\t}\n\t\n\t\/\/the action run in the thread\n\taction thread_action {\n\t\twrite \" > \" + self + \"current time: \" + #now;\n\t}\t\n}"
    },
    {
        "instruction": "Defines a type of agent called people which moves towards a randomly chosen point in the space it perceives at a speed of 1m\/s. The space it perceives is calculated at each time step by a 60-degree amplitude perception cone at a maximum distance of 40m, masked by agents of the obstacle species with a precision of 600. People agents are drawn by default in the form of a red triangle with 2m sides, oriented in the direction in which the agent is moving. In addition, if the perception zone is not null, it is drawn in green. \n",
        "output": "species people skills: [moving]{\n\tgeometry perceived_area;\n\tpoint target ;\n\t\n\treflex move {\n\t\tif (target = nil ) {\n\t\t\ttarget <- any_location_in(perceived_area);\n\t\t} \n\t\tdo goto target: target;\n\t\tif (location = target)  {\n\t\t\ttarget <- nil;\n\t\t}\n\t}\n\t\n\treflex update_perception {\n\t\tperceived_area <- (cone(heading-30,heading+30) intersection world.shape) intersection circle(40.0); \n\t\t\n\t\tif (perceived_area != nil) {\n\t\t\tperceived_area <- perceived_area masked_by (obstacle,600);\n\n\t\t}\n\t}\n\t\n\taspect default {\n\t\tdraw triangle(2) rotate:90 + heading color: #red;\n\t\tif (perceived_area != nil) {\n\t\t\tdraw perceived_area color: #green;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Code a species called People with the attributes speed of type float, health of type int, and a boolean called is_happy. People can migrate if they are not happy.\n",
        "output": "species People {\n        float speed <- 1.0f;\n        int health <- 30;\n        bool is_happy <- false;\n\n        init {\n            \/\/ Init section of species People\n        }\n\n        \/\/ Species People can migrate if not happy\n        reflex migrate when: !is_happy {\n            \/\/ Actions to perform when the reflex is triggered\n        }\n    }"
    },
    {
        "instruction": "Create a display to show my map gauss_distrib in a bar chart. The title should be \"Gauss Distribution\". The list of bins are accessed with the \"legend\" key, the list of values of each bin with the \"values\" key",
        "output": "display \"Gauss Distribution\"  type: 2d {\n\t\t\tchart \"Gauss Distribution\" type: histogram {\n\t\t\t\tdatalist (gauss_distrib at \"legend\") value: (gauss_distrib at \"values\");\n\t\t\t}\n}"
    },
    {
        "instruction": "How to place a camera at a specific places in my model? ",
        "output": "display view type: opengl {\ncamera 'default' location: {x1,y1,z1} target: {x2,y2,z2};\n}"
    },
    {
        "instruction": "Defines a model called test_time which stores in a global map called time_action of type string float the time taken by the model's global actions, and which displays in a global reflex called display_benchmark every 100 cycles the time taken in ms by each action. In the model, a single action is defined, called \"action_loop\", which performs an empty loop of 1000 iterations.  This action is called in a reflex called dynamic at each time step. Finally, an experiment called run is defined. \n",
        "output": "model test_time\n\nglobal {\n\tmap<string, float> time_action;\n\t\n\t\n\treflex dynamic {\n\t\tdo action_loop;\n\t}\n\t\n\treflex display_benchmark when: every(100 #cycle){\n\t\twrite \"***** \" + cycle + \" *****\";\n\t\tloop act over: time_action.keys {\n\t\t\twrite act + \" -> \" + time_action[act] + \"ms\";\n\t\t}\n\t}\n\t\n\taction action_loop {\n\t\tfloat t <- machine_time;\n\t\tloop times: 1000 {\n\t\t}\n\t\ttime_action[\"action_loop\"] <-  time_action[\"action_loop\"] + (machine_time -t);\n\t}\n}\n\nexperiment run;"
    },
    {
        "instruction": "In this experiment, add an additional simulation to be run in parallel with 5 as the value for the global variable nb_agents: \n\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies dummy;\n\t\t}\n\t}\n}",
        "output": "\nexperiment main type: gui {\n\t\/\/we define a init block to create new simulations\n\tinit {\n\t\t\/\/we create a second simulation (the first simulation is always created by default) with the following parameters\n\t\tcreate simulation with: (nb_agents: 5);\n\t\t\n\t}\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies dummy;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "in experiment \"main\", define a minimum duration for each cycle of 0.1s",
        "output": "\nexperiment main type: gui {\n\t\/\/definition of a minimal duration for each cycle. As the model is very simple, it can run too fast to observe the results, so we slow it down.\n\tfloat minimum_cycle_duration <- 0.1;\n}"
    },
    {
        "instruction": "Create 100 individual agents at the initialization of the model",
        "output": "global {\n\ninit {\ncreate individual number:100\n}\n\n}\n\nspecies individual {}"
    },
    {
        "instruction": "generates a snippet of code that asks 2 random agents of the species \"dummy_species\" to write their name on the console. ",
        "output": "ask 2 among dummy_species {\n\twrite name;\n}"
    },
    {
        "instruction": "How to create agent from a given species with initial values ?",
        "output": "\ninit\n{\n  int value <- 10;\n  create speciesName with: [data::value];\n}\n\nspecies speciesName \n{\n   int data;\n}"
    },
    {
        "instruction": "define a sheep species that can wander randomly in continuous environment",
        "output": "species sheep skills:[moving]{\nrelfex wandering{\ndo wander;\n}\n}"
    },
    {
        "instruction": "Write a loop statement over a species of agent",
        "output": "loop i over: speciesName\n{\n   write(i.data);\n}\n\n\n\nspecies speciesName\n{\n  int data <- 10 \/\/ random value\n}"
    },
    {
        "instruction": " model creates a simple simulation of agents moving randomly in a continuous space.\n\n",
        "output": "model simple_agent_model\n\nglobal {\n  int nb_agents <- 100;\n  geometry shape <- square(100);\n  init {\n    create species1 number: nb_agents {\n      location <- one_of(shape);\n    }\n  }\n}\n\nspecies species1 {\n  aspect base {\n    draw circle(1) color: #blue;\n  }\n  reflex move {\n    do wander amplitude: 10 speed: 1;\n  }\n}\n\nexperiment my_experiment type: gui {\n  output {\n    display \"my_display\" {\n      species species1 aspect: base;\n    }\n  }\n}\n"
    },
    {
        "instruction": "model simulates a predator-prey relationship. predators and preys are created in the initialization (init) block of the global scope. Each agent is located at a random point within a square of side length 100. The reflex move block defines the behavior of the agents, which is to wander randomly. The predators have an additional reflex eat block, which causes any preys within a distance of 1 to die. The experiment block sets up a graphical user interface (GUI) for running the model and visualizing the agents.\n\n",
        "output": "model PredatorPrey\n\nglobal {\n  int nb_predators <- 50;\n  int nb_preys <- 200;\n  geometry shape <- square(100);\n  init {\n    create predators number: nb_predators {\n      location <- one_of(shape);\n    }\n    create preys number: nb_preys {\n      location <- one_of(shape);\n    }\n  }\n}\n\nspecies predators {\n  aspect base {\n    draw circle(1) color: #red;\n  }\n  reflex move {\n    do wander amplitude: 10 speed: 1;\n  }\n  reflex eat {\n    ask preys within: 1 {\n      do die;\n    }\n  }\n}\n\nspecies preys {\n  aspect base {\n    draw circle(1) color: #blue;\n  }\n  reflex move {\n    do wander amplitude: 10 speed: 1;\n  }\n}\n\nexperiment my_experiment type: gui {\n  output {\n    display \"my_display\" {\n      species predators aspect: base;\n      species preys aspect: base;\n    }\n  }\n}\n"
    },
    {
        "instruction": "Put a circle in the center of the model. Make it grow each simulation step and until it covers the whole space of the model",
        "output": "global {\n\ngeometry circle <- circle(1) at_location {50,50};\n\nreflex grow when: circle.width < 100 {\ncircle <- circle buffer 1;\n}\n\n}"
    },
    {
        "instruction": "generates a code snippet that creates road agents from the file roads_shape_file and that builds the road_network graph from these roads. ",
        "output": "create road from: roads_shape_file;\nroad_network <- as_edge_graph(road);\n\t"
    },
    {
        "instruction": "Using the network plugin, generate a reflex to display a message that have been received",
        "output": "reflex fetch_message when:has_more_message()\n{\t\n   message mess <- fetch_message();\n   write(\"received message : \" + mess);\n}"
    },
    {
        "instruction": "write a model with sheep and wolves are created in the initialization (init) block of the global scope. Each agent is located at a random point within a square of side length 100. The reflex move block defines the behavior of the agents, which is to wander randomly. The wolves have an additional reflex eat block, which causes any sheep within a distance of 1 to die. The sheep have an additional reflex eaten block, which causes them to die if a wolf is within a distance of 1. The experiment block sets up a graphical user interface (GUI) for running the model and visualizing the agents.",
        "output": "model Ecosystem\n\nglobal {\n  int nb_sheep <- 100;\n  int nb_wolves <- 50;\n  geometry shape <- square(100);\n  init {\n    create sheep number: nb_sheep {\n      location <- one_of(shape);\n    }\n    create wolves number: nb_wolves {\n      location <- one_of(shape);\n    }\n  }\n}\n\nspecies sheep {\n  aspect base {\n    draw circle(1) color: #green;\n  }\n  reflex move {\n    do wander amplitude: 10 speed: 1;\n  }\n  reflex eaten {\n    ask wolves within: 1 {\n      do die;\n    }\n  }\n}\n\nspecies wolves {\n  aspect base {\n    draw circle(1) color: #red;\n  }\n  reflex move {\n    do wander amplitude: 10 speed: 1;\n  }\n  reflex eat {\n    ask sheep within: 1 {\n      do die;\n    }\n  }\n}\n\nexperiment my_experiment type: gui {\n  output {\n    display \"my_display\" {\n      species sheep aspect: base;\n      species wolves aspect: base;\n    }\n  }\n}\n"
    },
    {
        "instruction": "How can I draw a red line in my display from point A to B?",
        "output": "display view type: opengl {\ngraphics \"Lines\" {\n  draw line([{xa,ya}, {xb,yb}]); color: #red;\n}\n}"
    },
    {
        "instruction": "Define a global variable that computes at each step the number of people agents with the attribute is_happy is true.",
        "output": "global {\n\t\/\/ other attributes\n\tint nb_happy_people <- 0 update: people count each.is_happy ;\n\t\/\/...\n}"
    },
    {
        "instruction": "Right me a code that simulates an agent moving in an environment with obstacles. It must define the agent's perception distance, computes its field of vision, and controls its movement behavior. The GUI provides a visual representation of the environment and the agent's actions and field of vision.",
        "output": "\/**\n* Name: fieldofvision\n* Author: Patrick Taillandier\n* Description: This model illustrate how to use the masked_by operator to compute the field of vision of an agent (with obtsacles)\n* Tags: perception, spatial_computation, masked_by\n*\/\n\nmodel fieldofvision\n\nglobal {\n\t\/\/number of obstacles\n\tint nb_obstacles <- 20 parameter: true;\n\t\n\t\/\/perception distance\n\tfloat perception_distance <- 40.0 parameter: true;\n\t\n\t\/\/precision used for the masked_by operator (default value: 120): the higher the most accurate the perception will be, but it will require more computation\n\tint precision <- 600 parameter: true;\n\t\n\t\/\/space where the agent can move.\n\tgeometry free_space <- copy(shape);\n\tinit {\n\t\tcreate obstacle number:nb_obstacles {\n\t\t\tshape <- rectangle(2+rnd(20), 2+rnd(20));\n\t\t\tfree_space <- free_space - shape;\n\t\t}\n\t\t\n\t\tcreate people  {\n\t\t\tlocation <- any_location_in(free_space);\n\t\t}\n\t}\n}\n\nspecies obstacle {\n\taspect default {\n\t\tdraw shape color: #gray border: #black;\n\t}\n}\nspecies people skills: [moving]{\n\t\/\/zone of perception\n\tgeometry perceived_area;\n\t\n\t\/\/the target it wants to reach\n\tpoint target ;\n\t\n\treflex move {\n\t\tif (target = nil ) {\n\t\t\tif (perceived_area = nil) or (perceived_area.area < 2.0) {\n\t\t\t\t\/\/if the agent has no target and if the perceived area is empty (or too small), it moves randomly inside the free_space\n\t\t\t\tdo wander bounds: free_space;\n\t\t\t} else {\n\t\t\t\t\/\/otherwise, it computes a new target inside the perceived_area .\n\t\t\t\ttarget <- any_location_in(perceived_area);\n\t\t\t}\n\t\t} else {\n\t\t\t\/\/if it has a target, it moves towards this target\n\t\t\tdo goto target: target;\n\t\t\t\n\t\t\t\/\/if it reaches its target, it sets it to nil (to choose a new target)\n\t\t\tif (location = target)  {\n\t\t\t\ttarget <- nil;\n\t\t\t}\n\t\t}\n\t}\n\t\/\/computation of the perceived area\n\treflex update_perception {\n\t\t\/\/the agent perceived a cone (with an amplitude of 60\u00b0) at a distance of  perception_distance (the intersection with the world shape is just to limit the perception to the world)\n\t\tperceived_area <- (cone(heading-30,heading+30) intersection world.shape) intersection circle(perception_distance); \n\t\t\n\t\t\/\/if the perceived area is not nil, we use the masked_by operator to compute the visible area from the perceived area according to the obstacles\n\t\tif (perceived_area != nil) {\n\t\t\tperceived_area <- perceived_area masked_by (obstacle,precision);\n\n\t\t}\n\t}\n\t\n\taspect body {\n\t\tdraw triangle(2) rotate:90 + heading color: #red;\n\t}\n\taspect perception {\n\t\tif (perceived_area != nil) {\n\t\t\tdraw perceived_area color: #green;\n\t\t\tdraw circle(1) at: target color: #magenta;\n\t\t}\n\t}\n}\n\nexperiment fieldofvision type: gui {\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput synchronized: true {\n\t\tdisplay view{\n\t\t\tspecies obstacle;\n\t\t\tspecies people aspect: perception transparency: 0.5;\n\t\t\tspecies people aspect: body;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "generates a code snippet that creates 1,000 inhabitant agents and places each one in a randomly chosen location in one of the building agents chosen randomly. ",
        "output": "create inhabitant number: 1000 {\n\tbuilding a_building <- one_of(building);\n\tlocation <- any_location_in(a_building);\t \n}"
    },
    {
        "instruction": "How to get the id of an agent? ",
        "output": "agent a;\nint id <- int(a);"
    },
    {
        "instruction": "Create a random number of agent and make them move around randomly",
        "output": "global {\n\nint rnd_number <- 100;\n\ninit {\ncreate a number:rnd(rnd_number);\n}\n\n}\n\nspecies a skills:[moving]{\n\nreflex move_random {\ndo wander;\n}\n\n}"
    },
    {
        "instruction": "write some code that creates an hexagonal grid and displays it. The model will pick a random cell, change its color to red and its neighbours' colors to green",
        "output": "\/**\n* Name: HexagonalGrid\n* Author: Patrick Taillandier\n* Description: \n* Tags: grid, hexagon\n*\/\n\nmodel HexagonalGrid\n\nglobal {\n\tstring orientation <- \"horizontal\" among: [\"horizontal\", \"vertical\"] parameter: true;\t\n\t\n\tinit {\n\t\task cell {color <- #white;}\n\t}\n\treflex show_neighborhood {\n\t\task cell {color <- #white;}\n\t\task one_of(cell) {\n\t\t\tcolor <- #red;\n\t\t\task neighbors {\n\t\t\t\tcolor <- #green;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\/\/ the choices are 4,6 or 8 neighbors\ngrid cell height: 10 width: 10 neighbors: 6 horizontal_orientation: orientation = \"horizontal\";\n\n\nexperiment hexagonal type: gui{\n\toutput  synchronized:true{\n\t\tdisplay view type: 3d{\n\t\t\tgrid cell border: #black ;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "a model simulates the flow of water in a landscape with cells are created in the initialization (init) block of the global scope. Each cell is located at a random point within a square of side length 100 and has a random initial water level. The reflex flow block defines the behavior of the cells, which is to distribute their water to neighboring cells if they have more water than the average of their neighbors. The experiment block sets up a graphical user interface (GUI) for running the model and visualizing the cells.",
        "output": "model HydrologyModel\n\nglobal {\n  int nb_cells <- 100;\n  geometry shape <- square(100);\n  init {\n    create cells number: nb_cells {\n      location <- one_of(shape);\n      water_level <- rnd(100);\n    }\n  }\n}\n\nspecies cells {\n  float water_level;\n  aspect base {\n    draw square(1) color: rgb(0, 0, water_level);\n  }\n  reflex flow {\n    float total_water = sum_of(cells neighbors_at: 1, each.water_level);\n    float avg_water = total_water \/ count(cells neighbors_at: 1);\n    if (water_level > avg_water) {\n      float flow = (water_level - avg_water) \/ 2;\n      water_level <- water_level - flow;\n      ask cells neighbors_at: 1 {\n        water_level <- water_level + flow \/ count(cells neighbors_at: 1);\n      }\n    }\n  }\n}\n\nexperiment my_experiment type: gui {\n  output {\n    display \"my_display\" {\n      species cells aspect: base;\n    }\n  }\n}\n"
    },
    {
        "instruction": "Using the network plugin, write an action that send the string \"Hello\" to all agents connected to the network",
        "output": "action broadcastHello\n{\n do send to:\"ALL\" contents:\"Hello\";\n}\n"
    },
    {
        "instruction": "model simulates the diffusion of water in a landscape with cells are created in the initialization (init) block of the global scope. Each cell is located at a point in a grid of size grid_size and has a random initial water level. The reflex diffuse block defines the behavior of the cells, which is to distribute their water to neighboring cells based on the difference between their water level and the average water level of their neighbors. The amount of water that is diffused is controlled by the diffusion_rate. The experiment block sets up a graphical user interface (GUI) for running the model and visualizing the cells.\n",
        "output": "model WaterDiffusion\n\nglobal {\n  int grid_size <- 50;\n  float diffusion_rate <- 0.01;\n  init {\n    create cells number: grid_size * grid_size {\n      location <- cell_of(self, shape);\n      water_level <- rnd(100);\n    }\n  }\n}\n\ngrid cells width: grid_size height: grid_size neighbors: 8 {\n  float water_level;\n  reflex diffuse {\n    float total_water = sum_of(cells neighbors_at: 1, each.water_level);\n    float avg_water = total_water \/ count(cells neighbors_at: 1);\n    float diff = (water_level - avg_water) * diffusion_rate;\n    water_level <- water_level - diff;\n    ask cells neighbors_at: 1 {\n      water_level <- water_level + diff \/ count(cells neighbors_at: 1);\n    }\n  }\n  aspect base {\n    draw square(1) color: rgb(0, 0, water_level);\n  }\n}\n\nexperiment my_experiment type: gui {\n  output {\n    display \"my_display\" {\n      grid cells aspect: base;\n    }\n  }\n}\n"
    },
    {
        "instruction": "Generates a species of agent called road, which can be used to define a speed coefficient according to the number of agents on the road, in order to simulate traffic jams. This species has 3 attributes: capacity of type float, which corresponds to its length \/30 + 1; nb_drivers of type integer, which is initialized at 0.0 and is calculated at each time step by the number of inhabitant agents within 1m of the road; speed_rate of type float, which is initialized at 1.0 and is recalculated at each time step by an exponential of -nb_drivers\/capacity. \n",
        "output": "species road {\n\tfloat capacity <- 1 + shape.perimeter \/ 30#m;\n\tint nb_drivers <- 0 update: length(inhabitant at_distance 0.1);\n\tfloat speed_rate <- 1.0 update: exp(-nb_drivers \/ capacity) min: 0.1;\n}\n"
    },
    {
        "instruction": "Set my date variable to reflect the 23rd of March 2010 and time at 17:30:10.",
        "output": "date my_date <- date([2010,3,23,17,30,10]); "
    },
    {
        "instruction": "Given a model file named \"Multi-simulation.gaml\" containing a single species named dummy to display, how to create an experiment launching 2 simulations and displaying the agents of each simulation in 2 different displays?",
        "output": "import \"Multi-simulation.gaml\"\n\n\n\nexperiment main2 type: gui {\n\n\t\/\/we define a init block to create new simulations\n\tinit {\n\t\t\/\/we create a second simulation (the first simulation is always created by default)\n\t\tcreate simulation ;\n\t}\n\t\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies dummy;\n\t\t}\n\t}\n\n}"
    },
    {
        "instruction": "Give me an example of a multi-simulation experiment.",
        "output": "import \"Multi-simulation.gaml\"\n\n\n\nexperiment main2 type: gui {\n\n\t\/\/we define a init block to create new simulations\n\tinit {\n\t\t\/\/we create a second simulation (the first simulation is always created by default)\n\t\tcreate simulation ;\n\t}\n\t\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies dummy;\n\t\t}\n\t}\n\n}"
    },
    {
        "instruction": "create a model that write the 10 first number of the Fibonacci list in the console  ",
        "output": "global {\n\nlist<int> fibo <- [0,1]\n\ninit {\n\nloop times:10 {\nfibo <+ fibo[length(fibo)-1] + fibo[length(fibo)-2];\nwrite last(fibo);\n}\n\n}\n\n}"
    },
    {
        "instruction": "write a model to showcase the different ways to compute shortest paths on a grid between two points (a source and a goal) picked randomly. Display the source and goal as respectively green and red circles of 1m diameter. Display the path with lines connecting each step, and each step being represented by a triangle",
        "output": "\/**\n* Name:  Computation of the shortest path on a Grid of Cells\n* Author:  Patrick Taillandier\n* Description: Model to represent how to compute the shortest path from a grid (with the 4 algorithms).\n* Tags: grid, obstacle, shortest_path\n*\/\n\nmodel Grid\n\nglobal {\n\t\n\t\/*4 algorithms for the shortest path computation on a grid:\n\t*      - A* : default algorithm: Very efficient for both Moore (8) and Von Neumann (4) neighborhoods. An introduction to A*: http:\/\/www.redblobgames.com\/pathfinding\/a-star\/introduction.html\n\t*      - Dijkstra : Classic Dijkstra algorithm. An introduction to Dijkstra : http:\/\/www.redblobgames.com\/pathfinding\/a-star\/introduction.html\n\t*      - JPS : Jump Point Search, only usable for Moore (8) neighborhood. Most of time, more efficient than A*. An introduction to JPS: https:\/\/harablog.wordpress.com\/2011\/09\/07\/jump-point-search\/#3\n\t*      - BF : Breadth First Search. Should only be used for Von Neumann (4) neighborhood. An introduction to BF: http:\/\/www.redblobgames.com\/pathfinding\/a-star\/introduction.html\n\t*\/\n\t\n\tstring scenario <- \"wall\" among: [\"random\", \"wall\"] parameter: true;\n\tstring algorithm <- \"A*\" among: [\"A*\", \"Dijkstra\", \"JPS\", \"BF\"] parameter: true;\n\tint neighborhood_type <- 8 among:[4,8] parameter: true;\n\tfloat obstacle_rate <- 0.1 min: 0.0 max: 0.9 parameter: true;\n\tint grid_size <- 50 min: 5 max: 100 parameter: true;\n\tpoint source;\n\tpoint goal;\n\tpath the_path;\n\tinit toto {    \n\t\tif (scenario = \"wall\") {\n\t\t\task cell {is_obstacle <- false;}\n\t\t\tint x_max <- round(grid_size * 2\/3);\n\t\t\tloop i from: 2 to:x_max {\n\t\t\t\tcell[i, 3].is_obstacle <- true;\n\t\t\t\tcell[i, grid_size - 4].is_obstacle <- true;\n\t\t\t}\n\t\t\tloop i from: 3 to: grid_size - 4 {\n\t\t\t\tcell[x_max, i].is_obstacle <- true;\n\t\t\t}\n\t\t\task cell {color <- is_obstacle ? #black : #white;}\n\t\t}\n\t\tsource <- (one_of (cell where not each.is_obstacle)).location;\n\t\tgoal <- (one_of (cell where not each.is_obstacle)).location;\n\n\t\tusing topology(cell) {\n\t\t\tthe_path <- path_between((cell where not each.is_obstacle), source, goal);\t\n\t\t}\n\t} \n\t\n\treflex compute_path {\n\t\tsource <- (one_of (cell where not each.is_obstacle)).location;\n\t\tgoal <- (one_of (cell where not each.is_obstacle)).location;\n\n\t\tusing topology(cell) {\n\t\t\tthe_path <- path_between((cell where not each.is_obstacle), source, goal);\t\n\t\t}\n\t}\n}\n\ngrid cell width: grid_size height: grid_size neighbors: neighborhood_type optimizer: algorithm{\n\tbool is_obstacle <- flip(0.1);\n\trgb color <- is_obstacle ? #black : #white;\n} \n\n\t\n\nexperiment goto_grid type: gui {\n\toutput {\n\t\tdisplay objects_display type: 2d antialias:false{\n\t\t\tgrid cell border: #black;\n\t\t\tgraphics \"elements\" {\n\t\t\t\tdraw circle(1) color: #green at: source border: #black;\n\t\t\t\tdraw circle(1) color: #red at: goal  border: #black;\n\t\t\t\tloop v over: the_path.vertices {\n\t\t\t\t\tdraw triangle(0.5) color: #yellow border: #black at: point(v);\n\t\t\t\t}\n\t\t\t\tloop s over: the_path.segments {\n\t\t\t\t\tdraw s color: #red ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Generates an aspect called \"threeD\" that displays the agent's geometry with an extrusion value of \"height\" and 2 textures: the \"..\/includes\/roof.png\" file for the roof and the \"..\/includes\/texture5.jpg\" file for the facade.",
        "output": "aspect threeD {\n\tdraw shape depth: height texture: [\"..\/includes\/roof.png\",\"..\/includes\/texture5.jpg\"];\n}"
    },
    {
        "instruction": "How to launch a second simulation with given parameters values: its global values nb_agents (value = 5), agent_speed (value = 5.0) and agent_color (value = #red) ?",
        "output": "experiment main type: gui {\n\t\/\/we define a init block to create new simulations\n\tinit {\n\t\t\/\/we create a second simulation (the first simulation is always created by default) with the following parameters\n\t\tcreate simulation with: [nb_agents:: 5, agent_speed:: 5.0, agent_color:: #red];\n\t\t \n\t}\n}"
    },
    {
        "instruction": "Using the network plugin, write a code snippet of an action that display all the different attributes from a received message",
        "output": "action displayMessageInformation(message mess)\n{\n  write(\"content of the message \" + mess.contents);\n  write(\"sender of the message \" + mess.sender);\n  write(\"is the message unread ? \" + mess.unread);\n  write(\"message emission timestamp \" +  mess.emission_timestamp);\n  write(\"message reception timestamp \" + mess.recention_timestamp);\n}"
    },
    {
        "instruction": "Generates a code snippet that allows an agent to move towards the destination \"target\" on the \"road_network\" graph, and stores the path taken in the \"followed_path\" variable.",
        "output": "path followed_path <- goto(target: target, on: road_network,  return_path: true);\n\t\t"
    },
    {
        "instruction": "How to use a loop to display each element of a list one after the other?",
        "output": "list<string> list_of_string <- [\"A\",\"list\",\"of\",\"strings\",\".\"];\n\nloop id from: 0 to: length(list_of_string) - 1 {\n    write \"\" + id +\"th element of \" + list_of_string + \": \" + list_of_string[i];\n}"
    },
    {
        "instruction": "write me a species to represent people and that could be displayed in many different ways using different displays",
        "output": "species people {\n\tstring aspect_type;\n\trgb color_transparency <- rgb(#darkred, 0.4 \/ (1 + int(self)));\n\n\t\/\/ aspect blocks defines how each agent is displayed\n\taspect default {\n\t\/\/ The draw statement takes any drawable objects (geometry, text, image)...\n\t\/\/ The aspect color: defines the inner color of the geometry or the color of the text.\n\t\/\/ The aspect border: defines the geometry border color.\n\t\tdraw circle(0.5) color: #red border: #yellow;\n\t\tdraw aspect_type color: #black at: location + {0, 4, 1} anchor: #bottom_center depth: 3;\n\t}\n\n\t\/\/ In an aspect, it is possible to draw several layers one after the other.\t\n\taspect simple {\n\t\tdraw circle(0.5) color: #grey border: #darkgrey;\n\t\t\/\/ The facet wireframe: sets whether the drawn geometry is plain or empty.  \n\t\tdraw circle(1.0) border: #darkgreen wireframe: true;\n\t\tdraw square(3.0) border: #darkgreen wireframe: true;\n\t}\n\n\taspect big_square_for_transparency {\n\t\tdraw square(3.0) color: #darkblue border: #black;\n\t}\n\n\taspect big_circle_with_transparency {\n\t\tdraw circle(5.0) color: color_transparency border: #black;\n\t}\n\n\t\/\/ The object to draw can be text.\n\t\/\/ The draw can be configured using the color: facet and the font: one.\n\t\/\/ font: facet is expecting a font obbject composed by the name of the font, its size and #bold\/#italic\/#plain\/#bold+#italic.\t\n\taspect simple_text {\n\t\/\/ perspective: facet specifies whether to render the text in perspective or facing the user.\t\t\n\t\tdraw \"Agent: \" + name + \"(rotate!)\" at: location + {0, 8, 0} color: #green font: font(\"Arial\", 10, #bold) perspective: false;\n\t\tdraw \"Agent: \" + name at: location + {0, 6, 0} color: #blue font: font(\"SansSerif\", 15, #italic) perspective: true;\n\t}\n\n\t\/\/ When a line is drawn, it could be interesting to also draw an arrow at one of the extremities of the line\n\taspect arrows {\n\t\/\/ begin_arrow: and end_arrow: facets are used to define the size of the drawn line.\n\t\/\/ width: facet can be used to increase the width of a line \n\t\/\/ (the use of width with other geometry will provide unexpected result, as it increase each line of the geometry)\n\t\tdraw line([self.location, people(8).location]) color: #orange end_arrow: 1 begin_arrow: 2.2 width: 3.0;\n\t}\n\n\t\/\/ at (point): location where the shape\/text\/icon is drawn\n\t\/\/ rotate (any type in [float, int, pair]): orientation of the shape\/text\/icon; can be either an int\/float (angle) or a pair float::point (angle::rotation axis). The rotation axis, when expressed as an angle, is by defaut {0,0,1}\n\t\/\/ The elements drawn are by default located on the agent location, but they can be moved anywhere in the environment.\n\t\/\/ They can also be rotated.\t\t\n\taspect locate_geometry {\n\t\tdraw square(1.0) color: #silver border: #black at: world.location rotate: 45;\n\t\tdraw \"Agent in center\" color: #green font: font(\"Arial\", 15, #bold) at: world.location + {0.0, 2.0, 0.0} anchor: #bottom_center;\n\t}\n\n\t\/\/ In an OpenGL display, the various geometries can be displayed in 3d, or more specifically with a depth (facet depth:).\n\t\/\/ for example, a circle with depth, will be displayed as a cylinder.\n\t\/\/ These 3D objects be displayed taken into account the light or not with the lighted facet:\n\taspect col3D {\n\t\tdraw circle(1.0) color: #tomato depth: 5.0 lighted: true;\n\t\tdraw sphere(1.0) at: (location - {2.0, 0.0, 0.0}) color: #tomato;\n\t\tdraw cube(1.0) at: (location - {-2.0, 0.0, 0.0}) color: #tomato;\n\t\tdraw square(1.0) at: (location - {-2.0, 2.0, 0.0}) color: #tomato depth: 5.0 lighted: true;\n\t}\n\n\t\/\/ In a 3D display (openGL), agents can add texture (i.e. a picture on the geometry) and can be lighted or not.\n\taspect textured {\n\t\tdraw sphere(2.0) color: #tomato;\n\t\tdraw sphere(2.0) at: (location - {4.0, 0.0, 0.0}) color: #tomato lighted: false;\n\t\tdraw sphere(2.0) at: (location - {-4.0, 0.0, 0.0}) color: #tomato texture: wood0_image_file;\n\t}\n\n\t\/\/ When an agent is displayed drawing a picture, that picture can be resize (using the size: facet).\n\taspect image {\n\t\tdraw wood0_image_file size: {50.0, 10.0, 0.0};\n\t}\n\n}"
    },
    {
        "instruction": "generate a code snippet that defines a list of string called \"list_of_string\" composed of three elements \"A\", \"B\" and \"C\"",
        "output": "list<string> list_of_string <- [\"A\",\"B\",\"C\"];\n\t"
    },
    {
        "instruction": "How can I repeat a set of statements while iterating over a full container?\t\t\n",
        "output": "list<string> list_of_string <- [\"A\",\"list\",\"of\",\"strings\",\".\"];\n\nloop elt over: list_of_string {\n   write sample(elt);\n}"
    },
    {
        "instruction": "Generates a code snippet that loops over all the elements of the \"list_of_string\" list and displays them in the console. ",
        "output": "loop elt_of_list over: list_of_string {\n\twrite sample(elt_of_list);\n}\t\t"
    },
    {
        "instruction": "How to use a while-loop to display all the elements of a list of string values?",
        "output": "list<string> list_of_string <- [\"A\",\"list\",\"of\",\"strings\",\".\"];\nint id <- 0;\n\nloop while: (id < length(list_of_string) {\n   write \"\" + id +\"th element of \" + list_of_string;\n   write \"  \" + sample(list_of_string[id]); \t\t\t\n   \/\/ id should be incremented ... otherwise the loop while never end.\n   id <- id + 1;\n}\t\t\t\t\t\n"
    },
    {
        "instruction": "code a model named DEM, in global there is variable dem_file of type file, pointed to a raster file DEM_500x500.tif. create a grid agent cel_dem using the dem_file with the attribute elevation of type float. Init value of elevation is the grid value.",
        "output": "model load_DEM\n\nglobal {\n\t\n\tfile dem_file <- grid_file(\"..\/includes\/DEM\/DEM_500x500.tif\");\n}\ngrid cell_dem file: dem_file {\n\tfloat elevation <- float(grid_value);\n}\n"
    },
    {
        "instruction": "Generate a code snippet that define a matrice called  \"mat\" that has a size of 3x3 filled with 0.\n",
        "output": "matrix mat <- {3,3} matrix_with 0; \n\t"
    },
    {
        "instruction": "Generate a reflex of the plot grid species that describes the cabbage biomass grows following a logistic function with a growth rate equal to 0,2 and limited by the carry_capacity of the plot.",
        "output": "\treflex grow {\n\t\tif(carrying_capacity != 0){\n\t\t\tbiomass <- biomass * (1 + 0.2 * (1 - biomass\/carrying_capacity));\t\n\t\t}\n\t}\n"
    },
    {
        "instruction": "Write a model that creates a random directed graph (with 20 nodes and 20 edges), and save it in the dot format.",
        "output": "model SaveGraph\n\nglobal {\n\tinit {\n\t     graph the_graph <- generate_random_graph(20, 20, true,node_agent, edge_agent);\n\t\t\n\t     \/\/save the graph \t\t\n\t     save the_graph to:\"..\/results\/my_graph.dot\" format:\"dot\";\t\t\n\t}\n} \n  \n\/\/species that represent the nodes of the graph\nspecies node_agent {\n\taspect default {\n\t\tdraw circle(1.0) color:#red border: #black;\n\t}\n}\n\n\/\/species that represent the edges of the graph\nspecies edge_agent {\n\taspect default {\n\t\tdraw shape color:#black end_arrow: 1.0;\n\t}\n}\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies node_agent;\n\t\t\tspecies edge_agent;\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "write a code snippet that generate a message containing a map with data and send the message to a given agent in the network identified by its name.",
        "output": "\n\t\naction generateAndSendMessage(string dest)\n{\t\n   map<string,unknown> mess <- [\"int\"::10 , \"bool\"::true, \"list\"::[0,1,2]]; \n   do send to:dest contents:mess; \t\n}"
    },
    {
        "instruction": "create an experiment sim type GUI. Adding a display window named DEM type 3d, show the grid cell_dem as mesh where no data is -9999.",
        "output": "experiment sim type: gui {\n\toutput {\n\t\t\n\t\tdisplay \"DEM\" type: 3d \t\t\n\t\t\tmesh cell_dem no_data:-9999;\n\t\t}\n\n\t}\n}\n"
    },
    {
        "instruction": "Write a model that creates a random directed graph (with 30 nodes and 20 edges), and save it in the gml format.\n\n",
        "output": "model SavetoGraph\n\nglobal {\n\tinit {\n\t     graph the_graph <- generate_random_graph(30, 20, true,node_agent, edge_agent);\n\t\t\n\t     \/\/save the graph \t\t\n\t\tsave the_graph to:\"..\/results\/my_graph.gml\" format:\"gml\";\n\t}\n} \n  \n\/\/species that represent the nodes of the graph\nspecies node_agent {\n\taspect default {\n\t\tdraw circle(1.0) color:#red border: #black;\n\t}\n}\n\n\/\/species that represent the edges of the graph\nspecies edge_agent {\n\taspect default {\n\t\tdraw shape color:#black end_arrow: 1.0;\n\t}\n}\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies node_agent;\n\t\t\tspecies edge_agent;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Write a model that: defines the people species, \ncreate 2000  people agents randomly located in the environment, displays the agents\u2028with an aspect (named c) drawing the agent as a circle of radius 2, with an inner color red, and border color is black.",
        "output": "model my_model\n\nglobal {\n\tinit {\n\t\tcreate people number: 2000;\n\t}\n}\n\nspecies people{ \n     aspect c {\n         draw circle(1) color: #red border: #black;\n}\n\nexperiment Schelling1 type: gui {\n\toutput {\n\t\tdisplay people_display {\n\t\t\tspecies people aspect: c;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "generate a code snippet that defines an attribute called int of type integer with an initial value of 100 and that write its value in the console each time its value changes",
        "output": "int att <- 100 on_change: {write att;};"
    },
    {
        "instruction": "How to display the agents of 2 species named people and building, with aspects named respectively ci and sq?",
        "output": "experiment exp type: gui {\n\toutput {\n\t\tdisplay agents_display {\n\t\t\tspecies people aspect: ci;\n\t\t\tspecies building aspect: sq;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "create a grid of cells of size 10 by 10, each containing a random floating number that will be mapped to a color for the visualization",
        "output": "global {\n\nfield f <- field(10,10);\n\ninit {\nloop x from:0 to:10 { loop y from:0 to:10 { f[{x,y}] <- rnd(1.0); }}\n}\n\n}\n\nexperiment xp {\n\toutput {\n\t\tdisplay m {\n\t\t\tmesh f color:gradient([#pink,#magenta,#purple]);\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "write me a model with an experiment that will display a species differently depending on the value of a boolean variable called dark_mode. The species will be called dummy because I don't really care. When dark_mode is true the dummy agents will be represented by a dark red circle, when it's false by a normal red circle. Also change the display's background from white when dark_mode is false to black when it's true",
        "output": "\/**\n* Name: Conditional_aspect_selection\n* Author: Baptiste Lesquoy\n* Tags: \n*\/\n\n\nmodel Conditional_aspect_selection\n\nglobal {\n\t\n\tbool dark_mode <- false;\n\tfont my_font <- font(\"Helvetica\", 16, #bold);\n\tinit {\n\t\tcreate dummy number:10;\n\t}\n\t\n}\n\nspecies dummy {\n\t\n\taspect light {\n\t\tdraw circle(2) color:#red;\n\t}\n\taspect dark {\n\t\tdraw circle(2) color:#darkred;\n\t}\n}\n\n\nexperiment test {\n\tparameter \"Toggle dark mode\" var:dark_mode;\n\toutput{\n\t\tdisplay main background:dark_mode?#black:#white{\n\t\t\tspecies dummy {\n\t\t\t\tif dark_mode {\n\t\t\t\t\tdraw dark;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdraw light;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t\n\t\t\tgraphics \"Instructions\"{\n\t\t\t\tdraw \"Toggle the dark mode parameter and run a simulation step\" at:{5,5} color:dark_mode?#white:#black font:my_font;\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
    },
    {
        "instruction": "Define a species people with an attribute color (of type rgb). The attribute is randomly initialized to the value #red or #yellow (with a probability of 50% for each). The agents can be displayed using an aspect drawing agents as a circle of radius 1 and using the color as inner color of the circle.",
        "output": "species people {\n\t\n\trgb color;\n\t\n\tinit {\n\t\tif( flip(0.5) ) {\n\t\t\tcolor <- #red;\n\t\t} else {\n\t\t\tcolor <- #yellow;\n\t\t}\n\t}\n\t\n\taspect asp_circle {\n\t\tdraw circle(1.0) color: color ;\n\t}\n}"
    },
    {
        "instruction": "How to define a species people with a color attribute (of type rgb), initialized to a random color between #red and #yellow with equal probability.",
        "output": "species people {\n\trgb color;\n\t\n\tinit {\n\t\tcolor <- (flip(0.5) ? #red : #yellow);\n\t}\n}"
    },
    {
        "instruction": "How to define a species people with a color attribute (of type rgb), initialized to a random color between #red and #yellow with equal probability.",
        "output": "species people {\n\trgb color <- (flip(0.5) ? #red : #yellow);\n}"
    },
    {
        "instruction": "Define a species people that moves randomly in a continuous space a each simulation step.",
        "output": "species people {\n\n\treflex move {\n\t\tlocation <- any_location_in(world.shape);\n\t}\n\n}"
    },
    {
        "instruction": "Create an action, called proxima, that will return the distance between an agent and the closest other agent",
        "output": "global {\n\naction proxima (agent a) {\nreturn agent_closest_to(a) distance_to a;\n}\n\n}"
    },
    {
        "instruction": "Create a model to study the spread of influence or activity across a spatial environment and visualize it as a heatmap.",
        "output": "\/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*\/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t\/\/ The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t\/\/ Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Create a model demonstrating the use of overlay layers in graphical displays.",
        "output": "\/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*\/\n\nmodel Overlay\n\nglobal\n{\n\t\/\/define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n\/\/define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t\/\/each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t\/\/define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t\/\/for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            \/\/then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n"
    },
    {
        "instruction": "Show how to implement overlay layers to highlight different types of elements on a map.",
        "output": "\/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*\/\n\nmodel Overlay\n\nglobal\n{\n\t\/\/define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n\/\/define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t\/\/each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t\/\/define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t\/\/for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            \/\/then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n"
    },
    {
        "instruction": "Create a global block defining 3 global variables: rate_similar_wanted (initial value : 0.4), neighbours_distance (initial value : 5.0), nb_people (initial value : 100). It creates nb_people agents of the species people.",
        "output": "global {\n\tfloat rate_similar_wanted <- 0.4;\n\tfloat neighbours_distance <- 5.0;\n\tint nb_people <- 100;\n\tinit {\n\t\tcreate people number: nb_people;\n\t}\n}"
    },
    {
        "instruction": "Develop a visualization technique to represent various geographical features with distinct colors and labels using overlay layers.",
        "output": "\/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*\/\n\nmodel Overlay\n\nglobal\n{\n\t\/\/define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n\/\/define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t\/\/each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t\/\/define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t\/\/for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            \/\/then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n"
    },
    {
        "instruction": "Demonstrate the integration of overlay layers with a grid-based display to enhance visualization of spatial data.",
        "output": "\/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*\/\n\nmodel Overlay\n\nglobal\n{\n\t\/\/define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n\/\/define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t\/\/each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t\/\/define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t\/\/for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            \/\/then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n"
    },
    {
        "instruction": "Create a display to show my two lists of values coslist and sinlist in a series chart. I want the x axis to be labelled \"#points to draw at each step\", coslist should be labelled \"Cosinus\" and be displayed as a blue line and sinlist should be labelled \"Sinus\" and displayed as a red line. The display will be called \"long_series\"",
        "output": "\t\tdisplay \"long_series\" type: 2d {\n\t\t\tchart \"Long series values\" type: series x_label: \"#points to draw at each step\" memorize: false {\n\t\t\t\tdata \"Cosinus\" value: coslist color: #blue marker: false style: line;\n\t\t\t\tdata \"Sinus\" value: sinlist color: #red marker: false style: line;\n\t\t\t}\n\n\t\t}"
    },
    {
        "instruction": "Illustrate the concept of overlay layers in a graphical interface, allowing for the display of additional information on top of existing elements.",
        "output": "\/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*\/\n\nmodel Overlay\n\nglobal\n{\n\t\/\/define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n\/\/define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t\/\/each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t\/\/define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t\/\/for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            \/\/then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n"
    },
    {
        "instruction": "Design a simulation showcasing the versatility of overlay layers for representing different categories of objects within a spatial environment",
        "output": "\/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*\/\n\nmodel Overlay\n\nglobal\n{\n\t\/\/define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n\/\/define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t\/\/each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t\/\/define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t\/\/for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            \/\/then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n"
    },
    {
        "instruction": "Implement an overlay layer system for a 3D map visualization, allowing for the dynamic highlighting of specific regions or features.",
        "output": "\/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*\/\n\nmodel Overlay\n\nglobal\n{\n\t\/\/define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n\/\/define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t\/\/each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t\/\/define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t\/\/for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            \/\/then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n"
    },
    {
        "instruction": "Give me a sample complete model which shows how to create agents by importing data from a CSV file. The csv file for example is the sample iris data that comes with GAMA. The model reads the CSV file, creates an agent for each line of the CSV, and finally links its attributes to columns of the CSV File.",
        "output": "model CSVfileloading\n\nglobal {\n\t\n\tinit {\n\t\t\/\/create iris agents from the CSV file (use of the header of the CSV file), the attributes of the agents are initialized from the CSV files: \n\t\t\/\/we set the header facet to true to directly read the values corresponding to the right column. If the header was set to false, we could use the index of the columns to initialize the agent attributes\n\t\tcreate iris from:csv_file( \"..\/includes\/iris.csv\",true) with:\n\t\t\t[sepal_length::float(get(\"sepallength\")), \n\t\t\t\tsepal_width::float(get(\"sepalwidth\")), \n\t\t\t\tpetal_length::float(get(\"petallength\")),\n\t\t\t\tpetal_width::float(get(\"petalwidth\")), \n\t\t\t\ttype::string(get(\"type\"))\n\t\t\t];\t\n\t}\n}\n\nspecies iris {\n\tfloat sepal_length;\n\tfloat sepal_width;\n\tfloat petal_length;\n\tfloat petal_width;\n\tstring type;\n\trgb color ;\n\t\n\tinit {\n\t\tcolor <- type =\"Iris-setosa\" ? #blue : ((type =\"Iris-virginica\") ? #red: #yellow);\n\t}\n\t\n\taspect default {\n\t\tdraw circle(petal_width) color: color; \n\t}\n}\n\nexperiment main type: gui{\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies iris;\n\t\t}\n\t}\n\t\n}"
    },
    {
        "instruction": "Develop a tutorial on building and displaying heatmaps",
        "output": "\/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*\/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t\/\/ The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t\/\/ Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "fill my list coslist with the values of cos(x) with x varying from 0 to 1000",
        "output": "loop x from: 0 to: 1000 {\n\tadd cos(x) to: coslist;\n}"
    },
    {
        "instruction": "Explore the utilization of overlay layers in a graphical user interface to provide contextually relevant information alongside spatial data.",
        "output": "\/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*\/\n\nmodel Overlay\n\nglobal\n{\n\t\/\/define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n\/\/define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t\/\/each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t\/\/define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t\/\/for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            \/\/then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n"
    },
    {
        "instruction": "Wrote a model that will write \"you lose\" in the consol until a coin flip is won",
        "output": "global {\n\ninit {\n\nloop while:flip(0.5) { write \"YOU LOSE!\"; }\n\n}\n\n}"
    },
    {
        "instruction": "Create a graphical model that utilizes overlay layers to annotate a grid-based map with textual labels and colored markers for various geographic elements",
        "output": "\/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*\/\n\nmodel Overlay\n\nglobal\n{\n\t\/\/define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n\/\/define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t\/\/each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t\/\/define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t\/\/for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            \/\/then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n"
    },
    {
        "instruction": "Develop a tutorial on incorporating overlay layers into 3D visualizations to display multiple layers of information in a coherent manner.",
        "output": "\/**\n* Name: Overlay\n* Author: Alexis Drogoul and Patrick Taillandier\n* Description: Model to show how to use overlay layers in a display\n* Tags: overlay, display, graphic\n*\/\n\nmodel Overlay\n\nglobal\n{\n\t\/\/define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n\/\/define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t\/\/each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t\/\/define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t\/\/for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            \/\/then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n"
    },
    {
        "instruction": "Define a people species, with an attribute named neighbours (containing the list of people agents in the neighborhood). Its value is computed at each step with the people agents that are at a distance lower or equal to neighbours_distance global parameter.\n",
        "output": "species people {\t\n\n\tlist<people> neighbours update: people at_distance neighbours_distance;\n\n}"
    },
    {
        "instruction": "Define a people species, with an attribute named neighbours (containing the list of people agents in the neighborhood). Its value is computed at each step with the people agents that are at a distance lower or equal to neighbours_distance global parameter.\n",
        "output": "species people {\t\n\n\tlist<people> neighbours ;\n\n     reflex update {\n        neighbours <- people at_distance neighbours_distance;\n\n}"
    },
    {
        "instruction": "Demonstrate how to use agent behaviors to dynamically update a heatmap representation of activity levels within a simulated space",
        "output": "\/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*\/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t\/\/ The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t\/\/ Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "I have data stored in the variable gauss_distrib. Create an experiment to display it in a bar chart",
        "output": "experiment \"Example of Distribution\" type: gui {\n\toutput {\n\t\tdisplay \"Gauss Distribution\"  type: 2d {\n\t\t\tchart \"Gauss Distribution\" type: histogram {\n\t\t\t\tdatalist (gauss_distrib at \"legend\") value: (gauss_distrib at \"values\");\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Explore the creation of heatmaps using agent behavior data and visualize them using various color palettes and rendering techniques.",
        "output": "\/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*\/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t\/\/ The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t\/\/ Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Demonstrate the use of agent-based modeling to generate data for a heatmap and visualize it in different ways",
        "output": "\/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*\/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t\/\/ The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t\/\/ Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "model simulates a predator-prey relationship in a marine environment in which fish and hunters are created in the initialization (init) block of the global scope. Each agent is located at a random point within a square of side length 100. The reflex move block defines the behavior of the agents, which is to wander randomly. The hunters have an additional reflex eat block, which causes any fish within a distance of 1 to die. The fish have an additional reflex eaten block, which causes them to die if a hunter is within a distance of 1. The experiment block sets up a graphical user interface (GUI) for running the model and visualizing the agents.",
        "output": "model FishHunterModel\n\nglobal {\n  int nb_fish <- 100;\n  int nb_hunters <- 10;\n  geometry shape <- square(100);\n  init {\n    create fish number: nb_fish {\n      location <- one_of(shape);\n    }\n    create hunters number: nb_hunters {\n      location <- one_of(shape);\n    }\n  }\n}\n\nspecies fish {\n  aspect base {\n    draw circle(1) color: #blue;\n  }\n  reflex move {\n    do wander amplitude: 10 speed: 1;\n  }\n  reflex eaten {\n    ask hunters at_distance 1 {\n      do die;\n    }\n  }\n}\n\nspecies hunters {\n  aspect base {\n    draw circle(1) color: #red;\n  }\n  reflex move {\n    do wander amplitude: 10 speed: 1;\n  }\n  reflex eat {\n    ask fish at_distance 1 {\n      do die;\n    }\n  }\n}\n\nexperiment my_experiment type: gui {\n  output {\n    display \"my_display\" {\n      species fish aspect: base;\n      species hunters aspect: base;\n    }\n  }\n}\n"
    },
    {
        "instruction": "Create a simulation illustrating how heatmaps can be generated and displayed to represent the concentration of activity or events within a specified area.",
        "output": "\/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*\/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t\/\/ The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t\/\/ Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Define a people species, with 3 attributes: neighbours, that is the list of people agents at a distance lower than the neighbours_distance global variable, color (of type rgb), and is_happy, a boolean attribute initially set to false. \nDefine a reflex named computing_similarity with the following behavior. If neighbours is empty, set the rate_similar to 1.0. Otherwise, compute the number of neighbours, then the number of neighbours with the same colour as the agent, then set the rate_similar to the number of similar neighbours divided by the number of neighbours\nCompute the happiness state of the agent: is_happy is true if rate_similar is greater than the global variable rate_similar_wanted, and false otherwise.",
        "output": "species people {\n\t\/\/ other attributes\n\tlist<people> neighbours update: people at_distance neighbours_distance;\n\tbool is_happy <- false;\n        rgb color;\n\n\treflex computing_similarity {\n\t\tfloat rate_similar <- 0.0;\n\t\tif (empty(neighbours)) {\n\t\t\trate_similar <- 1.0;\n\t\t} else {\n\t\t\tint nb_neighbours <- length(neighbours);\n\t\t\tint nb_neighbours_sim <- neighbours count (each.color = color);\n\t\t\trate_similar <- nb_neighbours_sim \/nb_neighbours ;\n\t\t}\n\t\tis_happy <- rate_similar >= rate_similar_wanted;\n\t}\n\t\/\/other reflex and aspect definition\n}"
    },
    {
        "instruction": "Develop a model showcasing the generation and visualization of heatmaps based on the movement of agents within a simulated environment.",
        "output": "\/**\n* Name: Heatmap\n* A model that demonstrates how to build a simple heatmap based on fields and how to display it. \n* Author: drogoul\n* Tags: \n*\/\n\n\nmodel WormHeatmap\n\nglobal {\n\n\tint size <- 1000;\n\tfield heatmap <- field(500,500);\n\t\n\tinit {\n\t\tcreate worm number: size;\n\t}\n}\n\nspecies worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}\n\t\n\n\nexperiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t\/\/ The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t\/\/ Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Can you create a line in 3D between point {x1,y1,z1} and {x2,y2,z2}?",
        "output": "geometry line3D <- line([{x1,y1,z1}, {x2,y2,z2}]);"
    },
    {
        "instruction": "Can you create a square of size 10 at location 10,20 ?",
        "output": "geometry polygon2D <- square(10) at_location {10,20};"
    },
    {
        "instruction": "here is my model for the ants algorithm, create an experiment that will display all kind of data in charts of that model.\n\nmodel ants\n\nglobal {\n\t\/\/Number of ants\n\tint ants_number <- 100 min: 1 max: 2000 ;\n\t\/\/Evaporation value per cycle for the pheromons\n\tfloat evaporation_per_cycle <- 5.0 min: 0.0 max: 240.0 ;\n\t\/\/Diffusion rate for the pheromons\n\tfloat diffusion_rate <- 1.0 min: 0.0 max: 1.0 ;\n\t\/\/Size of the grid\n\tint gridsize <- 75 ;\n\t\/\/Center of the grid to put the location of the nest\n\tpoint center const: true <- { (gridsize \/ 2),  (gridsize \/ 2)} ;\n\tfile types const: true <- (pgm_file('..\/images\/environment75x75.pgm')) ;\n\tint food_gathered <- 0 ;   \n\tgeometry shape <- square(gridsize);\n\tinit{  \n\t\t\/\/Ant are placed randomly in the nest\n\t\tcreate ant number: ants_number with: [location::any_location_in (ant_grid(center))] ;\n\t}\n\t\n\t\/\/Reflex to diffuse the road of pheromon on the grid\n\treflex diffuse {\n      diffuse var:road on:ant_grid proportion: diffusion_rate radius:2 propagation: gradient;\n   }\n\n\n\n}\n\n\/\/Grid to discretize space for the food and the nest\ngrid ant_grid width: gridsize height: gridsize neighbors: 8 use_regular_agents: false {\n\tbool multiagent <- true ;\n\tfloat road <- 0.0 max:240.0 update: (road<=evaporation_per_cycle) ? 0.0 : road-evaporation_per_cycle;\n\tint type <- int(types at {grid_x,grid_y}) ;\n\tbool isNestLocation <- (self distance_to center) < 4 ; \n\tbool isFoodLocation <- type = 2 ; \n\trgb color <- isNestLocation ? #violet:((food > 0)? #blue : ((road < 0.001)? rgb ([100,100,100]) : ((road > 2)? #white : ((road > 0.5)? (#grey) : ((road > 0.2)? (#lightgrey) : (#darkgray)))))) update: isNestLocation ? #violet:((food > 0)? #blue : ((road < 0.001)? rgb ([100,100,100]) : ((road > 2)? #white : ((road > 0.5)? (#grey) : ((road > 0.2)? (#lightgray) : (#darkgray)))))) ;\n\tint food <- isFoodLocation ? 5 : 0 ;\n\tint nest const: true <- 300 - int(self distance_to center) ;\n\t\n}\n\/\/Species ant that will move and follow a final state machine\nspecies ant skills: [moving] control: fsm {\n\tfloat speed <- 2.0 ;\n\tant_grid place update: ant_grid (location ); \n\tbool hasFood <- false ;\n\n\n\n\treflex diffuse_road when:hasFood=true{\n      ant_grid(location).road <- ant_grid(location).road + 100.0;\n   }\n   \/\/Action to pick food\n\taction pick {\n\t\thasFood <- true ;\n\t\tplace.food <- place.food - 1 ;\n\t}\n\t\/\/Action to drop food\n\taction drop {\n\t\tfood_gathered <- food_gathered + 1 ;\n\t\thasFood <- false ;\n\t\theading <- heading - 180 ;\n\t}\n\t\/\/Action to chose the best place according to the possible food in the neighbour cells\n\taction choose_best_place type: ant_grid {\n\t\tlist<ant_grid> list_places <- place.neighbors ;\n\t\tif (list_places count (each.food > 0)) > 0  {\n\t\t\treturn (list_places first_with (each.food > 0)) ;\n\t\t} else {\n\t\t\t\tint min_nest  <-  (list_places min_of (each.nest)) ;\n\t\t\t\tlist_places <- list_places sort ((each.nest = min_nest) ? each.road :  0.0) ;\n\t\t\t\treturn last(list_places) ;\n\t\t\t}\n\t}\n\t\n\t\/\/Initial state of the ant : wander until it finds food or find a road to follow\n\tstate wandering initial: true {\n\t\tdo wander amplitude:120.0 ;\n\t\ttransition to: carryingFood when: place.food > 0 {\n\t\t\tdo pick ;\n\t\t}\n\t\ttransition to: followingRoad when: place.road > 0.05 ;\n\t}\n\t\/\/State to carry food to the nest once the food is found\n\tstate carryingFood {\n\t\tdo goto target: center ;\n\t\ttransition to: wandering when: place.isNestLocation { \n\t\t\tdo drop ;\n\t\t}\n\t}\n\t\/\/State to follow a road \n\tstate followingRoad {\n\t\tlocation <- (choose_best_place()) as point ;\n\t\ttransition to: carryingFood when: place.food > 0 {\n\t\t\tdo pick ;\n\t\t}\n\t\ttransition to: wandering when: (place.road < 0.05) ;\n\t}\n\n\taspect default {\n\t\tdraw circle(1.0) wireframe: !hasFood color: #orange ; \n\t}\n}",
        "output": "\nexperiment \"Experiment\" type: gui {\n\t\/\/Parameters to play with  in the gui\n\tparameter 'Number of ants:' var: ants_number category: 'Model' ;\n\tparameter 'Evaporation of the signal (unit\/cycle):' var: evaporation_per_cycle category: 'Model' ;\n\tparameter 'Rate of diffusion of the signal (%\/cycle):' var: diffusion_rate category: 'Model' ;\n\n\tlist<list<int>> nbants<-[[0]];\n\tlist<string> statesnames<-[\"wandering\"];\n\tlist<string> categnames<-[\"empty\",\"carry\"];\n\tlist<list<int>> nbantsbydist<-[[0]];\n\tlist xytestvallist<-[[[1,1],[2,2],[3,3]],[[1,2],[2,1],[3,4]],[[1,3],[2,3],[0,1]],[[1,4],[2,5],[0,0]]];\n\tlist<list<int>> xyval<-[[1,1],[2,1],[3,2]];\n\n\t\/\/Reflex to update the charts, belonging to the experiment bloc as it will not be used by other experiment which don't have the charts\n\treflex update_charts\n\t{\n\t\tnbants<-list<list<int>>([]);\n\t\tstatesnames<-list<string>([]);\n\t\tcategnames<-[\"empty\",\"carry\"];\n\t\tnbantsbydist<-list<list<int>>([]);\n\t\tloop x over:(world.ant)\n\t\t{\n\t\t\tif !(statesnames contains (x.state))\n\t\t\t{\t\t\t\t\n\t\t\tadd [(ant count (each.state=x.state and !each.hasFood)),(ant count (each.state=x.state and each.hasFood))] to: nbants;\n\t\t\tadd (x.state) to:statesnames;\t\t\t\t\n\t\t\tlist<int> nl<-list<int>([]);\n\t\t\tloop d from:0 to:9\n\t\t\t\t{\n\t\t\tadd (ant count (each.state=x.state and (((each distance_to center)>gridsize\/20*d) and ((each distance_to center)<gridsize\/20*(d+1))))) to: nl;\n\t\t\t\t}\n\t\t\tadd nl to:nbantsbydist;\n\t\t\t}\n\t\t}\n\t\n\t}\n\t\/\/The different displays\n\toutput {\n\t    layout horizontal([vertical([0::6721,2::3279])::5000,vertical([1::5000,horizontal([3::5000,4::5000])::5000])::5000]) tabs:true toolbars:true;\n\t\t\n\t\tdisplay Ants type: 2d antialias:false{\n\t\t\tgrid ant_grid ;\n\t\t\tspecies ant  ;\n\t\t}\n\t\tdisplay ProportionCarryFood  type: 2d {\n\t\t\tchart \"Proportions carrying: Pie\"  size: {0.5,0.5} position: {0, 0} type:pie\n\t\t\t{\n\t\t\t\tdata \"empty_ants\" value:(ant count (!each.hasFood)) color:#red;\n\t\t\t\tdata \"carry_food_ants\" value:(ant count (each.hasFood)) color:#green;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tchart \"Proportions carrying: Radar\"  size: {0.5,0.5} position: {0.5, 0} type:radar\n\t\t\taxes:#white\n\n\t\t\t{\n\t\t\t\tdata \"empty\" value:(ant count (!each.hasFood)) \n\t\t\t\taccumulate_values:true\n\t\t\t\tcolor:#red;\t\t\t\t\n\t\t\t\tdata \"carry\" value:(ant count (each.hasFood)) \n\t\t\t\taccumulate_values:true\n\t\t\t\tcolor:#blue;\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tchart \"Proportion: serie\"   size: {1.0,0.5} position: {0, 0.5} type:series \n\t\t\tseries_label_position: legend\n\t\t\tstyle:stack\n\t\t\t{\n\t\t\t\tdatalist [\"empty\",\"carry\"] accumulate_values:true \n\t\t\t\tvalue:[(ant count (!each.hasFood)),(ant count (each.hasFood))] \n\t\t\t\tcolor:[#red,#green];\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tdisplay CentroidPosition  type: 2d {\n\t\t\tchart \"Positions and History of Centroide and size by Carry state\" type:scatter\n\t\t\t{\n\t\t\t\tdatalist [\"avg-carry\",\"avg-empty\"] value:[mean((ant where (each.hasFood)) collect each.location),\n\t\t\t\t\tmean((ant where (!each.hasFood)) collect each.location)\n\t\t\t\t]\n\t\t\t\tmarker_size: [(ant count (each.hasFood))\/20,(ant count (!each.hasFood))\/20]\n\t\t\t\t\t color:[#red,#green] \n\t\t\t\t\t fill:false\n\t\t\t\t\t line_visible:true;\t\t\t\t\n\t\t\t\tdata \"empty_ants\" value:((ant where (!each.hasFood)) collect each.location) color:#red \n\t\t\t\taccumulate_values:false\n\t\t\t\tline_visible:false;\n\t\t\t\tdata \"carry_food_ants\" value:((ant where (each.hasFood)) collect each.location) \n\t\t\t\taccumulate_values:false\n\t\t\t\tcolor:#green line_visible:false;\n\n\t\t\t}\n\t\t}\t\n\t\tdisplay Distribution2dPosition  type: 2d {\n\t\t\tchart \"Distribution of the X positions\"   size: {0.65,0.3} position: {0.05, 0} type:histogram\n\t\t\t\n\t\t\t{\n\t\t\t\tdatalist (distribution_of(ant collect each.location.x,10,0,100) at \"legend\") \n\t\t\t\t\tvalue:(distribution_of(ant collect each.location.x,10,0,100) at \"values\");\n\t\t\t}\n\t\t\tchart \"Distribution of the Y positions\"   size: {0.3,0.7} position: {0.7, 0.28} type:histogram\n\t\t\treverse_axes:true\n\t\t\t\n\t\t\t{\n\t\t\t\tdatalist reverse(distribution_of(ant collect each.location.x,10,0,100) at \"legend\") \n\t\t\t\t\tvalue:reverse(distribution_of(ant collect each.location.x,10,0,100) at \"values\");\n\t\t\t}\n\n\t\t\tchart \"Distribution2d of the XvsY positions- heatmap\"   size: {0.7,0.7} position: {0, 0.3} type:heatmap\n\t\t\tseries_label_position:none\n\t\t\t{\n\t\t\t\tdata  \"XYdistrib\"\n\t\t\t\t\tvalue:(distribution2d_of(ant collect each.location.x,ant collect each.location.y,10,0,100,10,0,100) at \"values\")\n\t\t\t\t\tcolor:[#red]; \n\t\t\t}\n\t\t}\n\t\t\n\t\tdisplay DistributionPosition  type: 2d {\n\t\t\tchart \"Distribution of the X positions\"   size: {0.92,0.3} position: {0, 0} type:histogram\n\t\t\t\n\t\t\t{\n\t\t\t\tdatalist (distribution_of(ant collect each.location.x,10,0,100) at \"legend\") \n\t\t\t\t\tvalue:(distribution_of(ant collect each.location.x,10,0,100) at \"values\");\n\t\t\t}\n\t\t\tchart \"Distribution of the X positions- heatmap\"   size: {1.0,0.7} position: {0, 0.3} type:heatmap\n\t\t\tx_serie_labels: (distribution_of(ant collect each.location.x,10,0,100) at \"legend\")\n\t\t\ty_range:50\n\t\t\t{\n\t\t\t\tdata  \"Xdistrib\"\n\t\t\t\t\tvalue:(distribution_of(ant collect each.location.x,10,0,100) at \"values\")\n\t\t\t\t\tcolor:[#red];\n\t\t\t}\n\t\t}\t\n\t\t}\n\t}\t\n\n\n"
    },
    {
        "instruction": "basic structure of model simulates a fishery boat that moves in a marine environment and catches fish",
        "output": "model Fishery\n\nglobal {\n  \/\/ Define global attributes here\n}\n\nspecies fish {\n  \/\/ Define fish attributes and behaviors here\n}\n\nspecies boat {\n  \/\/ Define boat attributes and behaviors here\n}\n\nexperiment FisheryExperiment type: gui {\n  \/\/ Define your experiment here\n}\n"
    },
    {
        "instruction": "create an experiment to show me all different kind of bar charts available in gama. The data displayed doesn't matter",
        "output": "\nexperiment \"Multiple displays\" type: gui {\n\toutput synchronized: true {\n\t\tlayout #split parameters: false navigator: false editors: false consoles: false toolbars: false tray: false tabs: true;\t\n\t\tdisplay \"nice_bar_chart\"  type: 2d {\n\t\t\tchart \"Nice Cumulative Bar Chart\" type:histogram \n\t\t\t \tbackground: #darkblue\n\t\t\t \tcolor: #lightgreen \n\t\t\t \taxes: #lightgreen\n\t\t\t \ttitle_font: font('Serif', 32.0, #italic)\n\t\t\t \ttick_font: font('Monospaced', 14, #bold) \n\t\t\t \tlabel_font: font('Arial', 18, #bold) \n\t\t\t \tlegend_font: font('SanSerif', 14, #bold) \n\t\t\t \ty_range:[-20,40]\n\t\t\t \ty_tick_unit:10\n\t\t\t \tx_label:'Nice Xlabel'\n\t\t\t \ty_label:'Nice Ylabel'\n\t\t\t {\n\t\t\t\tdata \"BCC\" value:10*cos(100*cycle)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tstyle:stack\n\t\t\t\t\tcolor:#yellow;\n\t\t\t\tdata \"ABC\" value:10*sin(100*cycle)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tstyle: stack\n\t\t\t\t\tcolor:#blue;\n\t\t\t\tdata \"BCD\" value:(cycle mod 10)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tstyle: stack  \n\t\t\t\t\tmarker_shape:marker_circle ;\n\t\t\t}\n\t\t} \n\t\tdisplay \"data_cumulative_bar_chart\" type:2d {\n\t\t\tchart \"data_cumulative_bar_chart\" type:histogram \n\t\t\tstyle:stack\n\t\t\tx_serie_labels:(\"cycle\"+cycle)\n\t\t\tx_range:5\n\t\t\t{\n\t\t\t\tdata \"BCC\" value:cos(100*cycle)*cycle*cycle\n\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\tcolor:#yellow;\n\t\t\t\tdata \"ABC\" value:cycle*cycle \n\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#blue;\n\t\t\t\tdata \"BCD\" value:cycle+1\n\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\tmarker_shape:marker_circle ;\n\t\t\t}\n\t\t} \n \t\t\n\t\tdisplay \"data_non_cumulative_bar_chart\" type: 2d {\n\t\t\tchart \"data_non_cumulative_bar_chart\" type:histogram \n\t\t\tx_serie_labels: [\"categ1\",\"categ2\"]\n\t\t\tstyle:\"3d\"\n\t\t\tseries_label_position: xaxis\n\t\t\t{\n\t\t\t\tdata \"BCC\" value:cos(100*cycle)*cycle*cycle\n\/\/\t\t\t\tstyle:stack\n\t\t\t\tcolor:#yellow;\n\t\t\t\tdata \"ABC\" value:cycle*cycle \n\/\/\t\t\t\tstyle: stack\n\t\t\t\t\tcolor:#blue;\n\t\t\t\tdata \"BCD\" value:[cycle+1,cycle]\n\/\/\t\t\t\tstyle: stack  \n\t\t\t\tmarker_shape:marker_circle ;\n\t\t\t}\n\t\t} \n \t\t\n\t\tdisplay \"datalist_bar_cchart\" type:2d {\n\t\t\tchart \"datalist_bar\" type:histogram \n\t\t\tseries_label_position: onchart\n\t\t\t{\n\t\t\t\tdatalist legend:[\"cycle\",\"cosinus normalized\",\"offsetted cosinus normalized\"] \n\t\t\t\t\tstyle: bar\n\t\t\t\t\tvalue:[cycle,(sin(100*cycle) +  1) * cycle\/2,(sin(100*(cycle+30)) + 1) * cycle\/2] \n\t\t\t\t\tcolor:[#green,#black,#purple];\n\t\t\t}\n\t\t}\n\n\t\tdisplay \"onvalue_cumulative_bar_chart\" type:2d {\n\t\t\tchart \"onvalue_cumulative_bar_chart\" type:histogram \n\t\t\tseries_label_position: yaxis\n\t\t\tx_label: \"my_time_label\"\n\t\t\t{\n\t\t\t\tdata \"unique data value\" \n\t\t\t\t\tvalue:cos(cycle*10) \n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor: #red;\n\t\t\t}\n\t\t}\n\t\tdisplay \"data_cumulative_style_chart\" type:2d {\n\t\t\tchart \"Style Cumulative chart\" type:histogram style:stack\n\t\t\t \t{ \n\t\t\t\tdata \"Step\" value:cos(100*cycle+40)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#blue;\n\t\t\t\tdata \"Bar\" value:cos(100*cycle+60)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#green;\n\t\t\t\tdata \"Line\" value:cos(100*cycle)\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#orange;\n\t\t\t\tdata \"Dot\" value:cos(100*cycle)*0.3\n\t\t\t\t\taccumulate_values: true\t\t\t\t\t\t\n\t\t\t\t\tcolor:#red;\n\t\t\t}\n\t\t} \n\n\n\t}\n}"
    },
    {
        "instruction": "GAML model for a fishery boat simulation\n\n",
        "output": "model Fishery\n\nglobal {\n  \/\/ Define global attributes here\n  float fish_population <- 1000;\n  float boat_population <- 10;\n}\n\nspecies fish {\n  \/\/ Define fish attributes and behaviors here\n  float speed <- rnd(10);\n  reflex move {\n    do wander speed: speed;\n  }\n}\n\nspecies boat {\n  \/\/ Define boat attributes and behaviors here\n  float speed <- 20;\n  reflex move {\n    do wander speed: speed;\n  }\n  reflex catchFish {\n    ask fish within(10) {\n      do die;\n    }\n  }\n}\n\nexperiment FisheryExperiment type: gui {\n  \/\/ Define your experiment here\n  output {\n    display \"Fishery\" type: opengl {\n      species fish color: rgb(0,255,0);\n      species boat color: rgb(255,0,0);\n    }\n  }\n}\n"
    },
    {
        "instruction": "write a code snippet that contains a reflex that create a message containing a map with strings as keys and a int type as value and sent it to a given agent identified by its name. The name of the map is : \"data\".\n\nwrite a reflex capable of reading the message generated from the previous reflex.",
        "output": "action sendMessageWithMap(string dest)\n{\n  do send to: dest contents:[\"data\"::map([\"data1\"::30,\"data2\"::10])];\n}\n\n\nreflex fetchMessage when:has_more_message()\n{\t\n  loop while:has_more_message()\n  {\n    message mess <- fetch_message();\n    map<string, unknown> data <- mess.contents[\"data\"];\n    loop index over: data \n    {\n\twrite(index);\t\t\n    }\n  }\n}"
    },
    {
        "instruction": "How to create a line starting from point x1,y1 to point  x2,y2 ?",
        "output": "geometry line <- line([{x1,y1}, {x2,y2}]);"
    },
    {
        "instruction": "I want an example of code where `field` is used to represent an environment based on a Digital Elevation Model (DEM).",
        "output": "grid_file dem_file <- file(\"..\/includes\/DEM_100m_PP.asc\");\n\nfield terrain <- field(dem_file) ;\n\nfield flow <- field(terrain.columns,terrain.rows);\n\ngeometry shape <- envelope(dem_file);"
    },
    {
        "instruction": "What if I want to create different layers of that field to store information, like in an image with bands. Can you show that with the fields you gave?",
        "output": "list<point> points <- flow points_in shape;\n\nmap<point, bool> done <- points as_map (each::false);\n\nmap<point, float> heights <- points as_map (each::height(each));\n\nlist<point> water <- points where (flow[each] > 0) sort_by (heights[each]);\n\nloop p over: points - water {\n\tdone[p] <- true;\n}\n"
    },
    {
        "instruction": "GAML model for a fishery boat simulation that Fish now have an age attribute and a reproduce behavior. They can reproduce after they reach a certain age, creating new fish agents.\nBoats now have a fuel attribute. They consume fuel as they move, and they stop moving when they run out of fuel",
        "output": "model Fishery\n\nglobal {\n  float fish_population <- 1000;\n  float boat_population <- 10;\n  float reproduction_rate <- 0.1; \/\/ Fish reproduction rate\n  float fuel_consumption_rate <- 0.05; \/\/ Boat fuel consumption rate\n}\n\nspecies fish {\n  float speed <- rnd(10);\n  int age <- 0;\n  reflex move {\n    do wander speed: speed;\n  }\n  reflex reproduce {\n    if (age > 1) { \/\/ Fish can reproduce after 1 year\n      create fish number: reproduction_rate;\n    }\n  }\n  reflex aging {\n    age <- age + 1;\n  }\n}\n\nspecies boat {\n  float speed <- 20;\n  float fuel <- 100; \/\/ Initial fuel\n  reflex move {\n    if (fuel > 0) {\n      do wander speed: speed;\n      fuel <- fuel - fuel_consumption_rate;\n    }\n  }\n  reflex catchFish {\n    ask fish at_distance 10 {\n      do die;\n    }\n  }\n}\n\nexperiment FisheryExperiment type: gui {\n  output {\n    display \"Fishery\" type: opengl {\n      species fish color: rgb(0,255,0);\n      species boat color: rgb(255,0,0);\n    }\n  }\n}\n"
    },
    {
        "instruction": "Now, I want to display that field during the simulation. Can you provide a code for that?",
        "output": "mesh flow scale: 10 triangulation: true color: palette(reverse(brewer_colors(\"Blues\"))) transparency: 0.5 no_data:0.0 ;"
    },
    {
        "instruction": "Create a GAML code snippet that displays a Java2D chart (named chart_1) representing the distribution of the species `laborers` by states. The states include 'vacant,' 'manage_nursery,' 'assigned_nursery,' 'assigned_harvester,' 'assigned_planter,' and 'independent.' The chart should depict the count of laborers in each state where the 'com_identity' attribute is nil.",
        "output": "display chart_1 type: java2D{\t\nchart \"Own laborer according to state\" type: series\n\t{\n\tlist<string> states <- [\"vacant\", \"manage_nursery\", \"assigned_nursery\", \"assigned_harvester\", \"assigned_planter\", \"independent\"];\n\tloop i over: states{\n\t\tdata i value: count(labour, each.state = i and each.com_identity=nil);\n\t}\n}\n}"
    },
    {
        "instruction": "Create an experiment that shows in the display the species iris which was created from a csv file (iris.csv).",
        "output": "experiment main type: gui{\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies iris;\n\t\t}\n\t}\n\t\n}"
    },
    {
        "instruction": "Write GAML code to create monitors that track the total count of 'Warned Independent Harvester' agents (assuming they are represented by the variable total_warned_CM) and the total number of trees in the simulation (assuming they are represented by the variable trees) during simulation. Label the monitors as 'Total Warned Independent Harvester' and 'Tree count' respectively.",
        "output": "monitor \"Total Warned Independent Harvester\" value: total_warned_CM;\nmonitor \"Tree count\" value: length(trees);"
    },
    {
        "instruction": "Generate a 2D pie chart titled 'People Objectif' using data from a list of people objects. Each object has an 'objective' field (string) indicating their objective ('working' or 'resting'). Calculate the number of people in each category and represent them as separate slices in the pie chart.",
        "output": "\nchart \"People Objectif\" type: pie\n{\n  data \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\n  data \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\n\n}\n"
    },
    {
        "instruction": "create an experiment to showcase the different uses of pie charts. The data doesn't matter",
        "output": "\nexperiment \"Different Pies\" type: gui\n{\n\toutput synchronized: true\n\t{\n\t\tlayout #split parameters: false navigator: false editors: false consoles: false ;\t\n\t\t\n\t\tdisplay \"data_pie_chart\" type: 2d\n\t\t{\n\t\t\tchart \"Nice Ring Pie Chart\" type: pie style: ring background: # darkblue color: # lightgreen label_text_color: #red label_background_color: #lightgray axes: #red  title_font: font( 'Serif', 32, #italic)\n\t\t\ttick_font: font('Monospaced' , 14, #bold) label_font: font('Arial', 32 #bold) x_label: 'Nice Xlabel' y_label:\n\t\t\t'Nice Ylabel'\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: 100 + cos(100 * cycle) * cycle * cycle color: # black;\n\t\t\t\tdata \"ABC\" value: cycle * cycle color: # blue;\n\t\t\t\tdata \"BCD\" value: cycle + 1;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_3Dpie_chart\" type: 2d\n\t\t{\n\t\t\tchart \"data_3Dpie_chart\" type: pie style: 3d\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: 2 * cycle color: # black;\n\t\t\t\tdata \"ABC\" value: cycle * cycle color: # blue;\n\t\t\t\tdata \"BCD\" value: cycle + 1;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"datalist_pie_chart\" type: 2d\n\t\t{\n\t\t\tchart \"datalist_pie_chart\" type: pie style: exploded  series_label_position: \"none\" \n\t\t\t{\n\t\t\t\tdatalist legend: [\"A\", \"B\", \"C\"] value: [[cycle, cycle + 1, 2], [cycle \/ 2, cycle * 2, 1], [cycle + 2, cycle - 2, cycle]] x_err_values: [3, 2, 10] y_err_values:\n\t\t\t\t[3, cycle, 2 * cycle]\n\t\t\t\t\/\/\t\t\t\t\tcategoriesnames:[\"C1\",\"C2\",\"C3\"]\n\t\t\t\tcolor: [# black, # blue, # red];\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"
    },
    {
        "instruction": "Generate GAML code to create a layout with a horizontal structure containing two vertical sections whereby, each vertical section should have two elements of equal size.",
        "output": "layout horizontal([vertical([0::5000,1::5000])::5000,vertical([2::5000,3::5000])::5000]);"
    },
    {
        "instruction": "How can i add a depth to my geometry ? ",
        "output": "geometry line3D <- line([{20,60}, {40,60}]);\n\ndraw line3D depth: 10 color: #red;\n\nexperiment depth type:gui{\noutput{\n  display view type:opengl{\n    graphics \"Lines\" {\n      draw line3D depth: 10 color: #red;\n    }\n  }\n }\n}"
    },
    {
        "instruction": "How can I add depth to a geometry in an aspect? ",
        "output": "aspect base {\n  draw shape depth: height;\n}"
    },
    {
        "instruction": "Give me a model that initialises a grid from a JSON FIle.",
        "output": "model json_loading   \n\nglobal {\n\tfile JsonFile <- json_file(\"..\/includes\/cityIO.json\");\n    map<string, unknown> c <- JsonFile.contents;\n\n\tinit { \n\t\tlist<map<string, int>> cells <- c[\"grid\"];\n        loop mm over: cells {                 \n            cityMatrix cell <- cityMatrix grid_at {mm[\"x\"],mm[\"y\"]};\n            cell.type <-int(mm[\"type\"]);\n        }\n\t}  \n} \n\ngrid cityMatrix width:16  height:16{\n\trgb color <- #black;\n\tint type;\n   \taspect base{\t\n    \t\tdraw shape color:rgb(type*30) border:#black ;\n    }\n}\n\nexperiment Display  type: gui {\n\toutput {\n\t\tdisplay cityMatrixView   type: 3d axes:false{\t\n\t\t\tspecies cityMatrix aspect:base;\t\t\t\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "How can i change the color of an agent in an aspect? ",
        "output": "aspect base {\n  draw shape color: color;\n}"
    },
    {
        "instruction": "How do I generate a random number between 0 and 255 in Gama? ",
        "output": "int my_number<-rnd(255);"
    },
    {
        "instruction": "How do I generate a random number between -100 and 100 in Gama? ",
        "output": "int my_number<-rnd(-100,100);"
    },
    {
        "instruction": "Load a json file (cityIO.json) that comes with gama. ",
        "output": "file JsonFile <- json_file(\"..\/includes\/cityIO.json\");"
    },
    {
        "instruction": "create a 2d display called example to show a 3d pie chart that will have 3 categories: A, B and C, respectively colored in grey, green and red. A category will have a value of 3, B of 10 and C of 100",
        "output": "display \"example\" type: 2d {\n\tchart \"data_3Dpie_chart\" type: pie style: 3d\n\t{\n\t\tdata \"A\" value: 3 color: #grey;\n\t\tdata \"B\" value: 10 color: #green;\n\t\tdata \"C\" value: 100 color:#red;\n\t}\n}\n"
    },
    {
        "instruction": "Create a simulation environment to experiment with different color schemes and styling options for radar charts",
        "output": "\nexperiment \"Different radars\" type: gui\n{\n\n\toutput synchronized: true\n\t{\n\t\tlayout #split;\n\t\tdisplay \"nice_radar_chart\"  type: 2d \n\t\t{\n\t\t\tchart \"Nice Cumulative Radar Chart\" type: radar background: # darkblue color: # lightgreen axes: # lightgreen title_font: font('Serif', 32.0 #italic)\n\t\t\t tick_font: font('Monospaced',14 #bold) label_font: font('Arial', 18 #bold) legend_font: font('SanSerif', 14 ,#bold)\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: 10 * cos(100 * cycle) accumulate_values: true color: # yellow;\n\t\t\t\tdata \"ABC\" value: 10 * sin(100 * cycle) accumulate_values: true color: # lightgreen;\n\t\t\t\tdata \"BCD\" value: (cycle mod 10) accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"bounded_cumulative_radar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"bounded_cumulative_bar_chart\" type: radar x_serie_labels: (\"cycle\" + cycle) x_range: 10\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: cos(100 * cycle) * cycle * cycle accumulate_values: true color: # yellow;\n\t\t\t\tdata \"ABC\" value: cycle * cycle accumulate_values: true color: # blue;\n\t\t\t\tdata \"BCD\" value: cycle + 1 accumulate_values: true marker_shape: marker_circle;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_non_cumulative_bar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"data_non_cumulative_bar_chart\" type: radar x_serie_labels: [\"axeCos\", \"axeSin\", \"axeCosSin\"] series_label_position: xaxis\n\t\t\t{\n\t\t\t\tdata \"Cycle\" value: [1 + cos(cycle), 1 + sin(1 * cycle), 1 + cos(1 * cycle) * sin(cycle)] color: # yellow;\n\t\t\t\tdata \"2Cycle\" value: [1 + cos(1 * cycle * 2), 1 + sin(1 * cycle * 2), 1 + cos(1 * cycle * 2) * sin(1 * cycle * 2)] color: # blue;\n\t\t\t\tdata \"5Cycle\" value: [1 + cos(1 * cycle * 5), 1 + sin(1 * cycle * 5), 1 + cos(1 * cycle * 5) * sin(1 * cycle * 5)] color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"datalist_radar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"datalist_bar\" type: radar series_label_position: onchart\n\t\t\t{\n\t\t\t\tdatalist legend: [\"A\", \"B\", \"C\"] accumulate_values: true value: [1 + sin(cycle), 1 + cos(100 * cycle), 1 + cos(100 * (cycle + 30))] color: [# green, # black, # purple];\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"onvalue_cumulative_bar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"onvalue_cumulative_bar_chart\" type: radar series_label_position: yaxis x_label: \"my_time_label\" y_range: 100\n\t\t\t{\n\t\t\t\tdata \"unique data value\" value: 0.1*cycle*cos(cycle * 10) accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_cumulative_style_chart\" type: 2d\n\t\t{\n\t\t\tchart \"Style Cumulative chart\" type: radar style: stack\n\t\t\t{\n\t\t\t\tdata \"Step\" value: cos(100 * cycle + 40) accumulate_values: true color: # blue;\n\t\t\t\tdata \"Bar\" value: cos(100 * cycle + 60) accumulate_values: true color: # green;\n\t\t\t\tdata \"Line\" value: cos(100 * cycle) accumulate_values: true color: # orange;\n\t\t\t\tdata \"Dot\" value: cos(100 * cycle) * 0.3 accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"
    },
    {
        "instruction": "Create a model using a cellular automata to represent the Game of Life, the most famous example of cellular automata. Each cell will see if the number of living neighbours meets the condition to emerge or to live.",
        "output": "model life\n\n\/\/Declare the world as a torus or not torus environment\nglobal torus: torus_environment {\n\t\/\/Size of the environment\n\tint environment_width <- 200 min: 10 max: 1000;\n\tint environment_height <- 200 min: 10 max: 1000;\n\tbool parallel <- true;\n\t\/\/Declare as torus or not\n\tbool torus_environment <- true;\n\t\/\/Density \n\tint density <- 25 min: 1 max: 99;\n\t\/\/Conditions to live\n\tlist<int> living_conditions <- [2, 3];\n\t\/\/Conditions to birth\n\tlist<int> birth_conditions <- [3];\n\t\/\/Color for living cells\n\trgb livingcolor <- #white;\n\t\/\/Color for dying cells\n\trgb dyingcolor <- #red;\n\t\/\/Color for emerging cells\n\trgb emergingcolor <- #orange;\n\t\/\/Color for dead cells\n\trgb deadcolor <- #black;\n\t\/\/Shape of the environment\n\tgeometry shape <- rectangle(environment_width, environment_height);\n\t\n\t\/\/Initialization of the model by writing the description of the model in the console\n\tinit {\n\t\tdo description;\n\t}\n\t\n\t\/\/Ask at each life_cell to evolve and update\n\treflex generation {\n\t\t\/\/ The computation is made in parallel\n\t\task life_cell parallel: parallel {\n\t\t\tdo evolve;\n\t\t}\n\t}\n\t\/\/Write the description of the model in the console\n\taction description {\n\t\twrite\n\t\t'Description. The Game of Life is a cellular automaton devised by the British mathematician John Horton Conway in 1970. It is the best-known example of a cellular automaton. The game is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input from humans. One interacts with the Game of Life by creating an initial configuration and observing how it evolves.  The universe of the Game of Life is an infinite two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, live or dead. Every cell interacts with its eight neighbors, which are the cells that are directly horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur: \\n\\t 1.Any live cell with fewer than two live neighbours dies, as if caused by underpopulation. \\n\\t 2.Any live cell with more than three live neighbours dies, as if by overcrowding. \\n\\t 3.Any live cell with two or three live neighbours lives on to the next generation. \\n\\t 4.Any dead cell with exactly three live neighbours becomes a live cell. The initial pattern constitutes the seed of the system. The first(generation) is created by applying the above rules simultaneously to every cell in the seed\ufffdbirths and deaths happen simultaneously, and the discrete moment at which this happens is sometimes called a tick (in other words, each generation is a pure function of the one before). The rules continue to be applied repeatedly to create further generations.';\n\t}\n\n}\n\n\/\/Grid species representing a cellular automata\ngrid life_cell width: environment_width height: environment_height neighbors: 8  use_individual_shapes: false use_regular_agents: false \nuse_neighbors_cache: false parallel: parallel{\n\t\/\/Boolean to know if it is the new state of the cell\n\tbool new_state;\n\t\/\/List of all the neighbours\n\tlist<life_cell> neighbours <- self neighbors_at 1;\n\t\/\/Boolean  to know if it is a living or dead cell\n\tbool alive <- (rnd(100)) < density;\n\t\n\trgb color <- alive ? livingcolor : deadcolor;\n\t\n\t\/\/Action to evolve the cell considering its neighbours\n\taction evolve {\n\t\t\/\/Count the number of living neighbours of the cells\n\t\tint living <- neighbours count each.alive;\n\t\tif alive {\n\t\t\t\/\/If the number of living respect the conditions, the cell is still alive\n\t\t\tnew_state <- living in living_conditions;\n\t\t\tcolor <- new_state ? livingcolor : dyingcolor;\n\t\t} else {\n\t\t\t\/\/If the number of living meets the conditions, the cell go to born\n\t\t\tnew_state <- living in birth_conditions;\n\t\t\tcolor <- new_state ? emergingcolor : deadcolor;\n\t\t}\n\n\t}\n\t\/\/Action to update the new state of the cell\n\treflex update {\n\t\talive <- new_state;\n\t}\n\n}\n\n\nexperiment \"Game of Life\" type: gui {\n\tparameter \"Run in parallel \" var: parallel category: 'Board';\n\tparameter 'Width:' var: environment_width category: 'Board';\n\tparameter 'Height:' var: environment_height category: 'Board';\n\tparameter 'Torus?:' var: torus_environment category: 'Board';\n\tparameter 'Initial density of live cells:' var: density category: 'Cells';\n\tparameter 'Numbers of live neighbours required to stay alive:' var: living_conditions category: 'Cells';\n\tparameter 'Numbers of live neighbours required to become alive:' var: birth_conditions category: 'Cells';\n\tparameter 'Color of live cells:' var: livingcolor category: 'Colors';\n\tparameter 'Color of dying cells:' var: dyingcolor category: 'Colors';\n\tparameter 'Color of emerging cells:' var: emergingcolor category: 'Colors';\n\tparameter 'Color of dead cells:' var: deadcolor category: 'Colors';\n\toutput {\n\t\tdisplay Life type: 3d axes:false antialias:false{\n\t\t\tgrid life_cell;\n\t\t}\n\n\t}\n\n}\n"
    },
    {
        "instruction": "I would like to create a model where I have building with a specific width, height and width that are randomly placed in my scene. I want the building shape to change randomly at each iteration ",
        "output": "model city\n\nglobal{\ninit { \n      create Building number:number_of_building{\n      \t     width <- (rnd(100)\/100)*(rnd(100)\/100)*(rnd(100)\/100)*50+10;\n\t\t\t depth <-\t(rnd(100)\/100)*(rnd(100)\/100)*(rnd(100)\/100*width)*10+10;\n\t\t\tshape <- box(width, width, depth) rotated_by rnd(360);\n\n\t\t}\n\t}  \n\n}\n\n\nspecies Building{\n\tfloat width;\n\tfloat height;\n\tfloat depth;\n\tint angle;\t\t\t\n\n\t\n\treflex shuffle{\n\t\t width <- (rnd(100)\/100)*(rnd(100)\/100)*(rnd(100)\/100)*50+10;\n\t\t depth <-\t(rnd(100)\/100)*(rnd(100)\/100)*(rnd(100)\/100*width)*10+10;\n\t\t shape <- box(width, width, depth) rotated_by rnd(360);\n\t}\n\t\n\taspect base {\n\t\tdraw shape color:#white;\n\t}\n\t\n}\n\nexperiment DisplayTextured  type: gui {\noutput {\n\t display City type:3d{\n\t\tspecies Building aspect:base;\t\t\t\t\t\t\t\n\t}\n  }\n}"
    },
    {
        "instruction": "Demonstrate the application of radar charts in displaying complex data patterns and trends in a user-friendly graphical format.",
        "output": "\nexperiment \"Different radars\" type: gui\n{\n\n\toutput synchronized: true\n\t{\n\t\tlayout #split;\n\t\tdisplay \"nice_radar_chart\"  type: 2d \n\t\t{\n\t\t\tchart \"Nice Cumulative Radar Chart\" type: radar background: # darkblue color: # lightgreen axes: # lightgreen title_font: font('Serif', 32.0 #italic)\n\t\t\t tick_font: font('Monospaced',14 #bold) label_font: font('Arial', 18 #bold) legend_font: font('SanSerif', 14 ,#bold)\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: 10 * cos(100 * cycle) accumulate_values: true color: # yellow;\n\t\t\t\tdata \"ABC\" value: 10 * sin(100 * cycle) accumulate_values: true color: # lightgreen;\n\t\t\t\tdata \"BCD\" value: (cycle mod 10) accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"bounded_cumulative_radar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"bounded_cumulative_bar_chart\" type: radar x_serie_labels: (\"cycle\" + cycle) x_range: 10\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: cos(100 * cycle) * cycle * cycle accumulate_values: true color: # yellow;\n\t\t\t\tdata \"ABC\" value: cycle * cycle accumulate_values: true color: # blue;\n\t\t\t\tdata \"BCD\" value: cycle + 1 accumulate_values: true marker_shape: marker_circle;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_non_cumulative_bar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"data_non_cumulative_bar_chart\" type: radar x_serie_labels: [\"axeCos\", \"axeSin\", \"axeCosSin\"] series_label_position: xaxis\n\t\t\t{\n\t\t\t\tdata \"Cycle\" value: [1 + cos(cycle), 1 + sin(1 * cycle), 1 + cos(1 * cycle) * sin(cycle)] color: # yellow;\n\t\t\t\tdata \"2Cycle\" value: [1 + cos(1 * cycle * 2), 1 + sin(1 * cycle * 2), 1 + cos(1 * cycle * 2) * sin(1 * cycle * 2)] color: # blue;\n\t\t\t\tdata \"5Cycle\" value: [1 + cos(1 * cycle * 5), 1 + sin(1 * cycle * 5), 1 + cos(1 * cycle * 5) * sin(1 * cycle * 5)] color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"datalist_radar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"datalist_bar\" type: radar series_label_position: onchart\n\t\t\t{\n\t\t\t\tdatalist legend: [\"A\", \"B\", \"C\"] accumulate_values: true value: [1 + sin(cycle), 1 + cos(100 * cycle), 1 + cos(100 * (cycle + 30))] color: [# green, # black, # purple];\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"onvalue_cumulative_bar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"onvalue_cumulative_bar_chart\" type: radar series_label_position: yaxis x_label: \"my_time_label\" y_range: 100\n\t\t\t{\n\t\t\t\tdata \"unique data value\" value: 0.1*cycle*cos(cycle * 10) accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_cumulative_style_chart\" type: 2d\n\t\t{\n\t\t\tchart \"Style Cumulative chart\" type: radar style: stack\n\t\t\t{\n\t\t\t\tdata \"Step\" value: cos(100 * cycle + 40) accumulate_values: true color: # blue;\n\t\t\t\tdata \"Bar\" value: cos(100 * cycle + 60) accumulate_values: true color: # green;\n\t\t\t\tdata \"Line\" value: cos(100 * cycle) accumulate_values: true color: # orange;\n\t\t\t\tdata \"Dot\" value: cos(100 * cycle) * 0.3 accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"
    },
    {
        "instruction": "Create a specie called empty_building which is inherited from the specie building. It will have the attribute building_type that will be initialized with \"empty_building\" and a color which is grey defined by rgb(100,100,100)",
        "output": "species empty_building parent: building{\n\tstring building_type <- \"empty_building\";\n\trgb color <- rgb(100,100,100);\n}"
    },
    {
        "instruction": "Generate the snippet of code that generate a chart that at each simulation step, display the value of y according to the value of x",
        "output": "chart \"x and y\" type: xy\n{\n  data legend: \"x\" value:[x,y] line_visible: false color: #green;\n}"
    },
    {
        "instruction": "Develop a tutorial demonstrating the implementation of radar charts in a graphical interface for data analysis and visualization",
        "output": "\nexperiment \"Different radars\" type: gui\n{\n\n\toutput synchronized: true\n\t{\n\t\tlayout #split;\n\t\tdisplay \"nice_radar_chart\"  type: 2d \n\t\t{\n\t\t\tchart \"Nice Cumulative Radar Chart\" type: radar background: # darkblue color: # lightgreen axes: # lightgreen title_font: font('Serif', 32.0 #italic)\n\t\t\t tick_font: font('Monospaced',14 #bold) label_font: font('Arial', 18 #bold) legend_font: font('SanSerif', 14 ,#bold)\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: 10 * cos(100 * cycle) accumulate_values: true color: # yellow;\n\t\t\t\tdata \"ABC\" value: 10 * sin(100 * cycle) accumulate_values: true color: # lightgreen;\n\t\t\t\tdata \"BCD\" value: (cycle mod 10) accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"bounded_cumulative_radar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"bounded_cumulative_bar_chart\" type: radar x_serie_labels: (\"cycle\" + cycle) x_range: 10\n\t\t\t{\n\t\t\t\tdata \"BCC\" value: cos(100 * cycle) * cycle * cycle accumulate_values: true color: # yellow;\n\t\t\t\tdata \"ABC\" value: cycle * cycle accumulate_values: true color: # blue;\n\t\t\t\tdata \"BCD\" value: cycle + 1 accumulate_values: true marker_shape: marker_circle;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_non_cumulative_bar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"data_non_cumulative_bar_chart\" type: radar x_serie_labels: [\"axeCos\", \"axeSin\", \"axeCosSin\"] series_label_position: xaxis\n\t\t\t{\n\t\t\t\tdata \"Cycle\" value: [1 + cos(cycle), 1 + sin(1 * cycle), 1 + cos(1 * cycle) * sin(cycle)] color: # yellow;\n\t\t\t\tdata \"2Cycle\" value: [1 + cos(1 * cycle * 2), 1 + sin(1 * cycle * 2), 1 + cos(1 * cycle * 2) * sin(1 * cycle * 2)] color: # blue;\n\t\t\t\tdata \"5Cycle\" value: [1 + cos(1 * cycle * 5), 1 + sin(1 * cycle * 5), 1 + cos(1 * cycle * 5) * sin(1 * cycle * 5)] color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"datalist_radar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"datalist_bar\" type: radar series_label_position: onchart\n\t\t\t{\n\t\t\t\tdatalist legend: [\"A\", \"B\", \"C\"] accumulate_values: true value: [1 + sin(cycle), 1 + cos(100 * cycle), 1 + cos(100 * (cycle + 30))] color: [# green, # black, # purple];\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"onvalue_cumulative_bar_chart\" type: 2d\n\t\t{\n\t\t\tchart \"onvalue_cumulative_bar_chart\" type: radar series_label_position: yaxis x_label: \"my_time_label\" y_range: 100\n\t\t\t{\n\t\t\t\tdata \"unique data value\" value: 0.1*cycle*cos(cycle * 10) accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t\tdisplay \"data_cumulative_style_chart\" type: 2d\n\t\t{\n\t\t\tchart \"Style Cumulative chart\" type: radar style: stack\n\t\t\t{\n\t\t\t\tdata \"Step\" value: cos(100 * cycle + 40) accumulate_values: true color: # blue;\n\t\t\t\tdata \"Bar\" value: cos(100 * cycle + 60) accumulate_values: true color: # green;\n\t\t\t\tdata \"Line\" value: cos(100 * cycle) accumulate_values: true color: # orange;\n\t\t\t\tdata \"Dot\" value: cos(100 * cycle) * 0.3 accumulate_values: true color: # red;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"
    },
    {
        "instruction": "Create a grid cityMatrix from a json file,  with a width of 16 and height of 16. The color of each grid will depend on its type, each cell's border color is black, and the background of the cell will be black.",
        "output": "grid cityMatrix width:16  height:16{\n\trgb color <- #black;\n\tint type;\n   \taspect base{\t\n    \t\tdraw shape color:rgb(type*30) border:#black ;\n    }\n}\n"
    },
    {
        "instruction": "Create a reflex that occurs every day and that will set the boolean variable is_party_day true with a probability of 0.2 and the boolean is_evening_shopping_day at true with the probability of 0.4.",
        "output": "reflex today_feeling when:every(1#day){\n    bool is_party_day <- flip(0.2);\n    bool is_evening_shopping_day <- flip(0.4);\n}"
    },
    {
        "instruction": "I have two lists of x and y values called serie_x and serie_y, create a chart to display them as (x,y) points",
        "output": "chart \"serie_x and serie_y\" type: xy size: {1.0,0.5}{\n\tdata legend: \"x\" value:rows_list(matrix([serie_x,serie_y])) ;\n}\n\t\t\t"
    },
    {
        "instruction": "How can I apply a texture to a shape? ",
        "output": "file gamaRaster <- file('..\/images\/Gama.jpg');\n\nspecies Geometry2D{  \n\n  geometry myGeometry;\n\t\n  aspect default {\n    draw myGeometry texture:gamaRaster.path;\n  }\n} "
    },
    {
        "instruction": "For drawin the specie, create an aspect called base that draws a circle of radius build_len\/15, the color is the color attribute of the specie, the border is black and placed at the location: location + offset",
        "output": "aspect base {\n\tdraw circle(build_len\/15) color: color border:#black at: location + offset;\n}"
    },
    {
        "instruction": "I have two variables, x and y that represent one data point and are updated every cycle. Create a chart that will display the evolution of that data point on an xy type of chart with green points and no lines. Call that series of values \"x\"",
        "output": "\/\/at each simulation step, display the value of y according to the value of x\nchart \"x and y\" type: xy size: {1.0,0.5} position: {0,0.5}{\n\tdata legend: \"x\" value:[x,y] line_visible: false color: #green;\n}"
    },
    {
        "instruction": "Generate a complete model that shows how to access and manipulate fields information. To demonstrate this, two agents are created. One agent increases the values in the field, another one decreases them.",
        "output": "model AccessingFields\n\nglobal torus: true{\n\tgeometry shape <- square(2000);\n\tfield terrain <- field(300, 300);\n\n\tinit {\n\t\tcreate increaser with: [location::location];\n\t\tcreate decreaser with: [location::location];\n\t}\n\n\tspecies increaser skills: [moving] {\n\t\tgeometry shape <- square(40);\n\n\t\treflex move {\n\t\t\tdo wander amplitude: 2.0;\n\t\t\tloop s over: terrain cells_in self {\n\t\t\t\tterrain[geometry(s).location] <- terrain[geometry(s).location] + 1.0;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tspecies decreaser skills: [moving] {\n\t\tgeometry shape <- square(40);\n\n\t\treflex move {\n\t\t\tdo wander amplitude: 2.0;\n\t\t\tloop s over: terrain cells_in self {\n\t\t\t\tterrain[geometry(s).location] <- terrain[geometry(s).location] - 1.0;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Show\" {\n\tlist<rgb> palette <- brewer_colors(any(brewer_palettes(0)));\n\toutput {\n\t\tdisplay Field type: 3d {\n\t\t\tmesh terrain color: palette triangulation: true smooth: 4;\n\t\t}\n\n\t}\n\n}\n"
    },
    {
        "instruction": "Create a field named terrain with dimensions 300 by 300.",
        "output": "field terrain <- field(300, 300);"
    },
    {
        "instruction": "Set the starting date of the simulation to December 17,1979 at time 19:45:10.",
        "output": "global {\n    date starting_date <- date([1979,12,17,19,45,10]);\n}"
    },
    {
        "instruction": "Create a model to showcase how to drag and drop an agent inside the simulation's world with the mouse.",
        "output": "\/**\n* Name: MouseDrag\n* \n* Demonstrates the usage of the mouse_drag events to move an agent using user\n* interactions. Drag events are triggered when the mouse is moving with the\n* mouse button down. Notice that move events are not triggered when the mouse\n* button is down.\n* \n* Author: breugnot\n* Tags: gui, event, mouse_move, mouse_drag, mouse_down, mouse_up\n*\/\n\nmodel mouse_event\n\nglobal {\n\tgeometry shape <- square(20);\n\tDraggedAgent selected_agent <- nil;\n\tinit {\n\t\tcreate DraggedAgent with: (location: {10, 10});\n\t}\n\t\n\t\/** Insert the global definitions, variables and actions here *\/\n\taction mouse_down {\n\t\task DraggedAgent {\n\t\t\tif( self covers #user_location) {\n\t\t\t\t\/\/ Selects the agent\n\t\t\t\tselected_agent <- self;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction mouse_up {\n\t\tif(selected_agent != nil) {\n\t\t\tselected_agent <- nil;\n\t\t}\n\t}\n\t\n\taction mouse_drag {\n\t\t\/\/ Makes the agent follow the mouse while the mouse button is down\n\t\tif(selected_agent != nil) {\n\t\t\task selected_agent {\n\t\t\t\tlocation <- #user_location;\n\t\t\t}\n\t\t}\n\t}\n}\n\nspecies DraggedAgent {\n\tinit {\n\t\tshape <- circle(1);\n\t}\n\taspect default {\n\t\tdraw shape at: location;\n\t}\n}\n\nexperiment \"Mouse Drag\" type: gui {\n\t\/** Insert here the definition of the input and output of the model *\/\n\toutput {\n\t\tdisplay \"Mouse Drag [OPENGL]\" type:opengl {\n\t\t\tcamera #from_above locked:true;\n\t\t\tevent #mouse_down {ask simulation {do mouse_down;}}\n\t\t\tevent #mouse_up {ask simulation {do mouse_up;}}\n\t\t\tevent #mouse_drag {ask simulation {do mouse_drag;}}\n\t\t\t\n\t\t\tgraphics \"world\" {\n\t\t\t\tdraw world color: #white border:#black;\n\t\t\t}\n\n\t\t\tspecies DraggedAgent aspect:default;\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Give me a model which shows how to use a confirm dialog box. ",
        "output": "model Confirmdialog_example\n\nglobal {\n\tinit {\n\t\tbool  result <- user_confirm(\"Confirmation dialog box\",\"Do you want to confirm?\");\n\t\twrite sample(result);\n\t}\n}\n\nexperiment Confirmdialog_example type: gui ;"
    },
    {
        "instruction": "show me how to have an agent that follow the user's mouse on the screen",
        "output": "\/**\n* Name: followmouse\n* Based on the internal empty template. \n* Author: baptiste\n* Tags: \n*\/\n\n\nmodel followmouse\n\nglobal {\n\tinit {\n\t\tcreate dummy;\n\t}\n}\nspecies dummy {\n\tgeometry shape <- square(10);\n\treflex follow_mouse{\n\t\tlocation <- #user_location;\n\t}\n}\n\nexperiment follow {\n\toutput{\n\t\tdisplay main{\n\t\t\tspecies dummy;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "create a simulation where an agent of a species called dummy updates its location every cycle to be the same as the location of the user's mouse on the display. The agent's shape is going to be a square with a size of 10",
        "output": "\/**\n* Name: followmouse\n* Based on the internal empty template. \n* Author: baptiste\n* Tags: \n*\/\n\n\nmodel followmouse\n\nglobal {\n\tinit {\n\t\tcreate dummy;\n\t}\n}\nspecies dummy {\n\tgeometry shape <- square(10);\n\treflex follow_mouse{\n\t\tlocation <- #user_location;\n\t}\n}\n\nexperiment follow {\n\toutput{\n\t\tdisplay main{\n\t\t\tspecies dummy;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Give me a code snippet that generate a chart that compute the percentage of agents being happy in the model at each step. The happiness is represented as a boolean value 'is_happy'. The variable number_of_people gives the total number of people in the model.",
        "output": "chart \"Global happiness and similarity\" type: series\n{\n    data \"happy\" value:  (people count (each.is_happy) \/ number_of_people) * 100;\n}"
    },
    {
        "instruction": "Can I call a specific action when I click on the mouse on my screen? ",
        "output": "\/\/ Define an action that will be called when the user click\n\naction mouse_down {\n  \/\/Define what you want to do in your action\n}\n\n\/\/ In the display define an event layer\ndisplay view{\n  \/\/event #mouse_down {ask simulation {do mouse_down;}}\n}"
    },
    {
        "instruction": "Give me a complete model that shows how to create agents, and save the agents's attributes (speed, size) inside a CSV File at a specific time step. The created agents can move and change size at each time step. ",
        "output": "model SavetoCSV\n\nglobal {\n\tinit { \n\t\t\/\/Create all the agents\n\t\tcreate bug number: 50;\n\t}\n\t\/\/Save the agents bug when the cycle is equals to 100\n\treflex save_bug_attribute when: cycle = 100{\n\t\task bug {\n\t\t\t\/\/ save the values of the variables name, speed and size to the csv file; the rewrite facet is set to false to continue to write in the same file\n\t\t\tsave [name,speed, size] to: \"..\/results\/bug.csv\" format:\"csv\" rewrite: false;\n\t\t\t\/\/ save all the attributes values of the bug agents in a file. The file is overwritten at every save\n\t\t\tsave bug to: \"..\/results\/bug_agents.csv\" format:\"csv\" rewrite: true;\n\t\t}\n\t\t\/\/Pause the model as the data are saved\n\t\tdo pause;\n\t}\n}\n\n\/\/Species that will be saved\nspecies bug skills:[moving]{\n\tfloat size <- 1.0 + rnd(4) min: 1.0 max: 5.0;\n\tfloat speed <- 1.0 + rnd(4.0);\n\t\n\treflex update_size {\n\t\tint nb_neigh <- length(bug at_distance 20.0);\n\t\tif (nb_neigh > 5) {\n\t\t\tsize <- size + 1;\n\t\t} else {\n\t\t\tsize <- size - 1;\n\t\t}\n\t} \t\n\treflex move {\n\t\tdo wander;\n\t}\n\t\n\taspect default {\n\t\tdraw circle(size) color: #red;\n\t}\n}\n\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies bug;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Can I define a specific behaviour when I drag my mouse?",
        "output": "\/\/ Define an action that will be called when the user drag the mouse\n\naction mouse_drag {\n  \/\/Define what you want to do in your action\n}\n\n\/\/ In the display define an event layer\ndisplay view{\n  event #mouse_drag {ask simulation {do mouse_drag;}}\n}"
    },
    {
        "instruction": "Generate the definition of a grid representing a sugar plant. Each cell contains an initial value of sugar given by the attribute 'initialSugarValue'. Each sugar cell can hold a maximum given amount of sugar designated by the variable 'maxSugar'. At each step, the amount of sugar of each cell is incremented by a given value called 'sugarGrowthRate'. The size of the grid is 50x50. each cells have 4 neighbors.",
        "output": "grid sugar_cell width: 50 height: 50 neighbors: 4 \n{ \n\t\/\/Maximum sugar\n\tint maxSugar;\n\t\/\/Sugar contained in the cell\n\tint sugar update: sugar + sugarGrowthRate max: maxSugar;\n}\t"
    },
    {
        "instruction": "How can I pause my simulation? ",
        "output": "do pause;"
    },
    {
        "instruction": "Generate a model that stops when all the people agent are happy. ",
        "output": "global {\n\tint nb_happy_people <- 0 update: people count each.is_happy ;\n\n\t\/\/ attributes and init of the global\n\treflex end_simulation when: nb_happy_people = length(people) {\n\t\tdo pause;\n\t}\n}\n\nspecies people {\n       bool is_happy;\n}"
    },
    {
        "instruction": "Generate a experiment that defines 3 parameters and a didplay of the people species (using the asp_circle aspect). These 3 parameters correspond to the 3 global variables: nb_people, rate_similar_wanted, and neighbours_distance.",
        "output": "experiment Schelling1 type: gui {\n\tparameter \"nb of people\" var: nb_people;\n\tparameter \"rate similar wanted\" var: rate_similar_wanted min: 0.0 max: 1.0;\n\tparameter \"neighbours distance\" var: neighbours_distance step: 1.0;\n\t\n\toutput {\n\t\tdisplay people_display {\n\t\t\tspecies people aspect: asp_circle;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Pause the simulation.",
        "output": "do pause;"
    },
    {
        "instruction": "Create an empty list.",
        "output": "list empty_list;"
    },
    {
        "instruction": "Generate a GAML code snippet with the following specifications:\n\n\n1. Define a new species named `vehicle` that includes the skill `driving`.\n2. Assign to the species a random RGB color value.\n3. Inside the species, include an `init` block that initializes the following properties:\n  - `vehicle_length` as `1.9` meters (use the `#m` annotation for meters).\n  - `max_speed` as `100` km\/h.\n  - `max_acceleration` as a floating-point number `3.5`.\n\n\n4. Add a reflex named `select_next_path` that is triggered when the condition `current_path` is `nil`.\n  - Within this reflex, add a comment to denote it should compute a cyclical path.\n  - Use the `compute_path` action within this reflex, specify the parameters `graph` with the value `road_network`, and `target` using the value `one_of(intersection)`.\n\n\n5. Create another reflex named `commute` which is triggered when `current_path` is not `nil`.\n  - The reflex should contain the action `drive`.\n\n\n6. Define an aspect named `base` for the visual representation of the species.\n  - The aspect should draw a triangle with a size of `5.0`.\n  - Specify the color of the triangle to be the previously defined random color.\n  - Indicate the triangle should be rotated by the `heading + 90` degrees.\n  - Outline the triangle with the color `#black`.\n\n\nEnsure the code includes the appropriate GAML syntax, proper formatting, and comments for clarity.\n",
        "output": "species vehicle skills: [driving] {\n   rgb color <- rnd_color(255);\n   init {\n       vehicle_length <- 1.9 #m;\n       max_speed <- 100 #km \/ #h;\n       max_acceleration <- 3.5;\n   }\n\n\n   reflex select_next_path when: current_path = nil {\n       \/\/ A path that forms a cycle\n       do compute_path graph: road_network target: one_of(intersection);\n   }\n  \n   reflex commute when: current_path != nil {\n       do drive;\n   }\n   aspect base {\n       draw triangle(5.0) color: color rotate: heading + 90 border: #black;\n   }\n}\n"
    },
    {
        "instruction": "Generate a GAML code snippet that defines a `species` with these characteristics:\n\n\n1. The species should be named `people` and contain the skill `pedestrian`.\n2. Incorporate a `schedules` facet that shuffles the order of `people`.\n3. Assign to the species a random RGB color value.\n4. Define a speed attribute as a `float` type with a value of 3 km\/h.\n5. Include a boolean attribute `avoid_other` and set its initial value to `true`, which makes the pedestrian to avoid other pedestrians.\n6. Declare a `point` type variable named `current_target`.\n\n\nAdd a `reflex` named `move` that is activated when `current_target` is not `nil` and has the following behavior:\n\n\n- Use an `if` statement to check if there is an obstacle (`nb_obstacles > 0`). If true:\n - Invoke the action `walk_to` with the `target` facet set to `current_target` and `bounds` facet set to `free_space`.\n- If there are no obstacles:\n - Call the action `walk_to` with `current_target` as the target without any bounds.\n- Add another condition within the reflex to check if the distance to the `current_target` is less than `0.5`. If the condition is met:\n - The individual should perform the `die` action.\n\n\nDefine an `aspect` named `default` for visual representation that should:\n\n\n- Draw a `triangle` with a size determined by the variable `shoulder_length`.\n- Set the `color` of the triangle to the previously defined random color variable.\n- Include a rotation based on the `heading + 90.0` degrees.\n\n\nEnsure that proper GAML syntax is used and include comments for better clarity where applicable.\n",
        "output": "species people skills: [pedestrian] schedules: shuffle(people) {\n   rgb color <- rnd_color(255);\n   float speed <- 3 #km\/#h;\n   bool avoid_other <- true;\n   point current_target ;\n   reflex move when: current_target != nil{\n       if (nb_obstacles > 0) {\n           do walk_to target: current_target bounds: free_space;\n       } else {\n           do walk_to target: current_target;\n       }\n       if (self distance_to current_target < 0.5) {\n           do die;\n       }\n   }\n   aspect default {\n       draw triangle(shoulder_length) color: color rotate: heading + 90.0;\n   }\n}\n"
    },
    {
        "instruction": "Write a GAML code snippet that accomplishes the following tasks:\n\n\n1. **Module Name**\n  - Set the model name to `json_loading`.\n\n\n2. **Global Variable Definitions**\n  - Introduce a `global` species with a variable `JsonFile` that holds the JSON file loaded from a relative path \"..\/includes\/cityIO.json\".\n\n\n3. **Initialization Procedure**\n  - In the `init` block within the `global` species scope, parse the `grid` data from the JSON file contents and iterate over each cell.\n  - For each cell in the grid, instantiate a `cityMatrix` grid element at the coordinates specified by `x` and `y` values in the current cell.\n  - Assign the `type` of each `cityMatrix` cell according to the `type` value specified in the cell data.\n\n\n4. **Grid Definition**\n  - Define a two-dimensional grid named `cityMatrix` with a width and height of 16.\n  - Give each cell in the grid an `rgb` color attribute initialized to black and an integer `type`.\n  - Under the `aspect base`, set the cells to draw shapes colored based on their `type` times a multiplier (e.g., 30), with a black border.\n\n\n5. **Experiment Setup**\n  - Design an experiment named `Display` with the type set to `gui`.\n  - Configure the output to display a `cityMatrixView` in 3D without axes.\n  - Within the display, set the species to `cityMatrix` and the aspect to `base`.\n\n\nEnsure that the code is well-formatted and adheres to GAML conventions for clarity and maintainability.\n",
        "output": "model json_loading  \n\n\nglobal {\n   file JsonFile <- json_file(\"..\/includes\/cityIO.json\");\n   map<string, unknown> c <- JsonFile.contents;\n\n\n   init {\n       list<map<string, int>> cells <- c[\"grid\"];\n       loop mm over: cells {                \n           cityMatrix cell <- cityMatrix grid_at {mm[\"x\"],mm[\"y\"]};\n           cell.type <-int(mm[\"type\"]);\n       }\n   } \n}\n\n\ngrid cityMatrix width:16  height:16{\n   rgb color <- #black;\n   int type;\n   aspect base{   \n           draw shape color:rgb(type*30) border:#black ;\n   }\n}\n\n\nexperiment Display  type: gui {\n   output {\n       display cityMatrixView   type: 3d axes:false{  \n           species cityMatrix aspect:base;        \n       }\n   }\n}\n"
    },
    {
        "instruction": "Create a GAML script that defines a 16x16 grid named `cityMatrix`. Each cell in the grid should be characterized by two properties: `color` and `type`. Follow these specifications:\n\n\n1. Initialize a color property using RGB, with a default value corresponding to black.\n\n\n2. Create an integer type variable called `type` but leave it uninitialized.\n\n\n3. Define an `aspect` named `base` for the visualization of the cells. Within this aspect:\n\n\n  a. Implement a drawing function for the cells.\n \n  b. The color of each shape should vary depending on the `type` property. Use the `type` value multiplied by 30 to set the RGB color component.\n \n  c. Outline each shape with a black border.\n",
        "output": "grid cityMatrix width:16  height:16{\n   rgb color <- #black;\n   int type;\n   aspect base{   \n           draw shape color:rgb(type*30) border:#black ;\n   }\n}\n"
    },
    {
        "instruction": "Create a GAML (GAma Modeling Language) code snippet that defines a species with the following characteristics and behaviors:\n\n\n- Name the species `cell`.\n- Equip the species with the skill `moving3D` to enable three-dimensional movement.\n- Define an `rgb color` attribute to store the color of the cell.\n- Include a `list<cell>` type attribute named `neighbors` to hold nearby cells.\n- Add an `int` type attribute named `offset`.\n- Incorporate a `reflex` named `move` that allows the cell to perform a wandering action using the `do wander;` command.\n- Include a `reflex` named `compute_neighbors` where each cell evaluates its surroundings and updates its `neighbors` list with cells that are within a distance of less than 10 units to itself.\n- Define an `aspect` named `default` that:\n - Draws the cell as a small sphere (`environment_size * 0.01`) colored orange.\n - Iterates over the `neighbors` list and for each neighbor, draws a line between the cell\u2019s location and each neighbor's location.\n\n\nEnsure that the `aspect` visually represents the cells and their connections within the environment accurately.",
        "output": "species cell skills: [moving3D] {\n   rgb color;\n   list<cell> neighbors;\n   int offset;\n\n\n   reflex move {\n       do wander;\n   }\n\n\n   reflex compute_neighbors {\n       neighbors <- cell select ((each distance_to self) < 10);\n   }\n\n\n   aspect default {\n       draw sphere(environment_size * 0.01) color: #orange;\n       loop pp over: neighbors {\n           draw line([self.location, pp.location]);\n       }\n   }\n}\n"
    },
    {
        "instruction": "Write a GAML code snippet that accomplishes the following tasks:\n\n\n**Model Structure Overview:**\n- Design a model titled `quick_user_command_model`.\n- The model should initialize with a specific number of agents belonging to a species named `my_species`.\n\n\n**Global Initialization Requirements:**\n- In the global `init` block, ensure the model creates a predefined number of `my_species` agents.\n\n\n**Species Definition and Behavior:**\n- Define a species `my_species` with the following characteristics:\n - The species should respond to a user command, preferably one related to an experiment's runtime action (e.g., `die` when a certain command is issued).\n - Characterize `my_species` with a basic aspect that visualizes each agent with a simple geometric shape and color.\n\n\n**Aspect Visualization Details:**\n- The aspect labeled `base` should include:\n - The ability to draw a shape, such as a circle, with a specified size.\n - An attribute to set the color of the shape to a user-defined hexadecimal color code.\n\n\n**Experiment Configuration:**\n- Set up an experiment with the identifier `expe` of type `gui`.\n- This experiment should feature output configurations that include:\n - A display component labeled `my_display`.\n - The display should visualize the `my_species` agents using the `base` aspect defined earlier in the species block.\n\n\n**User Interactivity:**\n- Include user interactivity within the experiment that allows for the modification of `my_species` behavior during runtime through specific commands.",
        "output": "model quick_user_command_model\n\n\nglobal {\n   init {\n       create my_species number:10;\n   }\n}\n\n\nspecies my_species {\n   user_command cmd_inside_experiment action:die;\n   aspect base {\n       draw circle(1) color:#blue;\n   }\n}\n\n\nexperiment expe type:gui {\n   output {\n       display my_display {\n           species my_species aspect:base;\n       }\n   }\n}\n"
    },
    {
        "instruction": "Create a species called \"animal\" within a simulation environment. Each animal will have a red color by default, move at a speed of 1.0, and possess varying attributes like metabolism (random between 1 and maxMetabolism), vision range (random between 1 and maxRange), and lifespan (random within a defined range). Animals also have a fixed size of 0.5 and manage their energy through \"sugar\" reserves, which decrease with each step based on their metabolism. They keep track of their age, capped at their maximum lifespan, and occupy specific locations within the simulation grid represented by \"sugar_cells.\"",
        "output": "species animal {\n\t\/\/Color of the animal\n\trgb color  <- #red;\n\t\/\/Speed of the animal\n\tfloat speed  <- 1.0;\n\t\/\/Metabolism of the animal\n\tint metabolism  min: 1 <- rnd(maxMetabolism);\n\t\/\/Perception range of the animal\n\tint vision  min: 1 <- rnd(maxRange);\n\t\/\/Maximal age of the animal\n\tint maxAge  min: minDeathAge max: maxDeathAge <- rnd (maxDeathAge - minDeathAge) + minDeathAge;\n\t\/\/Size of the animal\n\tfloat size  <- 0.5;\n\t\/\/Sugar of the animal\n\tint sugar min: 0 <- (rnd (maxInitialSugar - minInitialSugar)) + minInitialSugar update: sugar - metabolism;\n\t\/\/Age of the animal\n\tint age max: maxAge <- 0 update: int(age + step);\n\t\/\/Place of the animal\n\tsugar_cell place;\n} "
    },
    {
        "instruction": "Can I draw my agent as a sphere of radius 1",
        "output": "draw sphere(1);"
    },
    {
        "instruction": "How to draw my agent as a circle of radius 1",
        "output": "draw circle(1);"
    },
    {
        "instruction": "Create a complete model showing an agent or a group of agent navigating in space using his field of vision (perception angle, distance), to avoid barriers.",
        "output": "model fieldofvision\n\nglobal {\n\t\/\/number of obstacles\n\tint nb_obstacles <- 20 parameter: true;\n\t\n\t\/\/perception distance\n\tfloat perception_distance <- 40.0 parameter: true;\n\t\n\t\/\/precision used for the masked_by operator (default value: 120): the higher the most accurate the perception will be, but it will require more computation\n\tint precision <- 600 parameter: true;\n\t\n\t\/\/space where the agent can move.\n\tgeometry free_space <- copy(shape);\n\tinit {\n\t\tcreate obstacle number:nb_obstacles {\n\t\t\tshape <- rectangle(2+rnd(20), 2+rnd(20));\n\t\t\tfree_space <- free_space - shape;\n\t\t}\n\t\t\n\t\tcreate people  {\n\t\t\tlocation <- any_location_in(free_space);\n\t\t}\n\t}\n}\n\nspecies obstacle {\n\taspect default {\n\t\tdraw shape color: #gray border: #black;\n\t}\n}\nspecies people skills: [moving]{\n\t\/\/zone of perception\n\tgeometry perceived_area;\n\t\n\t\/\/the target it wants to reach\n\tpoint target ;\n\t\n\treflex move {\n\t\tif (target = nil ) {\n\t\t\tif (perceived_area = nil) or (perceived_area.area < 2.0) {\n\t\t\t\t\/\/if the agent has no target and if the perceived area is empty (or too small), it moves randomly inside the free_space\n\t\t\t\tdo wander bounds: free_space;\n\t\t\t} else {\n\t\t\t\t\/\/otherwise, it computes a new target inside the perceived_area .\n\t\t\t\ttarget <- any_location_in(perceived_area);\n\t\t\t}\n\t\t} else {\n\t\t\t\/\/if it has a target, it moves towards this target\n\t\t\tdo goto target: target;\n\t\t\t\n\t\t\t\/\/if it reaches its target, it sets it to nil (to choose a new target)\n\t\t\tif (location = target)  {\n\t\t\t\ttarget <- nil;\n\t\t\t}\n\t\t}\n\t}\n\t\/\/computation of the perceived area\n\treflex update_perception {\n\t\t\/\/the agent perceived a cone (with an amplitude of 60\u00b0) at a distance of  perception_distance (the intersection with the world shape is just to limit the perception to the world)\n\t\tperceived_area <- (cone(heading-30,heading+30) intersection world.shape) intersection circle(perception_distance); \n\t\t\n\t\t\/\/if the perceived area is not nil, we use the masked_by operator to compute the visible area from the perceived area according to the obstacles\n\t\tif (perceived_area != nil) {\n\t\t\tperceived_area <- perceived_area masked_by (obstacle,precision);\n\n\t\t}\n\t}\n\t\n\taspect body {\n\t\tdraw triangle(2) rotate:90 + heading color: #red;\n\t}\n\taspect perception {\n\t\tif (perceived_area != nil) {\n\t\t\tdraw perceived_area color: #green;\n\t\t\tdraw circle(1) at: target color: #magenta;\n\t\t}\n\t}\n}\n\nexperiment fieldofvision type: gui {\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput synchronized: true {\n\t\tdisplay view{\n\t\t\tspecies obstacle;\n\t\t\tspecies people aspect: perception transparency: 0.5;\n\t\t\tspecies people aspect: body;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Write a GAML code snippet that accomplishes the following tasks:\n\n\n**Model Specification:**\n- Create a model with the identifier `CSVfileloading`.\n- The central function of this model is to load agent data from a CSV file.\n\n\n**CSV File Agent Creation:**\n- In the `init` block of the `global` species, instruct the model to:\n - Generate `iris` agents by importing data from a CSV file named `iris.csv`. Assume this file is located within a `includes` directory at the parent level of the current project.\n - Utilize the CSV file header to automatically map columns to agent attributes.\n - Directly assign the agent's attributes using the header values, converting them to the correct data type (e.g., `float` for numeric values and `string` for textual values).\n\n\n**Species Attributes and Initialization:**\n- Define a species `iris` with attributes:\n - Numeric attributes: `sepal_length`, `sepal_width`, `petal_length`, `petal_width`.\n - Categorical attribute: `type`.\n - Visualization attribute: `color` of type `rgb`.\n\n\n- For initial species attributes:\n - Assign color values based on the `type` attribute using a conditional statement. For instance, if `type` equals `Iris-setosa`, set the color to blue, otherwise, if `type` equals `Iris-virginica`, set the color to red; default to yellow for all other types.\n\n\n**Visualization Aspect:**\n- Define an aspect named `default` for the `iris` species that:\n - Draws a circle with the size based on the `petal_width`.\n - Colors the circle with the `color` attribute defined in the `iris` species.\n\n\n**Experiment Configuration:**\n- Create an experiment titled `main` with a graphical user interface (GUI).\n- For the experiment`s output:\n - Set up a display titled `map`.\n - Ensure the display visualizes the `iris` species with the previously defined `default` aspect.\n\n\n**Additional Notes:**\n- Include comments in the global `init` block to clarify the purpose of the `header` facet when loading from the CSV file and the impact of setting it to true or false.",
        "output": "model CSVfileloading\n\n\nglobal {\n  \n   init {\n       \/\/create iris agents from the CSV file (use of the header of the CSV file), the attributes of the agents are initialized from the CSV files:\n       \/\/we set the header facet to true to directly read the values corresponding to the right column. If the header was set to false, we could use the index of the columns to initialize the agent attributes\n       create iris from:csv_file( \"..\/includes\/iris.csv\",true) with:\n           [sepal_length::float(get(\"sepallength\")),\n               sepal_width::float(get(\"sepalwidth\")),\n               petal_length::float(get(\"petallength\")),\n               petal_width::float(get(\"petalwidth\")),\n               type::string(get(\"type\"))\n           ]; \n   }\n}\n\n\nspecies iris {\n   float sepal_length;\n   float sepal_width;\n   float petal_length;\n   float petal_width;\n   string type;\n   rgb color ;\n  \n   init {\n       color <- type =\"Iris-setosa\" ? #blue : ((type =\"Iris-virginica\") ? #red: #yellow);\n   }\n  \n   aspect default {\n       draw circle(petal_width) color: color;\n   }\n}\n\n\nexperiment main type: gui{\n   output {\n       display map {\n           species iris;\n       }\n   }\n  \n}\n"
    },
    {
        "instruction": "How can I instantiate agents from a csv file where each line of the csv represent an agent? ",
        "output": "\/\/ Define the path to your csv file\ncreate myAgent from:csv_file(\"pathToYourFile\/file.csv\");"
    },
    {
        "instruction": "Create a complete model to represent how the agents move from one point to a target agent on a grid of cells with obstacles, following the shortest path and coloring in magenta the cells intersecting the path of an agent",
        "output": "model Grid\n\nglobal {\n\t\/*2 algorithms for the shortest path computation on a grid with weights:\n\t*      - A* : default algorithm: An introduction to A*: http:\/\/www.redblobgames.com\/pathfinding\/a-star\/introduction.html\n\t*      - Dijkstra : Classic Dijkstra algorithm. An introduction to Dijkstra : http:\/\/www.redblobgames.com\/pathfinding\/a-star\/introduction.html\n\t*\/\n\t\n\tfile dem <- file(\"..\/includes\/vulcano_50.asc\");\n\tgeometry shape <- envelope(dem);\n\tstring algorithm <- \"A*\" among: [\"A*\", \"Dijkstra\"] parameter: true;\n\tint neighborhood_type <- 8 among:[4,8] parameter: true;\n\tmap<cell,float> cell_weights;\n\n\tinit {    \n\t\task cell {grid_value <- grid_value * 5;}  \n\t\tfloat max_val <- cell max_of (each.grid_value);\n\t\task cell {\n\t\t\tfloat val <- 255 * (1 - grid_value \/ max_val);\n\t\t\tcolor <- rgb(val, val,val);\n\t\t}\n\t\tcell_weights <- cell as_map (each::each.grid_value);\n\t\tcreate goal{\n\t\t\tlocation <- (one_of (cell where not each.is_obstacle)).location;\n\t\t}\n\t\tcreate people number: 10 {\n\t\t\ttarget <- one_of (goal);\n\t\t\tlocation <-  (one_of (cell where not each.is_obstacle)).location;\n\t\t}\n\t} \n}\n\ngrid cell file: dem neighbors: neighborhood_type optimizer: algorithm {\n\tbool is_obstacle <- flip(0.2);\n\trgb color <- is_obstacle ? #black : #white;\n} \n\t \nspecies goal {\n\taspect default { \n\t\tdraw circle(0.5) color: #red;\n\t}\n}  \n\t\n\t  \nspecies people skills: [moving] {\n\tgoal target;\n\tfloat speed <- 1.0;\n\taspect default {\n\t\tdraw circle(0.5) color: #green;\n\t\tif (current_path != nil) {\n\t\t\tdraw current_path.shape color: #red;\n\t\t}\n\t}\n\t\n\treflex move when: location != target{\n\t\t\/\/We restrain the movements of the agents only at the grid of cells that are not obstacle using the on facet of the goto operator and we return the path\n\t\t\/\/followed by the agent\n\t\t\/\/the recompute_path is used to precise that we do not need to recompute the shortest path at each movement (gain of computation time): the obtsacles on the grid never change.\n\t\tdo goto (on:cell_weights, target:target, speed:speed, recompute_path: false);\n\t\t\n\t\t\/\/As a side note, it is also possible to use the path_between operator and follow action with a grid\n\t\t\/\/Add a my_path attribute of type path to the people species\n\t\t\/\/if my_path = nil {my_path <- path_between((cell where not each.is_obstacle), location, target);}\n\t\t\/\/do follow (path: my_path);\n\t}\n}\n\nexperiment goto_grid type: gui {\n\toutput {\n\t\tdisplay objects_display type:2d antialias:false{\n\t\t\tgrid cell border: #black;\n\t\t\tspecies goal aspect: default ;\n\t\t\tspecies people aspect: default ;\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Create a complete model that illustrates the use of the wander action of the moving Skill on a graph,  the probability to choose a road is given by a map (road::probability). Each road segment is constructed or defined from a line shape.",
        "output": "model WanderonGraph\n\nglobal {\n\t\n\tgraph network;\n\t\n\t\/\/map that gives the probability to choose a road\n\tmap<road,float> proba_use_road;\n\t\n\tinit {\n\t\tcreate road with: [shape::line([{10,10}, {40,10}])];\n\t\tcreate road with: [shape::line([{40,10}, {40,40}])];\n\t\tcreate road with: [shape::line([{40,10}, {80,10}])];\n\t\tcreate road with: [shape::line([{80,10}, {80,40}])];\n\t\tcreate road with: [shape::line([{40,40}, {80,40}])];\n\t\tcreate road with: [shape::line([{80,40}, {80,80}])];\n\t\tcreate road with: [shape::line([{80,80}, {10,80}])];\n\t\tcreate road with: [shape::line([{80,80}, {50,50}])];\n\t\tcreate road with: [shape::line([{50,50}, {10,80}])];\n\t\tcreate road with: [shape::line([{10,80}, {10,10}])];\n\t\t\n\t\t\n\t\tcreate people number: 50 with: [location::any_location_in(one_of(road))];\n\t\t\n\t\t\/\/directed graph build from the road agents\n\t\tnetwork <- directed(as_edge_graph(road));\n\t\t\n\t\t\/\/the map of probability to choose a road is build from the proba_use attribute of roads\n\t\tproba_use_road <- road as_map (each::each.proba_use);\n\t}\n}\n\nspecies road {\n\t\/\/ probability for a agent to choose this road\n\tfloat proba_use <- rnd(0.1, 1.0);\n\t\n\taspect default {\n\t\tdraw shape +(proba_use\/2.0)  color: #gray end_arrow: 2.0;\n\t}\n}\n\nspecies people skills: [moving]{\n\trgb color <- rnd_color(255);\n\taspect default {\n\t\tdraw circle(1.0) color:color border: #black;\n\t}\n\t\n\treflex move {\n\t\t\/\/ move randomly on the network, using proba_use_road to define the probability to choose a road.\n\t\tdo wander on: network proba_edges: proba_use_road ;\n\t}\n}\n\nexperiment WanderonGraph type: gui {\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput {\n\t\tdisplay map type:2d{\n\t\t\tspecies road;\n\t\t\tspecies people;\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "the GAML code for a waste bin agent",
        "output": "species waste_bin {\n    float capacity;\n    float current_level;\n    point location;\n    \n    reflex update_level {\n        \/\/ Code to update the current level of waste in the bin\n    }\n    \n    reflex request_collection when: current_level > 0.8 * capacity {\n        \/\/ Code to request waste collection\n    }\n}\n"
    },
    {
        "instruction": "How can I instantiate agents from a csv file where each line of the csv represent an agent and the value of n the first column name col1 of the csv to initiate an attribute1 of my species? ",
        "output": "create myAgent from:csv_file(\"pathToYourFile\/file.csv\") with:[attribute1::float(get(\"col1\"))];\n\nspecies myAgent{\n  float attribute1;\n}"
    },
    {
        "instruction": "Write a GAML code snippet that accomplishes the following tasks:\n\n\n**Model Name Definition:**\n- Start by defining a model called `import_csv`.\n\n\n**Global Block Specifications:**\n- Declare a file variable to read from a CSV file named `test.csv`, assuming it's located in an `includes` subdirectory relative to the GAML file.\n\n\n**Initialization Steps:**\n- Within the block `init` of `global` species section:\n - Read and store the CSV file contents into a GAML matrix to represent the grid data.\n - Iterate over a custom grid, accessing each cell and:\n   - Assign cell values as floats from the corresponding entries in the matrix.\n   - Optionally, output the values to the console for verification.\n\n\n**Grid Configuration and Reflexes:**\n- Define a grid named `my_gama_grid` with specified dimensions (width and height).\n- Within this grid, create a reflex called `update_color` to:\n - Print the current cell\u2019s value for debugging purposes.\n - Change the cell\u2019s color based on its value using a conditional statement (e.g., if the value equals 1, color it blue, otherwise color it white).\n\n\n**Experiment and Output Settings:**\n- Set up an experiment called `main` of the `gui` type.\n- Configure the experiment`s output:\n - Display a visualization that shows `my_gama_grid`.\n - Ensure that the visualization updates to reflect changes in the grid, demonstrating the interaction between the cell values and their colors.",
        "output": "model import_csv\n\n\nglobal {\n   file my_csv_file <- csv_file(\"..\/includes\/test.csv\",\",\");\n   init {\n       matrix data <- matrix(my_csv_file);\n       ask my_gama_grid {\n           grid_value <- float(data[grid_x,grid_y]);\n           write data[grid_x,grid_y];\n       }\n   }\n}\n\n\ngrid my_gama_grid width: 11 height: 8 {\n   reflex update_color {\n       write grid_value;\n       color <- (grid_value = 1) ? #blue : #white;\n   }\n}\n\n\nexperiment main type: gui{\n   output {\n       display display_grid {\n           grid my_gama_grid;\n       }\n   }\n}\n"
    },
    {
        "instruction": "Create a complete model to show the movement on a graph created by polygons. The model will create a graph using a polygon shapefile by skeletonizing it, and creating roads using the skeleton. All of the agents will use this graph to go to the same targeted location.",
        "output": "model polygon\n\nglobal {\n\t\/\/Import of the shapefile containing the different polygons\n\tfile shape_file_in <- file('..\/includes\/gis\/squareHole.shp') ;\n\tgraph the_graph;\n\t\n\tgeometry shape <- envelope(shape_file_in);\n\t\n\tinit {    \n\t\tcreate object from: shape_file_in ;\n\t\tobject the_object <- first(object);\n\t\t\n\t\t\/\/triangulation of the object to get the different triangles of the polygons\n\t\tlist<geometry> triangles <- list(triangulate(the_object, 0.01));\n\t\t\n\t\tloop trig over: triangles {\n\t\t\tcreate triangle_obj {\n\t\t\t\tshape <- trig;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/creation of a list of skeleton from the object \n\t\tlist<geometry> skeletons <- list(skeletonize(the_object, 0.01));\n\t\t\n\t\t\/\/Split of the skeletons list according to their intersection points\n\t\tlist<geometry> skeletons_split  <- split_lines(skeletons);\n\t\tloop sk over: skeletons_split {\n\t\t\tcreate skeleton {\n\t\t\t\tshape <- sk;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/Creation of the graph using the edges resulting of the splitted skeleton\n\t\t the_graph <- as_edge_graph(skeleton);\n\t\t \n\t\t \n\t\tcreate goal  {\n\t\t\t location <- any_location_in (one_of(skeleton)); \n\t\t}\n\t\tcreate people number: 100 {\n\t\t\t target <- one_of (goal) ; \n\t\t\t location <- any_location_in (one_of(skeleton));\n\t\t} \n\t}\n}\n\nspecies object  {\n\taspect default {\n\t\tdraw shape color: #gray ;\n\t}\n}\n\nspecies triangle_obj  {\n\trgb color <- rgb(150 +rnd(100),150 + rnd(100),150 + rnd(100));\n\taspect default {\n\t\tdraw shape color: color ; \n\t}\n}\n\nspecies skeleton  {\n\taspect default {\n\t\tdraw shape + 0.2 color: #red ;\n\t}\n}\n\t\nspecies goal {\n\taspect default {\n\t\tdraw circle(3) color:#red;\n\t}\n}\n\nspecies people skills: [moving] {\n\tgoal target;\n\tpath my_path; \n\t\n\treflex goto {\n\t\tdo goto on:the_graph target:target speed:1.0;\n\t}\n\taspect default {\n\t\tdraw circle(3) color: #green;\n\t}\n}\n\nexperiment goto_polygon type: gui {\n\toutput {\n\t\tdisplay objects_display {\n\t\t\tspecies object aspect: default ;\n\t\t\tspecies triangle_obj aspect: default ;\n\t\t\tspecies skeleton aspect: default ;\n\t\t\tspecies people aspect: default ;\n\t\t\tspecies goal aspect: default ;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Creating a GAML code for an enhanced backtracking search algorithm to optimize waste collection routes involves several steps. The algorithm would typically be used to determine the most efficient paths for waste collection vehicles to take, considering factors like the shortest travel distance, the least amount of time, or the lowest fuel consumption.",
        "output": "global {\n  float threshold = 0.75; \/\/ Threshold for bin fullness to trigger collection\n  list<bin> bins; \/\/ List of all waste bins\n  list<vehicle> vehicles; \/\/ List of all collection vehicles\n}\n\nspecies bin {\n  float fullness <- 0; \/\/ Current fullness level\n  point location; \/\/ Geographic location of the bin\n  \n  reflex check_fullness {\n    if (fullness > threshold) {\n      \/\/ Code to mark bin for collection\n    }\n  }\n}\n\nspecies vehicle {\n  path current_route; \/\/ Current collection route\n  float capacity; \/\/ Vehicle capacity\n  float load <- 0; \/\/ Current load\n  \n  reflex plan_route {\n    \/\/ Code to plan the collection route using the backtracking search algorithm\n  }\n  \n  reflex collect_waste {\n    \/\/ Code to collect waste from bins\n  }\n}\n\nexperiment WasteCollection type: gui {\n  \/\/ Code to set up the simulation environment\n}\n"
    },
    {
        "instruction": "Write a GAML code snippet that accomplishes the following tasks:\n\n\n**Model Creation and Global Scope:**\n- Begin by defining a model named 'URLImageImport'.\n- Within the global scope, outline the purpose and structure of the model, which includes importing an image, manipulating it, and saving the result.\n\n\n**Auxiliary Function Definition:**\n- Introduce a utility function, say `essai`, which accepts an integer parameter and returns a modified value (in the example, the function always returns 100, but you can specify the desired operation). For clarity, provide a concise comment on the essence of the function.\n\n\n**External Image Import and Geometry Extraction:**\n- Declare an image file loaded from an external URL, providing the exact address as shown in the example (or specify any desired image URL for the task).\n- Extract and store a geometry from the image's envelope to demonstrate image handling capabilities in GAML.\n\n\n**Image Processing and Copying:**\n- Process the original image data by performing a `shuffle` operation on its contents. Outline the expected change of the data from this shuffle (e.g., pixel positions shuffled).\n- Construct an auxiliary function call to demonstrate how user-defined functions can interact with data, such as passing a value and storing the result in a variable.\n\n\n**Local Image File Creation and Initialization:**\n- Direct the creation of an image file in the local file system using the modified matrix data. Specify the path (e.g., \"..\/images\/local_copy.png\") and the data source (shuffled image contents).\n- During the model's initialization phase (`init`), instruct the modified image file to be saved locally, providing the steps to persist the processed image data on the disk.\n\n\n**Experiment Design and Output Visualization:**\n- Outline an experiment named 'urlImage' that is intended for visualization of the transformation made to the image data.\n- In the experiment's output block:\n - Configure a display named 'display' with a white background.\n - Include instructions to display both the original image (`im`) and the locally saved copy (`copy`) within the display. Mention the element properties (e.g., size, position) if necessary for precise placement.\n\n\n**Additional Notes:**\n- Embed comments within the script to detail each step, particularly when dealing with GAML-specific functions such as `image_file`, `geometry`, `shuffle`, and `save`. This should guide the code creation process clearly.",
        "output": "model URLImageImport\n\n\nglobal {\n  \n   int essai(int a) {\n       return 100;\n   }\n  \n   image_file im <- image_file(\"https:\/\/raw.githubusercontent.com\/wiki\/gama-platform\/gama\/resources\/images\/general\/GamaPlatform.png\");\n   geometry shape <- envelope(im);\n   \/\/ We modify a bit the image\n   matrix<int> shuffle <- shuffle(im.contents);\n   int c <- essai(100);\n   \/\/ We create a file with the new contents\n   image_file copy <- image_file(\"..\/images\/local_copy.png\", shuffle);\n   init {\n       \/\/ And save it\n       save copy;\n   }\n\n\n}\n\n\nexperiment urlImage {\n   output {\n       display 'display' background: #white {\n           image  copy;\n           image im ;\n       }\n\n\n   }\n\n\n}\n"
    },
    {
        "instruction": "Generate a model composed of an empty global block, a speciel animal and a grid of 30 by 30 plot cells. Plots have a, attribute state (type string).",
        "output": "global { }\n\ngrid plot height: 30 width: 30 {\n\tstring state;\n}\n\nspecies animal {  }"
    },
    {
        "instruction": "Create a GAML code snippet that configures a new species with the following attributes, reflexes, and visual aspects:\n\n\n- Name the species `people`.\n- Assign the skill `moving` to enable basic movement capabilities.\n- Declare a boolean attribute `is_infected` with an initial value of `false`.\n- Create a `point` type attribute named `target` that will represent the location this person is moving towards.\n- Introduce an `int` type attribute called `staying_counter` that counts the number of cycles a person has stayed in one location.\n- Define a `reflex` named `stay` that activates when the `target` is `nil`. Within this reflex:\n - Increment `staying_counter` by 1 every cycle.\n - Use a probabilistic function `flip(staying_counter \/ staying_coeff)` to determine when to move, assigning a new target location selected from any of the buildings (`one_of(building)`).\n- Implement another `reflex` named `move` that triggers when `target` is not `nil` and should:\n - Command the person to go to the `target` via the `road_network`.\n - Reset `target` to `nil` and `staying_counter` to 0 once the `target` location is reached.\n- Add a `reflex` named `infect` that is executed when `is_infected` is true. It should:\n - Affect nearby `people` within a certain `infection_distance`.\n - Use a `flip(proba_infection)` function to probabilistically infect others.\n- Incorporate an `aspect` with the name `default` to visually represent the people in two-dimensional space by:\n - Drawing a circle of size 5 where the color is red if `is_infected` is true, and green otherwise.\n- Finally, create an `aspect` called `sphere3D` for three-dimensional visual representation where:\n - Each person is drawn as a sphere of radius 3, elevated above the ground by 3 units (`location.z + 3`).\n - The color of the sphere should also indicate the infection status, red for infected and green for not infected.\n\n\nEnsure that the snippet reflects the behavior and visual representation of the people, considering their infection status and movement within a modeled environment.\n",
        "output": "species people skills:[moving]{    \n   bool is_infected <- false;\n   point target;\n   int staying_counter;\n   reflex stay when: target = nil {\n       staying_counter <- staying_counter + 1;\n       if flip(staying_counter \/ staying_coeff) {\n           target <- any_location_in (one_of(building));\n       }\n   }\n      \n   reflex move when: target != nil{\n       do goto target:target on: road_network;\n       if (location = target) {\n           target <- nil;\n           staying_counter <- 0;\n       }\n   }\n   reflex infect when: is_infected{\n       ask people at_distance infection_distance {\n           if flip(proba_infection) {\n               is_infected <- true;\n           }\n       }\n   }\n   aspect default{\n       draw circle(5) color:is_infected ? #red : #green;\n   }\n   aspect sphere3D{\n       draw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;\n   }\n}\n"
    },
    {
        "instruction": "Create a complete model showing how to represent a flooding system with dykes and buildings. It uses a grid to discretize space, and has a 3D display. The water can flow from one cell to another considering the height of the cells, and the water pressure. It is also possible to delete dyke by clicking on one of them in the display.",
        "output": "model hydro\n\nglobal {\n\t\n   \/\/Shapefile for the river\n   file river_shapefile <- file(\"..\/includes\/RedRiver.shp\");\n   \/\/Shapefile for the dykes\n   file dykes_shapefile <- file(\"..\/includes\/Dykes.shp\");\n   \/\/Shapefile for the buildings\n   file buildings_shapefile <- file(\"..\/includes\/Building.shp\");\n   \n   \/\/Data elevation file\n   file dem_file <- file(\"..\/includes\/mnt50.asc\");  \n   \/\/Diffusion rate\n   float diffusion_rate <- 0.6;\n   \/\/Height of the dykes\n   float dyke_height <- 15.0;\n   \/\/Width of the dyke\n   float dyke_width <- 15.0;\n    \n   \/\/Shape of the environment using the dem file\n   geometry shape <- envelope(dykes_shapefile);\n   \n   \/\/List of the drain and river cells\n   list<cell> drain_cells;\n   list<cell> river_cells;\n   \n   \n  \n   float step <- 1#h;\n   \n   init {\n   \t \/\/Initialization of the cells\n      do init_cells;\n     \/\/Initialization of the water cells\n      do init_water;\n     \/\/Initialization of the river cells\n     river_cells <- cell where (each.is_river);\n     \/\/Initialization of the drain cells\n      drain_cells <- cell where (each.is_drain);\n     \/\/Initialization of the obstacles (buildings and dykes)\n      do init_obstacles;\n      \/\/Set the height of each cell\n      ask cell {\n         obstacle_height <- compute_highest_obstacle();\n         do update_color;\n      }\n   }\n   \/\/Action to initialize the altitude value of the cell according to the dem file\n   action init_cells {\n      ask cell  {\n         altitude <- grid_value;\n         neighbour_cells <- (self neighbors_at 1) ;\n      }\n   }\n   \/\/action to initialize the water cells according to the river shape file and the drain\n   action init_water {\n      geometry river <- geometry(river_shapefile);\n      ask cell overlapping river  {\n         water_height <- 10.0;\n         is_river <- true;\n         is_drain <- grid_y = matrix(cell).rows - 1;\n      }\n   }\n   \/\/initialization of the obstacles (the buildings and the dykes)\n   action init_obstacles{\n      create buildings from: buildings_shapefile  {\n         do update_cells;\n      }\n      create dyke from: dykes_shapefile;\n      ask dyke  {\n          shape <-  shape + dyke_width;\n            do update_cells;\n      }\n   }\n   \/\/Reflex to add water among the water cells\n   reflex adding_input_water {\n   \t  float water_input <- rnd(100)\/100;\n      ask river_cells {\n         water_height <- water_height + water_input;\n      }\n   }\n   \/\/Reflex to flow the water according to the altitute and the obstacle\n   reflex flowing {\n      ask (cell sort_by ((each.altitude + each.water_height + each.obstacle_height))) {\n      \talready <- false;\n         do flow;\n      }\n   }\n   \/\/Reflex to update the color of the cell\n   reflex update_cell_color {\n      ask cell  {\n         do update_color;\n      }\n   }\n   \/\/Reflex for the drain cells to drain water\n   reflex draining {\n      ask drain_cells {\n         water_height <- 0.0;\n      }\n   }\n   \n}\n\/\/Species which represent the obstacle\n   species obstacle  {\n   \t  \/\/height of the obstacle\n      float height min: 0.0;\n      \/\/Color of the obstacle\n      rgb color;\n      \/\/Pressure of the water\n      float water_pressure update: compute_water_pressure();\n      \n      \/\/List of cells concerned\n      list<cell> cells_concerned ;\n      \/\/List of cells in the neighbourhood \n      list<cell> cells_neighbours;\n      \n      \/\/Action to compute the water pressure\n      float compute_water_pressure {\n      \t\/\/If the obstacle doesn't have height, then there will be no pressure\n         if (height = 0.0) {\n            return 0.0;\n         } else {\n         \t\/\/The leve of the water is equals to the maximul level of water in the neighbours cells\n            float water_level <- cells_neighbours max_of (each.water_height);\n            \/\/Return the water pressure as the minimal value between 1 and the water level divided by the height\n            return min([1.0,water_level \/ height]);\n         } \n      }\n      \n      \/\/Action to update the cells\n      action update_cells {\n      \t\/\/All the cells concerned by the obstacle are the ones overlapping the obstacle\n         cells_concerned <- (cell overlapping self);\n        \task cells_concerned {\n        \t\/\/Add the obstacles to the obstacles of the cell\n            add myself to: obstacles;\n            water_height <- 0.0;\n         }\n         \/\/Cells neighbours are all the neighbours cells of the cells concerned\n         cells_neighbours <- cells_concerned + cells_concerned accumulate (each.neighbour_cells);\n         \/\/The height is now computed\n      \t do compute_height();\n         if (height > 0.0) {   \n         \t\/\/We compute the water pressure again\n            water_pressure <- compute_water_pressure();\n         } else {water_pressure <- 0.0;}\n      }\n      action compute_height;\n      aspect geometry {\n         int val <- int( 255 * water_pressure);\n         color <- rgb(val,255-val,0);\n         draw shape color: color depth: height*5 border: color;\n      }\n   }\n   \/\/Species buildings which is derivated from obstacle\n   species buildings parent: obstacle schedules: [] {\n   \t \/\/The building has a height randomly chosed between 2 and 10\n      float height <- 2.0 + rnd(8);\n   }\n   \/\/Species dyke which is derivated from obstacle\n   species dyke parent: obstacle {\n   \t\n       int counter_wp <- 0;\n       int breaking_threshold <- 24;\n      \n      \/\/Action to represent the break of the dyke\n       action break{\n         ask cells_concerned  {\n            do update_after_destruction(myself);\n         }\n         do die;\n      }\n      \/\/Action to compute the height of the dyke as the dyke_height without the mean height of the cells it overlaps\n      action compute_height\n       {\n      \t   height <- dyke_height - mean(cells_concerned collect (each.altitude));\n      \n      }\n      \n      \/\/Reflex to break the dynamic of the water\n      reflex breaking_dynamic {\n      \tif (water_pressure = 1.0) {\n      \t\tcounter_wp <- counter_wp + 1;\n      \t\tif (counter_wp > breaking_threshold) {\n      \t\t\tdo break;\n      \t\t}\n      \t} else {\n      \t\tcounter_wp <- 0;\n      \t}\n      }\n      \/\/user command which allows the possibility to destroy the dyke for the user\n      user_command \"Destroy dyke\" action: break; \n   }\n   \/\/Grid cell to discretize space, initialized using the dem file\n   grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false schedules: []  {\n      \/\/Altitude of the cell\n      float altitude;\n      \/\/Height of the water in the cell\n      float water_height <- 0.0 min: 0.0;\n      \/\/Height of the cell\n      float height;\n      \/\/List of the neighbour cells\n      list<cell> neighbour_cells ;\n      \/\/Boolean to know if it is a drain cell\n      bool is_drain <- false;\n      \/\/Boolean to know if it is a river cell\n      bool is_river <- false;\n      \/\/List of all the obstacles overlapping the cell\n      list<obstacle> obstacles;\n      \/\/Height of the obstacles\n      float obstacle_height <- 0.0;\n      bool already <- false;\n      \n      \/\/Action to compute the highest obstacle among the obstacles\n      float compute_highest_obstacle {\n         if (empty(obstacles))\n         {\n            return 0.0; \n         } else {\n            return obstacles max_of(each.height);\n         }\n      }\n      \/\/Action to flow the water \n      action flow {\n      \t\/\/if the height of the water is higher than 0 then, it can flow among the neighbour cells\n         if (water_height > 0) {\n         \t\/\/We get all the cells already done\n            list<cell> neighbour_cells_al <- neighbour_cells where (each.already);\n            \/\/If there are cells already done then we continue\n            if (!empty(neighbour_cells_al)) {\n               \/\/We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height\n               ask neighbour_cells_al {height <- altitude + water_height + obstacle_height;}\n               \/\/The height of the cell is equals to its altitude and water height\n               height <-  altitude +  water_height;\n               \/\/The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell\n               list<cell> flow_cells <- (neighbour_cells_al where (height > each.height)) ;\n               \/\/If there are cells, we compute the water flowing\n               if (!empty(flow_cells)) {\n                  loop flow_cell over: shuffle(flow_cells) sort_by (each.height){\n                     float water_flowing <- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]); \n                     water_height <- water_height - water_flowing;\n                     flow_cell.water_height <-flow_cell.water_height +  water_flowing;\n                     height <- altitude + water_height;\n                  }   \n               }\n            }\n         }\n         already <- true;\n      }  \n      \/\/Update the color of the cell\n      action update_color { \n         int val_water <- 0;\n         val_water <- max([0, min([255, int(255 * (1 - (water_height \/ 12.0)))])]) ;  \n         color <- rgb([val_water, val_water, 255]);\n         grid_value <- water_height + altitude;\n      }\n      \/\/action to compute the destruction of the obstacle\n      action update_after_destruction(obstacle the_obstacle){\n         remove the_obstacle from: obstacles;\n         obstacle_height <- compute_highest_obstacle();\n      }\n       \n   }\n\n\nexperiment Run type: gui {\n   parameter \"Shapefile for the river\" var:river_shapefile category:\"Water data\";\n   parameter \"Shapefile for the dykes\" var:dykes_shapefile category:\"Obstacles\";\n   parameter \"Shapefile for the buildings\" var:buildings_shapefile category:\"Obstacles\";\n   parameter \"Height of the dykes\" var:dyke_height category:\"Obstacles\";\n   parameter \"Diffusion rate\" var:diffusion_rate category:\"Water dynamic\";\n   output { \n   \/\/layout vertical([0::5000,1::5000]) tabs:false editors: false;\n      display map type: 3d {\n         grid cell triangulation: true;\n         species buildings aspect: geometry refresh: false;\n         species dyke aspect: geometry ;\n      }\n      display chart_display refresh: every(24#cycles)  type: 2d  { \n         chart \"Pressure on Dykes\" type: series legend_font: font(\"Helvetica\", 18)  label_font: font(\"Helvetica\", 20, #bold)  title_font: font(\"Helvetica\", 24, #bold){\n            data \"Mean pressure on dykes \" value: mean(dyke collect (each.water_pressure)) style: line color: #magenta  ;\n            data \"Rate of dykes with max pressure\" value: (dyke count (each.water_pressure = 1.0))\/ length(dyke) style: line color: #red ;\n            data \"Rate of dykes with high pressure\" value: (dyke count (each.water_pressure > 0.5))\/ length(dyke) style: line color: #orange ;\n            data \"Rate of dykes with low pressure\" value: (dyke count (each.water_pressure < 0.25))\/ length(dyke) style: line color: #green ;\n         }\n      }\n   }\n}"
    },
    {
        "instruction": "Generate an experiment displaying in a monitor the global variable nb_happy_people;",
        "output": "experiment Schelling1 type: gui {\n\n\toutput {\n\t\t\/\/ other displays\n\n\t\tmonitor \"nb of happy people\" value: nb_happy_people;\n\t}\n}"
    },
    {
        "instruction": "Load a river shapefile (RedRiver.shp) from the includes folder.",
        "output": "file river_shapefile <- file(\"..\/includes\/RedRiver.shp\");"
    },
    {
        "instruction": "Develop a GAML code snippet that configures a grid representing vegetation cells. Detail the grid's properties and the internal attributes of the cells as follows:\n\n\n- Define the grid with the name `vegetation_cell` and set its size to a width of 50 and a height of 50 cells. Specify that each cell should consider 4 neighbors.\n- Inside the `vegetation_cell` species, declare a constant `float` variable `max_food` with a value of `1.0`.\n- Generate an initial `float` variable `food_prod` to represent food production, assigning it a random value up to `0.01`.\n- Establish a `float` variable `food`, representing the amount of food available in the vegetation cell, with a random initial value up to `1.0`. Ensure that this value cannot exceed `max_food` and is set to increment by `food_prod` at every update.\n- Create an `rgb` type variable `color` that reflects the food availability in the cell. The red and blue components of the RGB color should inversely correlate with the `food` variable (i.e., lower food leads to higher red and blue values), while the green component remains constant at `255`. Update this color to reflect changes in the food variable dynamically.\n- Define a list of `vegetation_cell` type named `neighbors2`. This list should be populated with neighboring cells at a distance of 2 grid steps from the current cell.\n\n\nThis snippet should allow the modeling of a dynamic grid in which food production and availability alter the appearance of each cell, and neighboring relationships are established for further interactions in the simulation.\n",
        "output": "grid vegetation_cell width: 50 height: 50 neighbors: 4 {\n   float max_food <- 1.0;\n   float food_prod <- rnd(0.01);\n   float food <- rnd(1.0) max: max_food update: food + food_prod;\n   rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n   list<vegetation_cell> neighbors2  <- (self neighbors_at 2);\n}\n"
    },
    {
        "instruction": "Generate an experiment displaying a chart in a new display called display_chart to follow the evolution of the number of happy people, stored in the nb_happy_people global variable.\n",
        "output": "experiment main_xp type: gui {\n\t\/\/ parameter definition\n\t\n\toutput {\n\t\t\/\/ display monitor\n\t\tdisplay chart type:series {\n\t\t\tchart \"evolution of the number of happy people\" type: series{\n\t\t\t\tdata \"nb of happy people\" value: nb_happy_people color: #green;\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Create a specie RandomGuy that has attributes rouge, vert, bleu which is a random number between 0 and 255, a function that returns its location, a reflex that uses the function wander from the skill moving, an action goTo that go to a new location, and for drawing it in the display, create an aspect called base that draw it a cricle of color defined by the attributes rouge, vert, bleu.",
        "output": "species RandomGuy skills:[moving] {\n\t\n\n\tint rouge <- rnd(0,255);\n\tint bleu <- rnd(0,255);\n\tint vert <- rnd(0,255);\n\n\tpoint get_location {\n\t\treturn location;\n\t}\n\n    reflex move {\n        do wander;\n    }\n    \n    \n\t\n\taction goTo(point new_loc) {\n\t\tlocation <- new_loc;\n\t}\n\t\n    aspect base {\n    \tdraw circle(1) color:rgb(rouge,bleu,vert);\n    }\n    \n}"
    },
    {
        "instruction": "Build a GAML code snippet that constructs a species named `prey` with the following characteristics and rules:\n\n\n- Begin by setting up the `prey` species with a base size initialized to `1.0` and an assigned color of blue (`#blue`).\n- Declare a `float` attribute `max_energy`, which holds the maximum energy level for the prey, drawing its value from a global variable `prey_max_energy`.\n- Introduce a `float` attribute `max_transfer` representing the maximum amount of energy that can be transferred from food per time step, linked to the variable `prey_max_transfer`.\n- Define a `float` attribute `energy_consum` that specifies the rate of energy consumption by the prey, sourced from a variable `prey_energy_consum`.\n- Assign to the `prey` a home cell from the `vegetation_cell` grid using `one_of(vegetation_cell)` and store it in a variable named `my_cell`.\n- Set up an energy variable for the prey initialized with a random value up to `max_energy`, ensuring that it diminishes over time due to `energy_consum` and does not exceed `max_energy`.\n- Include an `init` block in which the prey\u2019s initial location is set to the location of `my_cell`.\n- Implement a `reflex` named `basic_move` allowing the prey to move to a random neighboring cell within a distance of 2 steps (`my_cell.neighbors2`), updating its location accordingly.\n- Create a `reflex` labeled `eat` that is executed when there is food available in `my_cell`. Within this reflex, define the energy transfer from the cell to the prey based on available food and `max_transfer`.\n- Add a `reflex` called `die` that triggers when the prey's energy level falls to zero or below, resulting in the prey\u2019s death (`do die`).\n- Design an `aspect` named `base` to visually represent the prey in the simulation environment. It should draw a circle using its `size` and `color` attributes.\n\n\nMake sure that the code allows for interactions between the `prey` and its environment, reflecting energy transfer dynamics and the ability to move and survive based on energy levels.",
        "output": "species prey {\n   float size <- 1.0;\n   rgb color <- #blue;\n   float max_energy <- prey_max_energy;\n   float max_transfer <- prey_max_transfer;\n   float energy_consum <- prey_energy_consum;\n      \n   vegetation_cell my_cell <- one_of(vegetation_cell);\n   float energy <- rnd(max_energy) update: energy - energy_consum max: max_energy;\n  \n   init {\n       location <- my_cell.location;\n   }\n\n\n   reflex basic_move {\n       my_cell <- one_of(my_cell.neighbors2);\n       location <- my_cell.location;\n   }\n\n\n   reflex eat when: my_cell.food > 0 {\n       float energy_transfer <- min([max_transfer, my_cell.food]);\n       my_cell.food <- my_cell.food - energy_transfer;\n       energy <- energy + energy_transfer;\n   }\n\n\n   reflex die when: energy <= 0 {\n       do die;\n   }\n\n\n   aspect base {\n       draw circle(size) color: color;\n   }\n}\n"
    },
    {
        "instruction": "Create an empty list with 10 elements where each element has a value of 0.",
        "output": "list list_of_size_10_with_0 <- list_with(10, 0);"
    },
    {
        "instruction": "Develop a GAML code snippet that configures a grid representing vegetation cells. Detail the grid's properties and the internal attributes of the cells as follows:\n\n\n- Define the grid with the name `vegetation_cell` and set its size to a width of 50 and a height of 50 cells. Specify that each cell should consider 4 neighbors.\n- Inside the `vegetation_cell` species, declare a constant `float` variable `max_food` with a value of `1.0`.\n- Generate an initial `float` variable `food_prod` to represent food production, assigning it a random value up to `0.01`.\n- Establish a `float` variable `food`, representing the amount of food available in the vegetation cell, with a random initial value up to `1.0`. Ensure that this value cannot exceed `max_food` and is set to increment by `food_prod` at every update.\n- Create an `rgb` type variable `color` that reflects the food availability in the cell. The red and blue components of the RGB color should inversely correlate with the `food` variable (i.e., lower food leads to higher red and blue values), while the green component remains constant at `255`. Update this color to reflect changes in the food variable dynamically.\n- Define a list of `vegetation_cell` type named `neighbors2`. This list should be populated with neighboring cells at a distance of 2 grid steps from the current cell.\n\n\nThis snippet should allow the modeling of a dynamic grid in which food production and availability alter the appearance of each cell, and neighboring relationships are established for further interactions in the simulation.\n",
        "output": "grid vegetation_cell width: 50 height: 50 neighbors: 4 {\n   float max_food <- 1.0;\n   float food_prod <- rnd(0.01);\n   float food <- rnd(1.0) max: max_food update: food + food_prod;\n   rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)));\n   list<vegetation_cell> neighbors2  <- (self neighbors_at 2);\n}\n"
    },
    {
        "instruction": "Generate GAML code to create a grid with cells of width and height set to 100 units. Inside each cell, generate a random float value 'grid_value' using the 'rnd' function based on the distance from the cell to the world location. Calculate an RGB color 'color' using the random value, where the red component is determined by scaling 'grid_value' within the range [0, 100].",
        "output": "grid cell width: 100 height: 100 {\n\tfloat grid_value <- rnd(1.0,self distance_to world.location);\n\trgb color <- rgb(255 * (1 - grid_value \/ 100), 0,0);\n}"
    },
    {
        "instruction": "Create a complete model that shows the evacuation of human agents indoors towards an exit. The agents will be moving in discretised 3D space, avoid the barriers (walls), and should not overlap with one another.",
        "output": "model evacuationgoto\n\nglobal {\n\t\/\/Shapefile of the walls\n\tfile wall_shapefile <- shape_file(\"..\/includes\/walls.shp\");\n\t\/\/Shapefile of the exit\n\tfile exit_shapefile <- shape_file(\"..\/includes\/exit.shp\");\n\t\/\/DImension of the grid agent\n\tint nb_cols <- 50;\n\tint nb_rows <- 50;\n\t\n\t\/\/Shape of the world initialized as the bounding box around the walls\n\tgeometry shape <- envelope(wall_shapefile);\n\t\n\tinit {\n\t\t\/\/Creation of the wall and initialization of the cell is_wall attribute\n\t\tcreate wall from: wall_shapefile {\n\t\t\task cell overlapping self {\n\t\t\t\tis_wall <- true;\n\t\t\t}\n\t\t}\n\t\t\/\/Creation of the exit and initialization of the cell is_exit attribute\n\t\tcreate exit from: exit_shapefile {\n\t\t\task (cell overlapping self) where not each.is_wall{\n\t\t\t\tis_exit <- true;\n\t\t\t}\n\t\t}\n\t\t\/\/Creation of the people agent\n\t\tcreate people number: 50{\n\t\t\t\/\/People agent are placed randomly among cells which aren't wall\n\t\t\tlocation <- one_of(cell where not each.is_wall).location;\n\t\t\t\/\/Target of the people agent is one of the possible exits\n\t\t\ttarget <- one_of(cell where each.is_exit).location;\n\t\t}\n\t}\n}\n\/\/Grid species to discretize space\ngrid cell width: nb_cols height: nb_rows neighbors: 8 {\n\tbool is_wall <- false;\n\tbool is_exit <- false;\n\trgb color <- #white;\t\n}\n\/\/Species exit which represent the exit\nspecies exit {\n\taspect default {\n\t\tdraw shape color: #blue;\n\t}\n}\n\/\/Species which represent the wall\nspecies wall {\n\taspect default {\n\t\tdraw shape color: #black depth: 10;\n\t}\n}\n\/\/Species which represent the people moving from their location to an exit using the skill moving\nspecies people skills: [moving]{\n\t\/\/Evacuation point\n\tpoint target;\n\trgb color <- rnd_color(255);\n\t\n\t\/\/Reflex to move the agent \n\treflex move {\n\t\t\/\/Make the agent move only on cell without walls\n\t\tdo goto target: target speed: 1.0 on: (cell where not each.is_wall) recompute_path: false;\n\t\t\/\/If the agent is close enough to the exit, it dies\n\t\tif (self distance_to target) < 2.0 {\n\t\t\tdo die;\n\t\t}\n\t}\n\taspect default {\n\t\tdraw pyramid(2.5) color: color;\n\t\tdraw sphere(1) at: {location.x,location.y,2} color: color;\n\t}\n}\nexperiment evacuationgoto type: gui {\n\tfloat minimum_cycle_duration <- 0.04; \n\toutput {\n\t\tdisplay map type: 3d axes:false{\n\t\t\timage \"..\/images\/floor.jpg\";\n\t\t\tspecies wall refresh: false;\n\t\t\tspecies exit refresh: false;\n\t\t\tspecies people;\n\t\t\t\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Draft a GAML code snippet to generate a visually appealing histogram-type bar chart with the following specifications:\n\n\n- Begin by setting up a `display` with the identifier `nice_bar_chart` configured to render in 2D.\n- Inside this display, establish a chart titled \"Nice Cumulative Bar Chart\". This chart should be defined with a histogram type.\n- Set the background color to dark blue (`#darkblue`) and the color for bars to light green (`#lightgreen`).\n- Define the chart axes color to also be light green (`#lightgreen`).\n- Customize the font settings for various elements of the chart:\n - Set the title font to 'Serif', with a size of 32.0 and style `italic`.\n - Configure the tick font to 'Monospaced', size 14, with a `bold` emphasis.\n - Assign the label font to 'Arial', size 18, and also `bold`.\n - For the legend, choose 'SanSerif', size 14, and style it `bold`.\n- Control the vertical range of the chart (`y_range`) to be between -20 and 40.\n- Determine the vertical axis tick unit (`y_tick_unit`) to be 10.\n- Label the horizontal axis as 'Nice Xlabel' and the vertical axis as 'Nice Ylabel'.\n- Include within the chart definition, the following three datasets with individual characteristics:\n - Dataset \"BCC\" should graph values using `10*cos(100*cycle)` and present a cumulative pattern (accumulate_values set to true). Employ a stacking style (`style:stack`) and color the bars yellow (`#yellow`).\n - Dataset \"ABC\" should plot values via `10*sin(100*cycle)` also in a stacked, cumulative fashion. Match the color of bars to blue (`#blue`).\n - Dataset \"BCD\" should represent values based on `(cycle mod 10)` and follow the same accumulation and stacking settings. Additionally, designate `marker_circle` as the marker shape used for this data.\n\n\nEnsure the snippet generates an interactive and cumulative bar chart where the data dynamically accumulates over simulation cycles and the aesthetic choices deliver a \"nice\" thematic look.\n",
        "output": "display \"nice_bar_chart\"  type: 2d {\n   chart \"Nice Cumulative Bar Chart\" type:histogram\n       background: #darkblue\n       color: #lightgreen\n       axes: #lightgreen\n       title_font: font('Serif', 32.0, #italic)\n       tick_font: font('Monospaced', 14, #bold)\n       label_font: font('Arial', 18, #bold)\n       legend_font: font('SanSerif', 14, #bold)\n       y_range:[-20,40]\n       y_tick_unit:10\n       x_label:'Nice Xlabel'\n       y_label:'Nice Ylabel'\n       {\n       data \"BCC\" value:10*cos(100*cycle)\n           accumulate_values: true                    \n           style:stack\n           color:#yellow;\n       data \"ABC\" value:10*sin(100*cycle)\n           accumulate_values: true                    \n           style: stack\n           color:#blue;\n       data \"BCD\" value:(cycle mod 10)\n           accumulate_values: true                    \n           style: stack \n           marker_shape:marker_circle ;\n   }\n}\n"
    },
    {
        "instruction": "Create a complete model that represents how the K Nearest Neighbors Algorithm work. Whenever the user click on any location, a point will be generated and its color will be based on the colors of its k-nearest points. The user can also let the point generated dynamically and the colors of these points will also based on the colors of their k-nearest points.",
        "output": "model KNearestNeighbors\n\n\nglobal {\n\n\tmap<unknown, unknown> store;\n\tlist<rgb> colour <- [#red, #blue, #green, #yellow, #purple, #orange, #pink, #magenta, #cyan];\n    int init_amount <- 10;\n    int nb_group <- 2;\n    float radius <- 10.0;\n    int k <- 10;\n\tinit {\n\t\tloop i from: 0 to: nb_group - 1{\n\t\t\tspecial_point center;\n\t\t\tcreate special_point{\n\t\t\t\tcolor <- colour[i];\n\t\t\t\tcenter <- self;\n\t\t\t}\n\t\t\tgeometry around <- circle(radius, center.location) intersection world.shape;\n\t\t\tcreate special_point number: init_amount - 1{\n\t\t\t\tlocation <- any_location_in(around);\n\t\t\t\tcolor <- center.color;\n\t\t\t}\n\t\t}\n\t\tstore <- world.special_point as_map (each::each.color);\n\t}\n\n\taction createAgent{\n\t    create special_point{\n\t    \tlocation <- #user_location;\n\t    \tcolor <- self k_nearest_neighbors (store, k);\n\t\t    store <+ (self::color);\n\t    }\n\t}\n\n\treflex auto{\n\t\tcreate special_point{\n\t   \t\tcolor <- self k_nearest_neighbors (store, k);\n\t   \t\tstore <+ self::color;\n\t   \t}\n\t}\n}\n\nspecies special_point {\n\tfloat size <- 0.5;\n\trgb color;\n\taspect base{\n\t\tdraw circle(size) color:color;\n\t}\n\t\n}\n\nexperiment demo {\n\tparameter \"Number of groups: \" var:nb_group min: 2 max: 9;\n\tparameter \"Radius: \" var: radius min:10.0 max:30.0;\n\tparameter \"Initial numbers of agent for each group: \" var:init_amount min:1 max:50;\n\tparameter \"Number of neighbours considered (K)\" var:k min:1;\n\toutput {\n\t\tdisplay main {\n\t\t\tspecies special_point aspect: base;\n\t\t\tevent #mouse_down {ask simulation {do createAgent;}} \n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Generate a model containing a 900 square spatial units (named plot and organized as a grid) containing a wild cabbage biomass. \nThe carrying capacity of each plot is a random value between 10 and 0 biomass.  \nInitially, the cabbages biomass is random between 0 and the local carrying capacity.\nWild cabbage biomass grows with a logistic function with a growth rate equal to 0,2.\nDisplay the maps of biomass and of carrying capacity.",
        "output": "model cabbages\n\nglobal {\n\n\tfloat growth_rate <- 0.2 ;\n\tfloat max_carrying_capacity <- 10.0;\n\n}\n\ngrid plot height: 30 width: 30 neighbors: 8 {\n\n\tfloat biomass;\n\tfloat carrying_capacity;\n\trgb color <- rgb(0,255*biomass\/max_carrying_capacity,0)\n\t\tupdate: rgb(0,255*biomass\/max_carrying_capacity,0);\t\t\n\t\n\tinit {\t\t\n\t\tcarrying_capacity <- rnd(max_carrying_capacity);\t\t\n\t\tbiomass <- rnd(carrying_capacity);\n\t\tcolor <-  rgb(0,255*biomass\/max_carrying_capacity,0);\t\n\t}\t\n\t\n\treflex grow {\n\t\tif(carrying_capacity != 0){\n\t\t\tbiomass <- biomass * (1 + growth_rate * (1 - biomass\/carrying_capacity));\t\n\t\t}\n\t}\n}\n\n\nexperiment cabbagesExp type: gui {\n\toutput {\n\t\tdisplay biomass {\n\t\t\tgrid plot border: #black;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Create a species called equipped with the ability to move in a 3D environment. The cell has a built-in reflex named \"move\" that triggers the actual movement action at each step.",
        "output": "species movingAgent skills: [moving3D] {\n\treflex move {\n\t\tdo move;\n\t}\n}"
    },
    {
        "instruction": "Create a GAML model that simulates a world with buildings. Each building has to be created from a shape file 'buildings.shp'. Each building have an in-built attributes called 'height' that represents the height of the building",
        "output": "init\n{\n  file buildings_shapefile <- file(\"building.shp\");\n  create building from: buildings_shapefile;\n}\n\nspecies building {\n\tfloat height <- rnd(10#m, 20#m) ;\n}"
    },
    {
        "instruction": "Import common shelling segregation gaml into current model.",
        "output": "import \"..\/includes\/Common Schelling Segregation.gaml\""
    },
    {
        "instruction": "Create a list named list list_of_size_10_with_0 with 10 elements with initial values of 0.",
        "output": "list list_of_size_10_with_0 <- list_with(10, 0);"
    },
    {
        "instruction": "Create a GAML code snippet for a model named \"NewModel\" that incorporates the following components and directives:\n\n\n- Declare a global species to define global variables and initialization processes.\n - Within the global scope, initialize an integer variable `number_of_agents` and set its value to `5`.\n - In the global `init` component, write the directive to create `number_of_agents` instances of a species named `my_node`.\n - Define a new species called `my_node` which inherits from a `graph_node` and is linked by an edge species named `edge_agent`.\n - Equipped the `my_node` species with a method called `related_to` that takes another `my_node` as a parameter and always returns `true`, indicating a relationship.\n - Provide the visual representation (aspect) for `my_node` species:\n - Include an `aspect` named `base` that instructs how to draw the node as a green circle with a radius of `1`.\n\n\n- Declare a second species named `edge_agent` as a child of `base_edge`.\n - For `edge_agent`, define an `aspect` also called `base` which sets the visualization guidelines to draw the agent with a blue shape.\n - Set up an experiment called `MyExperiment` of type `gui`.\n - Within the experiment, configure an output section that includes a display named `MyDisplay` using `java2D`.\n   - Ensure the display shows species `my_node` using their defined `base` aspect.\n   - Also, instruct the display to represent species `edge_agent` using its `base` aspect.\n\n\nMake sure the code encompasses the setup of networked agents interacting in a defined space and visibly represented in a two-dimensional Java-based simulation environment.\n",
        "output": "model NewModel\n\n\nglobal {\n   int number_of_agents <- 5;\n\n\n   init {\n   create my_node number: number_of_agents;\n   }\n}\n\n\nspecies my_node parent: graph_node edge_species: edge_agent {\n   bool related_to (my_node other) {\n   return true;\n   }\n\n\n   aspect base {\n   draw circle(1) color: #green;\n   }\n}\n\n\nspecies edge_agent parent: base_edge {\n   aspect base {\n   draw shape color: #blue;\n   }\n}\n\n\nexperiment MyExperiment type: gui {\n   output {\n   display MyDisplay type: java2D {\n       species my_node aspect: base;\n       species edge_agent aspect: base;\n   }\n   }\n}\n"
    },
    {
        "instruction": "Create a complete Schelling segregation model using gis data.",
        "output": "model segregation\n\n\/\/Import the model Common Schelling Segregation\nimport \"..\/includes\/Common Schelling Segregation.gaml\" \nglobal {\n\t\/\/List of all the free places\n\tlist<space> free_places  ;  \n\t\/\/List of all the places\n\tlist<space> all_places ;\n\t\/\/Neighbours distance for the perception of an agent\n\tint neighbours_distance <- 50 min: 1 parameter: \"Distance of perception:\" category: \"Population\" max: 1000;\n\t\/\/Shapefile to load\n\tfile shape_file_name <- file(\"..\/gis\/nha2.shp\") parameter: \"Shapefile to load:\" category: \"GIS specific\";\n\t\/\/Shape of the environment\n\tgeometry shape <- envelope(shape_file_name);\n\t\/\/Square meters per people in m2\n\tint square_meters_per_people <- 200 parameter: \"Occupancy of people (in m2):\" category: \"GIS specific\";\n\t\n\t\/\/Action to initialize people agents\n\taction initialize_people { \n\t\t\/\/Create all the places with a surface given within the shapefile\n\t\tcreate space from: shape_file_name with: [surface :: float(read(\"AREA\"))];\n\t\tall_places  <- shuffle(space);\n\t\t\/\/Compute the number of people to create considering the density of people\n\t\tnumber_of_people <- int( density_of_people * sum (all_places collect (each.capacity))); \n\t\tcreate people number: number_of_people;  \n\t    all_people <- people as list ; \n\t    \/\/Move all the people to a new place\n\t\task people  {  \n\t\t\tdo move_to_new_place;       \n\t\t}   \n\t}      \n\t\/\/Action to initialize the places\n\taction initialize_places {}   \n\t\n} \n\n\/\/Species people representing the people\nspecies people parent: base { \n\t\/\/Size of the people agent\n\tfloat size const: true <- 2.0;\n\t\/\/Color of the people agent  \n\trgb color const: true <- colors at (rnd (number_of_groups - 1)); \n\tint red const: true <- (color as list) at 0; \n\tint green const: true <- (color as list) at 1;  \n\tint blue const: true <- (color as list) at 2;  \n\t\/\/Building in which the agent lives\n\tspace current_building <- nil;\n\t\/\/List of all the neighbour people agents\n\tlist<people> my_neighbours -> people at_distance neighbours_distance; \n\t\n\t\/\/Action to move to a new place\n\taction move_to_new_place {  \n\t\tcurrent_building <- (shuffle(all_places) first_with (((each).capacity) > 0));\n\t\task current_building {\n\t\t\tdo accept one_people: myself;   \n\t\t}\n\t}\n\t\/\/Reflex to migrate to another place if the agent isn't happy\n\treflex migrate when: !is_happy {\n\t\tif current_building != nil {\n\t\t\task current_building { \n\t\t\t\tdo remove_one one_people: myself;\n\t\t\t}\n\t\t} \n\t\tdo move_to_new_place;\n\t}\n\n\taspect simple {\n\t\tdraw circle(5) color: color border: #black;\n\t}\n}\n\n\/\/Species space representing a space for a people agent to live in\nspecies space {\t\n\t\/\/List of all the people agents living within\n\tlist<people> insiders;\n\trgb color <- rgb(255, 255, 255); \n\t\/\/Surface of the place\n\tfloat surface;\n\t\/\/Capacity of the place\n\tint capacity  <- 1 + int(surface \/ square_meters_per_people);\n\t\n\t\/\/Action to accept a people agent  \n\taction accept (people one_people) {\n\t\tadd one_people to: insiders;\n\t\tlocation of one_people <- any_location_in(shape);\n\t\tcapacity <- capacity - 1;\n\t}\n\t\/\/Action to remove a people agent\n\taction remove_one (people one_people){\n\t\tremove one_people from: insiders;\n\t\tcapacity <- capacity + 1;\n\t}\n\taspect simple {\n\t\tcolor <- empty(insiders) ? #white : rgb ([mean (insiders collect each.red), mean (insiders collect each.green), mean (insiders collect each.blue)]);\n\t\tdraw  square(40) color: color;\n\t}\n\taspect gis {\n\t\tcolor <- empty(insiders) ? #white : rgb( [mean (insiders collect each.red), mean (insiders collect each.green), mean (insiders collect each.blue)]);\n\t\tdraw shape color: color border: #black;\n\t} \n\taspect highlighted {\n\t\tcolor <- #blue;\n\t\tdraw shape+10 color: color;\n\t}\n}\n\n\nexperiment schelling type: gui {\t\n\toutput {\n\t\tdisplay Town_display type:2d  {\n\t\t\tspecies space aspect: gis;\n\t\t\tspecies people  aspect: simple;\n\t\t}\n\t\tdisplay Charts  type: 2d {\n\t\t\tchart \"Proportion of happiness\" type: histogram background: #lightgray gap:0.05 position: {0,0} size: {1.0,0.5}{\n\t\t\t\tdata \"Unhappy\" value: number_of_people - sum_happy_people color: #green;\n\t\t\t\tdata \"Happy\" value: sum_happy_people color: #yellow ;\n\t\t\t}\n\t\t\tchart \"Global happiness and similarity\" type: series background: #lightgray axes: #white position: {0,0.5} size: {1.0,0.5} {\n\t\t\t\tdata \"happy\" color: #blue value:  ((sum_happy_people * 100) \/ number_of_people)  style: spline ;\n\t\t\t\tdata \"similarity\" color: #red value:  (sum_similar_neighbours \/ sum_total_neighbours) * 100 style: step ;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Create a complete model showing how to represent a flooding system with dykes and buildings. The model should use a grid to discretize space, and will have a 3D display. The water can flow from one cell to another considering the height of the cells, and the water pressure. It is also possible to delete dyke by clicking on one of them in the display.",
        "output": "model hydro\n\nglobal {\n\t\n   \/\/Shapefile for the river\n   file river_shapefile <- file(\"..\/includes\/RedRiver.shp\");\n   \/\/Shapefile for the dykes\n   file dykes_shapefile <- file(\"..\/includes\/Dykes.shp\");\n   \/\/Shapefile for the buildings\n   file buildings_shapefile <- file(\"..\/includes\/Building.shp\");\n   \n   \/\/Data elevation file\n   file dem_file <- file(\"..\/includes\/mnt50.asc\");  \n   \/\/Diffusion rate\n   float diffusion_rate <- 0.6;\n   \/\/Height of the dykes\n   float dyke_height <- 15.0;\n   \/\/Width of the dyke\n   float dyke_width <- 15.0;\n    \n   \/\/Shape of the environment using the dem file\n   geometry shape <- envelope(dykes_shapefile);\n   \n   \/\/List of the drain and river cells\n   list<cell> drain_cells;\n   list<cell> river_cells;\n   \n   \n  \n   float step <- 1#h;\n   \n   init {\n   \t \/\/Initialization of the cells\n      do init_cells;\n     \/\/Initialization of the water cells\n      do init_water;\n     \/\/Initialization of the river cells\n     river_cells <- cell where (each.is_river);\n     \/\/Initialization of the drain cells\n      drain_cells <- cell where (each.is_drain);\n     \/\/Initialization of the obstacles (buildings and dykes)\n      do init_obstacles;\n      \/\/Set the height of each cell\n      ask cell {\n         obstacle_height <- compute_highest_obstacle();\n         do update_color;\n      }\n   }\n   \/\/Action to initialize the altitude value of the cell according to the dem file\n   action init_cells {\n      ask cell  {\n         altitude <- grid_value;\n         neighbour_cells <- (self neighbors_at 1) ;\n      }\n   }\n   \/\/action to initialize the water cells according to the river shape file and the drain\n   action init_water {\n      geometry river <- geometry(river_shapefile);\n      ask cell overlapping river  {\n         water_height <- 10.0;\n         is_river <- true;\n         is_drain <- grid_y = matrix(cell).rows - 1;\n      }\n   }\n   \/\/initialization of the obstacles (the buildings and the dykes)\n   action init_obstacles{\n      create buildings from: buildings_shapefile  {\n         do update_cells;\n      }\n      create dyke from: dykes_shapefile;\n      ask dyke  {\n          shape <-  shape + dyke_width;\n            do update_cells;\n      }\n   }\n   \/\/Reflex to add water among the water cells\n   reflex adding_input_water {\n   \t  float water_input <- rnd(100)\/100;\n      ask river_cells {\n         water_height <- water_height + water_input;\n      }\n   }\n   \/\/Reflex to flow the water according to the altitute and the obstacle\n   reflex flowing {\n      ask (cell sort_by ((each.altitude + each.water_height + each.obstacle_height))) {\n      \talready <- false;\n         do flow;\n      }\n   }\n   \/\/Reflex to update the color of the cell\n   reflex update_cell_color {\n      ask cell  {\n         do update_color;\n      }\n   }\n   \/\/Reflex for the drain cells to drain water\n   reflex draining {\n      ask drain_cells {\n         water_height <- 0.0;\n      }\n   }\n   \n}\n\/\/Species which represent the obstacle\n   species obstacle  {\n   \t  \/\/height of the obstacle\n      float height min: 0.0;\n      \/\/Color of the obstacle\n      rgb color;\n      \/\/Pressure of the water\n      float water_pressure update: compute_water_pressure();\n      \n      \/\/List of cells concerned\n      list<cell> cells_concerned ;\n      \/\/List of cells in the neighbourhood \n      list<cell> cells_neighbours;\n      \n      \/\/Action to compute the water pressure\n      float compute_water_pressure {\n      \t\/\/If the obstacle doesn't have height, then there will be no pressure\n         if (height = 0.0) {\n            return 0.0;\n         } else {\n         \t\/\/The leve of the water is equals to the maximul level of water in the neighbours cells\n            float water_level <- cells_neighbours max_of (each.water_height);\n            \/\/Return the water pressure as the minimal value between 1 and the water level divided by the height\n            return min([1.0,water_level \/ height]);\n         } \n      }\n      \n      \/\/Action to update the cells\n      action update_cells {\n      \t\/\/All the cells concerned by the obstacle are the ones overlapping the obstacle\n         cells_concerned <- (cell overlapping self);\n        \task cells_concerned {\n        \t\/\/Add the obstacles to the obstacles of the cell\n            add myself to: obstacles;\n            water_height <- 0.0;\n         }\n         \/\/Cells neighbours are all the neighbours cells of the cells concerned\n         cells_neighbours <- cells_concerned + cells_concerned accumulate (each.neighbour_cells);\n         \/\/The height is now computed\n      \t do compute_height();\n         if (height > 0.0) {   \n         \t\/\/We compute the water pressure again\n            water_pressure <- compute_water_pressure();\n         } else {water_pressure <- 0.0;}\n      }\n      action compute_height;\n      aspect geometry {\n         int val <- int( 255 * water_pressure);\n         color <- rgb(val,255-val,0);\n         draw shape color: color depth: height*5 border: color;\n      }\n   }\n   \/\/Species buildings which is derivated from obstacle\n   species buildings parent: obstacle schedules: [] {\n   \t \/\/The building has a height randomly chosed between 2 and 10\n      float height <- 2.0 + rnd(8);\n   }\n   \/\/Species dyke which is derivated from obstacle\n   species dyke parent: obstacle {\n   \t\n       int counter_wp <- 0;\n       int breaking_threshold <- 24;\n      \n      \/\/Action to represent the break of the dyke\n       action break{\n         ask cells_concerned  {\n            do update_after_destruction(myself);\n         }\n         do die;\n      }\n      \/\/Action to compute the height of the dyke as the dyke_height without the mean height of the cells it overlaps\n      action compute_height\n       {\n      \t   height <- dyke_height - mean(cells_concerned collect (each.altitude));\n      \n      }\n      \n      \/\/Reflex to break the dynamic of the water\n      reflex breaking_dynamic {\n      \tif (water_pressure = 1.0) {\n      \t\tcounter_wp <- counter_wp + 1;\n      \t\tif (counter_wp > breaking_threshold) {\n      \t\t\tdo break;\n      \t\t}\n      \t} else {\n      \t\tcounter_wp <- 0;\n      \t}\n      }\n      \/\/user command which allows the possibility to destroy the dyke for the user\n      user_command \"Destroy dyke\" action: break; \n   }\n   \/\/Grid cell to discretize space, initialized using the dem file\n   grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false schedules: []  {\n      \/\/Altitude of the cell\n      float altitude;\n      \/\/Height of the water in the cell\n      float water_height <- 0.0 min: 0.0;\n      \/\/Height of the cell\n      float height;\n      \/\/List of the neighbour cells\n      list<cell> neighbour_cells ;\n      \/\/Boolean to know if it is a drain cell\n      bool is_drain <- false;\n      \/\/Boolean to know if it is a river cell\n      bool is_river <- false;\n      \/\/List of all the obstacles overlapping the cell\n      list<obstacle> obstacles;\n      \/\/Height of the obstacles\n      float obstacle_height <- 0.0;\n      bool already <- false;\n      \n      \/\/Action to compute the highest obstacle among the obstacles\n      float compute_highest_obstacle {\n         if (empty(obstacles))\n         {\n            return 0.0; \n         } else {\n            return obstacles max_of(each.height);\n         }\n      }\n      \/\/Action to flow the water \n      action flow {\n      \t\/\/if the height of the water is higher than 0 then, it can flow among the neighbour cells\n         if (water_height > 0) {\n         \t\/\/We get all the cells already done\n            list<cell> neighbour_cells_al <- neighbour_cells where (each.already);\n            \/\/If there are cells already done then we continue\n            if (!empty(neighbour_cells_al)) {\n               \/\/We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height\n               ask neighbour_cells_al {height <- altitude + water_height + obstacle_height;}\n               \/\/The height of the cell is equals to its altitude and water height\n               height <-  altitude +  water_height;\n               \/\/The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell\n               list<cell> flow_cells <- (neighbour_cells_al where (height > each.height)) ;\n               \/\/If there are cells, we compute the water flowing\n               if (!empty(flow_cells)) {\n                  loop flow_cell over: shuffle(flow_cells) sort_by (each.height){\n                     float water_flowing <- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]); \n                     water_height <- water_height - water_flowing;\n                     flow_cell.water_height <-flow_cell.water_height +  water_flowing;\n                     height <- altitude + water_height;\n                  }   \n               }\n            }\n         }\n         already <- true;\n      }  \n      \/\/Update the color of the cell\n      action update_color { \n         int val_water <- 0;\n         val_water <- max([0, min([255, int(255 * (1 - (water_height \/ 12.0)))])]) ;  \n         color <- rgb([val_water, val_water, 255]);\n         grid_value <- water_height + altitude;\n      }\n      \/\/action to compute the destruction of the obstacle\n      action update_after_destruction(obstacle the_obstacle){\n         remove the_obstacle from: obstacles;\n         obstacle_height <- compute_highest_obstacle();\n      }\n       \n   }\n\n\nexperiment Run type: gui {\n   parameter \"Shapefile for the river\" var:river_shapefile category:\"Water data\";\n   parameter \"Shapefile for the dykes\" var:dykes_shapefile category:\"Obstacles\";\n   parameter \"Shapefile for the buildings\" var:buildings_shapefile category:\"Obstacles\";\n   parameter \"Height of the dykes\" var:dyke_height category:\"Obstacles\";\n   parameter \"Diffusion rate\" var:diffusion_rate category:\"Water dynamic\";\n   output { \n   \/\/layout vertical([0::5000,1::5000]) tabs:false editors: false;\n      display map type: 3d {\n         grid cell triangulation: true;\n         species buildings aspect: geometry refresh: false;\n         species dyke aspect: geometry ;\n      }\n      display chart_display refresh: every(24#cycles)  type: 2d  { \n         chart \"Pressure on Dykes\" type: series legend_font: font(\"Helvetica\", 18)  label_font: font(\"Helvetica\", 20, #bold)  title_font: font(\"Helvetica\", 24, #bold){\n            data \"Mean pressure on dykes \" value: mean(dyke collect (each.water_pressure)) style: line color: #magenta  ;\n            data \"Rate of dykes with max pressure\" value: (dyke count (each.water_pressure = 1.0))\/ length(dyke) style: line color: #red ;\n            data \"Rate of dykes with high pressure\" value: (dyke count (each.water_pressure > 0.5))\/ length(dyke) style: line color: #orange ;\n            data \"Rate of dykes with low pressure\" value: (dyke count (each.water_pressure < 0.25))\/ length(dyke) style: line color: #green ;\n         }\n      }\n   }\n}"
    },
    {
        "instruction": "Create a complete simple SI model without Ordinary Differential Equations showing agents moving randomly among a grid and becoming infected.",
        "output": "model si\n\nglobal { \n\t\n    int number_S <- 495;  \/\/ The number of susceptible\n    int number_I <- 5 ;\t\/\/ The number of infected\n    float survivalProbability <- 1\/(70*365) ; \/\/ The survival probability\n\tfloat beta <- 0.05 ; \t\/\/ The parameter Beta\n\tfloat nu <- 0.001 ;\t\/\/ The parameter Nu\n\tint numberHosts <- number_S+number_I; \/\/Total number of hosts\n\tbool local_infection <- true ; \/\/Infection spread locally or not\n\tint neighbours_size <- 2 ; \/\/Size of the neighbourhood\n\tgeometry shape <- square(50);\n\tinit { \n\t\t\/\/Creation of all the susceptible hosts\n\t\tcreate Host number: number_S {\n        \tis_susceptible <- true;\n        \tis_infected <-  false;\n            is_immune <-  false; \n            color <-  rgb(46,204,113);\n        }\n        \/\/Creation of all the infected hosts\n        create Host number: number_I {\n            is_susceptible <-  false; \n            is_infected <-  true;\n            is_immune <-  false; \n            color <-  rgb(231,76,60);  \n       }\n   }\n   \/\/Reflex to update the number of infected hosts\n   reflex compute_nb_infected {\n   \t\tnumber_I <- Host count (each.is_infected);\n   }  \n}\n\n\/\/Grid to discretize space\ngrid si_grid width: 50 height: 50 use_individual_shapes: false use_regular_agents: false frequency: 0{\n\trgb color <- #white;\n\tlist<si_grid> neighbours <- (self neighbors_at neighbours_size) ;       \n}\n\/\/Species host which represent the possible hosts of a disease\nspecies Host  {\n\t\/\/Booleans to represent the state of the agent\n\tbool is_susceptible <- true;\n\tbool is_infected <- false;\n    bool is_immune <- false;\n    rgb color <- rgb(46,204,113);\n    int sic_count <- 0;\n    si_grid myPlace;\n    \n    \/\/The agent is placed randomly among the grid\n    init {\n    \tmyPlace <- one_of (si_grid as list);\n    \tlocation <- myPlace.location;\n    }        \n    \/\/Reflex to move the agents in its neighbourhood\n    reflex basic_move {\n    \tmyPlace <- one_of (myPlace.neighbours) ;\n        location <- myPlace.location;\n    }\n    \/\/Reflex to infect the agent if it is susceptible and according to the other infected agents\n    reflex become_infected when: is_susceptible {\n    \tfloat rate <- 0.0;\n    \tif(local_infection) {\n    \t\tint nb_hosts <- 0;\n    \t\tint nb_hosts_infected <- 0;\n    \t\tloop hst over: ((myPlace.neighbours + myPlace) accumulate (Host overlapping each)) {\n    \t\t\tnb_hosts <- nb_hosts + 1;\n    \t\t\tif (hst.is_infected) {\n    \t\t\t\tnb_hosts_infected <- nb_hosts_infected + 1;\n    \t\t\t}\n    \t\t}\n    \t\trate <- nb_hosts_infected \/ nb_hosts;\n    \t} else {\n    \t\trate <- number_I \/ numberHosts;\n    \t}\n    \tif (flip(beta * rate)) {\n        \tis_susceptible <-  false;\n            is_infected <-  true;\n            is_immune <-  false;\n            color <-  rgb(231,76,60);    \n        }\n    }\n    \/\/Reflex to kill the agent according to the death rate\n    reflex shallDie when: flip(nu) {\n\t\tcreate species(self) {\n\t\t\tmyPlace <- myself.myPlace ;\n\t\t\tlocation <- myself.location ; \n\t\t}\n       \tdo die;\n    }\n            \n    aspect basic {\n        draw circle(1) color: color; \n    }\n}\n\n\nexperiment Simulation type: gui { \n \tparameter \"Number of Susceptible\" var: number_S ;\/\/ The number of susceptible\n    parameter \"Number of Infected\" var: number_I ;\t\/\/ The number of infected\n    parameter \"Survival Probability\" var: survivalProbability ; \/\/ The survival probability\n\tparameter \"Beta (S->I)\" var:beta; \t\/\/ The parameter Beta\n\tparameter \"Mortality\" var:nu ;\t\/\/ The parameter Nu\n\tparameter \"Is the infection is computed locally?\" var:local_infection ;\n\tparameter \"Size of the neighbours\" var:neighbours_size ;\n\t\n \toutput {\n \t\tlayout #split; \n\t    display si_display  type:2d antialias:false{\n\t        grid si_grid border: #lightgray;\n\t        species Host aspect: basic;\n\t    }\n\t        \n\t    display chart refresh: every(10#cycles)  type: 2d  {\n\t\t\tchart \"Susceptible\" type: series background: #white style: exploded {\n\t\t\t\tdata \"susceptible\" value: Host count (each.is_susceptible) color: rgb(46,204,113);\n\t\t\t\tdata \"infected\" value: Host count (each.is_infected) color: rgb(231,76,60);\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n}"
    },
    {
        "instruction": "Create a generic species with moving skill.",
        "output": "species generic_species skills: [moving]\n{\n\tfloat speed <- 1.0;\n\tpoint goal;\n\tbool is_chased <- false;\n\treflex live_with_my_goal\n\t{\n\t\tif (goal != nil)\n\t\t{\n\t\t\tdo wander speed: speed;\n\t\t\tdo goto target: goal speed: speed;\n\t\t} else\n\t\t{\n\t\t\tdo wander speed: speed;\n\t\t}\n\n\t}\n\n}"
    },
    {
        "instruction": "Given a field called \"heatmap\", create an experiment named \"Show heatmap\" with a gui type. Set up the output layout to split. Add a display named 'Other' of type 3D. Ensure that this display has a black background and is viewed from an upward-facing front camera angle. Visualize the heatmap data using a mesh. Use the 'Reds' color scheme from the Brewer colors palette. Ensure that the visualization accounts for the increasing values by enabling triangulation.",
        "output": "experiment \"Show heatmap\" type: gui {\n\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Other type: 3d background: #black camera: #from_up_front{\n\t\t\t\/\/ Bumps appear due to the values increasing\n\t\t\tmesh heatmap scale: 0.1 color: brewer_colors(\"Reds\") triangulation: true;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Create an empty list  only for integer values.",
        "output": "list<int> empty_list_of_int ;"
    },
    {
        "instruction": "Give a GAML code snippet that outlines a complex node system with specific behaviors, attributes, and visual markers as follows:\n\n\n- Begin by defining a species named `my_node`, which extends from `graph_node` and associates with an edge species `edge_agent`.\n- Introduce an integer attribute `status` within `my_node` with an initial value of `0`.\n- Declare a list of integers `list_connected_index` to store the indexes of connected nodes.\n\n\n- Inside the species, implement an `init` block where:\n - A loop iterates through each node of type `my_node`.\n - Within this loop, use the probabilistic `flip(0.1)` function to decide whether to link the current node with another by adding an index to `list_connected_index`.\n - Define a boolean method `related_to` that takes another `my_node` as a parameter and returns `true` if `list_connected_index` contains the index of `other` node.\n\n\n- Create an action `update_neighbors` that:\n - Gathers a list of neighboring nodes by invoking `my_graph neighbors_of (self)`.\n - Iterates over this list, setting each neighbor\u2019s `status` attribute to `1`.\n\n\n- Configure an `aspect` named `base` to visually represent the nodes based on their `status`:\n - If `status` equals `0`, draw a green circle with a black border.\n - If `status` equals `1`, draw a yellow circle with a black border.\n - If `status` equals `2`, draw a red circle with a black border.\n - Additionally, superimpose the degree of the node (from `my_graph`) as a black string on the visualization, adjusting the position relative to the node's location.\n - Reset the `status` to `0` at the end of the aspect, preparing it for the next cycle.\n\n\nEnsure the code effectively creates dynamic and interactive nodes that visually indicate their status and connectivity within a network structure, with the ability to be further manipulated or queried within the GAMA simulation environment.\n",
        "output": "species my_node parent: graph_node edge_species: edge_agent {\n   int status <- 0;\n   list<int> list_connected_index;\n  \n   init {\n   int i <- 0;\n   loop g over: my_node {\n       if (flip(0.1)) {\n       add i to:list_connected_index;\n       }\n       i <- i+1;\n   }\n   }\n  \n   bool related_to(my_node other){\n       if (list_connected_index contains (my_node index_of other)) {\n       return true;\n   }\n       return false;\n   }\n  \n   action update_neighbors {\n   list<my_node> list_neighbors <- my_graph neighbors_of (self);\n\n\n   loop neighb over: list_neighbors {\n       neighb.status <- 1;\n   }\n   }\n\n\n   aspect base {\n   if (status = 0) {\n       draw circle(2) color: #green border: #black;\n   } else if (status = 1) {\n       draw circle(2) color: #yellow border: #black;\n   } else if (status = 2) {\n       draw circle(2) color: #red border: #black;\n   }\n  \n       draw string(my_graph degree_of self) color: #black size: 4 at: {self.location.x-1, self.location.y-2};\n   status <- 0;\n   }\n}\n"
    },
    {
        "instruction": "How to project a point in WGS 84 projection ? ",
        "output": "point poi_location_WGS84 <- CRS_transform(poi_location, \"EPSG:4326\").location;"
    },
    {
        "instruction": "Create a complete model that shows the movement of boids following a goal, and creating a flock. In the experiment, the boids are dislayed in 3D and allows users to move the goal.",
        "output": "model boids \nglobal torus: torus_environment{ \n\t\/\/Number of boids that will be created\n\tint number_of_agents <- 50 min: 1 max: 500;\n\t\/\/Number of obstacles for the boids movement to represent\n\tint number_of_obstacles <- 0 min: 0;\n\t\/\/Maximal speed of the boids\n\tfloat maximal_speed <- 15.0 min: 0.1 max: 15.0;\n\t\/\/Factors for the group of boids\n\tint cohesion_factor <- 200;\n\tint alignment_factor <- 100; \n\t\/\/Variables for the movement of the boids\n\tfloat minimal_distance <- 30.0; \n\t\n\tint width_and_height_of_environment <- 1000;  \n\tbool torus_environment <- false; \n\tbool apply_cohesion <- true ;\n\tbool apply_alignment <- true ;\n\tbool apply_separation <- true;\n\tbool apply_avoid <- true;  \n\tbool apply_wind <- true;   \n\tbool moving_obstacles <- false;   \n\tint bounds <- int(width_and_height_of_environment \/ 20); \n\t\/\/Vector for the wind\n\tpoint wind_vector <- {0,0}; \n\tlist<image_file> images  <- [image_file('..\/images\/bird1.png'),image_file('..\/images\/bird2.png'),image_file('..\/images\/bird3.png')]; \n\tint xmin <- bounds;   \n\tint ymin <- bounds;  \n\tint xmax <- (width_and_height_of_environment - bounds);     \n\tint ymax <- (width_and_height_of_environment - bounds);   \n\t\n\t\/\/Action to move the goal to the mouse location\n\taction move_goal {\n\t\task first(boids_goal) {\n\t\t\tdo goto target: #user_location speed: 30.0;\n\t\t}\n\t}\n\t\n\tgeometry shape <- square(width_and_height_of_environment);\n\t\n\tinit { \n\t\t\/\/Create the boids agents\n\t\tcreate boids number: number_of_agents { \n\t\t\t location <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 };\n\t\t} \n\t\t\/\/Create the obstacles agents\n\t\tcreate obstacle number: number_of_obstacles {\n\t\t\tlocation <- {rnd (width_and_height_of_environment - 2) + 1, rnd (width_and_height_of_environment -2) + 1 }; \n\t\t}\n\t\t\/\/Create the goal that boids will follow\n\t\tcreate  boids_goal;\t\n\t}\t\n}\n\n\/\/Species boids goal which represents the goal that will be followed by boids agents using the skill moving\nspecies boids_goal skills: [moving] {\n\tfloat range  <- 20.0;\n\t\n\t\/\/If the mouse is not used, then the goal just wander\n\treflex wander {  \n\t\tdo  wander amplitude: 45.0 speed: 20.0;  \n\t}\n\t\n\taspect default {\n\t\tdraw circle(10) color: #red ;\n\t\tdraw circle(40) color: #orange wireframe: true;\n\t}\n} \n\/\/Species boids which represents the boids agents whom follow the boid goal agents, using the skill moving\nspecies boids skills: [moving] {\n\t\/\/Speed of the boids agents\n\tfloat speed max: maximal_speed <- maximal_speed;\n\t\/\/Range used to consider the group of the agent\n\tfloat range <- minimal_distance * 2;\n\tpoint velocity <- {0,0};\n\t\t\n\t\/\/Reflex used when the separation is applied to change the velocity of the boid\n\treflex separation when: apply_separation {\n\t\tpoint acc <- {0,0};\n\t\task (boids overlapping (circle(minimal_distance)))  {\n\t\t\tacc <- acc - ((location) - myself.location);\n\t\t}  \n\t\tvelocity <- velocity + acc;\n\t}\n\t\n\t\/\/Reflex to align the boid with the other boids in the range\n\treflex alignment when: apply_alignment {\n\t\tlist others  <- ((boids overlapping (circle (range)))  - self);\n\t\tpoint acc <- mean (others collect (each.velocity)) - velocity;\n\t\tvelocity <- velocity + (acc \/ alignment_factor);\n\t}\n\t \n\t\/\/Reflex to apply the cohesion of the boids group in the range of the agent\n\treflex cohesion when: apply_cohesion {\n\t\tlist others <- ((boids overlapping (circle (range)))  - self);\n\t\tpoint mass_center <- (length(others) > 0) ? mean (others collect (each.location)) : location;\n\n\t\tpoint acc <- mass_center - location;\n\t\tacc <- acc \/ cohesion_factor; \n\t\tvelocity <- velocity + acc;   \n\t}\n\t\n\t\/\/Reflex to avoid the obstacles\n\treflex avoid when: apply_avoid { \n\t\tpoint acc <- {0,0};\n\t\tlist<obstacle> nearby_obstacles <- (obstacle overlapping (circle (range)) );\n\t\tloop obs over: nearby_obstacles {\n\t\t\tacc <- acc - ((location of obs) - my (location));\n\t\t}\n\t\tvelocity <- velocity + acc; \n\t}\n\t\n\t\/\/action to represent the bounding of the environment considering the velocity of the boid\n\taction bounding {\n\t\tif  !(torus_environment) {\n\t\t\tif  (location.x) < xmin {\n\t\t\t\tvelocity <- velocity + {bounds,0};\n\t\t\t} else if (location.x) > xmax {\n\t\t\t\tvelocity <- velocity - {bounds,0};\n\t\t\t}\n\t\t\t\n\t\t\tif (location.y) < ymin {\n\t\t\t\tvelocity <- velocity + {0,bounds};\n\t\t\t} else if (location.y) > ymax {\n\t\t\t\tvelocity <- velocity - {0,bounds};\n\t\t\t}\n\t\t} else {\n\t\t\tif (location.x) < 0.0 {\n\t\t\t\tlocation <- {width_and_height_of_environment + location.x,location.y};\n\t\t\t} else if (location.x) > width_and_height_of_environment {\n\t\t\t\tlocation <- {location.x - width_and_height_of_environment ,location.y};\n\t\t\t}\n\t\t\t\n\t\t\tif (location.y) < 0.0 {\n\t\t\t\tlocation <- {location.x, width_and_height_of_environment + location.y};\n\t\t\t} else if (location.y) > width_and_height_of_environment {\n\t\t\t\tlocation <- {location.x,location.y - width_and_height_of_environment};\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\/\/Reflex to follow the goal \n\treflex follow_goal {\n\t\tvelocity <- velocity + ((first(boids_goal).location - location) \/ cohesion_factor);\n\t}\n\t\/\/Reflex to apply the wind vector on the velocity\n\treflex wind when: apply_wind {\n\t\tvelocity <- velocity + wind_vector;\n\t}\n\t\n\t\/\/Action to move the agent  \n\taction do_move {  \n\t\tif (((velocity.x) as int) = 0) and (((velocity.y) as int) = 0) {\n\t\t\tvelocity <- {(rnd(4)) -2, (rnd(4)) - 2};\n\t\t}\n\t\tpoint old_location <- copy(location);\n\t\tdo goto target: location + velocity;\n\t\tvelocity <- location - old_location;\n\t}\n\t\n\t\/\/Reflex to apply the movement by calling the do_move action\n\treflex movement {\n\t\tdo do_move;\n\t\tdo bounding;\n\t}\n\t\n\taspect image {\n\t\tdraw (images at (rnd(2))) size: {50,50} rotate: heading ;      \n\t}\n\taspect circle { \n\t\tdraw circle(15)  color: #red;\n\t}\n\t\n\taspect default { \n\t\tdraw circle(20) color: #lightblue wireframe: true;\n\t}\n} \n\n\/\/Species obstacle that represents the obstacles avoided by the boids agents using the skill moving\nspecies obstacle skills: [moving] {\n\tfloat speed <- 2.0;\n\n\tinit {\n\t\tshape <- triangle(15);\n\t}\t\n\t\/\/Reflex to move the obstacles if it is available\n\treflex move_obstacles when: moving_obstacles {\n\t\t\/\/Will make the agent go to a boid with a 50% probability\n\t\tif flip(0.5)  \n\t\t{ \n\t\t\tdo goto target: one_of(boids);\n\t\t} \n\t\telse{ \n\t\t\tdo wander amplitude: 360.0;   \n\t\t}\n\t}\n\taspect default {\n\t\tdraw  triangle(20) color: #black ;\n\t}\n\n}\n\n\nexperiment \"Basic\" type: gui {\n\tparameter 'Number of agents' var: number_of_agents;\n\tparameter 'Number of obstacles' var: number_of_obstacles;\n\tparameter 'Maximal speed' var: maximal_speed;\n\tparameter 'Cohesion Factor' var: cohesion_factor;\n\tparameter 'Alignment Factor' var: alignment_factor; \n\tparameter 'Minimal Distance'  var: minimal_distance; \n\tparameter 'Width\/Height of the Environment' var: width_and_height_of_environment ;  \n\tparameter 'Toroidal Environment ?'  var: torus_environment ; \n\tparameter 'Apply Cohesion ?' var: apply_cohesion ;\n\tparameter 'Apply Alignment ?' var: apply_alignment ;   \n\tparameter 'Apply Separation ?' var: apply_separation ;   \n\tparameter 'Apply Avoidance ?' var: apply_avoid ;   \n\tparameter 'Apply Wind ?' var: apply_wind ;     \n\tparameter 'Moving Obstacles ?' var: moving_obstacles  ;    \n\tparameter 'Direction of the wind' var: wind_vector ;  \n\t\n\t\/\/Minimum duration of a step to better see the movements\n\tfloat minimum_cycle_duration <- 0.01;\n\n\toutput synchronized: true {\n\t\tdisplay Sky type: 3d axes:false{ \n\t\t\timage '..\/images\/sky.jpg' refresh: false;\n\t\t\tspecies boids aspect: image;\n\t\t\tspecies boids_goal;\n\t\t\tspecies obstacle;\n\t\t}\n\n\t}\n}\n\n\nexperiment \"Interactive\" type: gui autorun: true{\n\tparameter 'Number of agents' var: number_of_agents;\n\tparameter 'Number of obstacles' var: number_of_obstacles;\n\tparameter 'Maximal speed' var: maximal_speed;\n\tparameter 'Cohesion Factor' var: cohesion_factor;\n\tparameter 'Alignment Factor' var: alignment_factor; \n\tparameter 'Minimal Distance'  var: minimal_distance; \n\tparameter 'Width\/Height of the Environment' var: width_and_height_of_environment ;  \n\tparameter 'Toroidal Environment ?'  var: torus_environment ; \n\tparameter 'Apply Cohesion ?' var: apply_cohesion ;\n\tparameter 'Apply Alignment ?' var: apply_alignment ;   \n\tparameter 'Apply Separation ?' var: apply_separation ;   \n\tparameter 'Apply Avoidance ?' var: apply_avoid ;   \n\tparameter 'Apply Wind ?' var: apply_wind ;     \n\tparameter 'Moving Obstacles ?' var: moving_obstacles  ;    \n\tparameter 'Direction of the wind' var: wind_vector ;  \n\tbool previous_state <- gama.pref_synchronize_quadtree;\n\t\n\tinit {\n\t\t\/\/ The preference is explicitly set so as to avoid concurrency problems \n\t\tgama.pref_synchronize_quadtree <- true;\n\t}\n\t\n\tabort {\n\t\tgama.pref_synchronize_quadtree <- previous_state;\n\t}\n\t\n\t\/\/Minimum duration of a step to better see the movements\n\tfloat minimum_cycle_duration <- 0.01;\n\n\toutput synchronized: true {\n\t\tdisplay Sky  background: #blue type: 3d fullscreen: 0 toolbar: false axes:false{ \n\t\t\timage '..\/images\/sky.jpg' refresh: false;\n\t\t\tspecies boids aspect: image trace: 10 fading: true ;\n\t\t\tspecies boids_goal;\n\t\t\tspecies obstacle;\n\t\t\t\/\/Event to call the action move_goal in global if the mouse move within the experiment\n\t\t\tevent #mouse_move {ask simulation {do move_goal;}}\n\t\t}\n\n\t}\n}"
    },
    {
        "instruction": "Create an action move_goal that asks to move the goal to the mouse location.",
        "output": "\/\/Action to move the goal to the mouse location\n\taction move_goal {\n\t\task first(boids_goal) {\n\t\t\tdo goto target: #user_location speed: 30.0;\n\t\t}\n\t}"
    },
    {
        "instruction": "Generate a model that create agents by importing data of a CSV file. The model read the CSV File (iris.csv) and create an agent Iris for each line of the CSV, linking its attributes to columns of the CSV File (sepal_length, sepal_width,petal_length, petal_width,type). In addition the Iris species has a color attribute (value #blue if the type is Iris-setosa, #red is the type is Iris-virginica and #yellow otherwise). The color is used to display the Iris agents as a circle of radius petal_width.",
        "output": "model CSVfileloading\n\nglobal {\n\t\n\tinit {\n\t\t\/\/create Iris agents from the CSV file (use of the header of the CSV file), the attributes of the agents are initialized from the CSV files: \n\t\t\/\/we set the header facet to true to directly read the values corresponding to the right column. If the header was set to false, we could use the index of the columns to initialize the agent attributes\n\t\tcreate Iris from:csv_file( \"..\/includes\/iris.csv\",true) with:\n\t\t\t[sepal_length::float(get(\"sepallength\")), \n\t\t\t\tsepal_width::float(get(\"sepalwidth\")), \n\t\t\t\tpetal_length::float(get(\"petallength\")),\n\t\t\t\tpetal_width::float(get(\"petalwidth\")), \n\t\t\t\ttype::string(get(\"type\"))\n\t\t\t];\t\n\t}\n}\n\nspecies Iris {\n\tfloat sepal_length;\n\tfloat sepal_width;\n\tfloat petal_length;\n\tfloat petal_width;\n\tstring type;\n\trgb color ;\n\t\n\tinit {\n\t\tcolor <- type =\"Iris-setosa\" ? #blue : ((type =\"Iris-virginica\") ? #red: #yellow);\n\t}\n\t\n\taspect default {\n\t\tdraw circle(petal_width) color: color; \n\t}\n}\n\nexperiment main type: gui{\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies Iris;\n\t\t}\n\t}\n\t\n}\n"
    },
    {
        "instruction": "Create a square geometry named shape that matches a specified width and height of the environment.",
        "output": "int width_and_height_of_environment <- 1000;\ngeometry shape <- square(width_and_height_of_environment);"
    },
    {
        "instruction": "Write a GAML code snippet to establish a model entitled `multi_simulations` designed for initiating multiple simulation instances as below:\n\n\n- Start by defining a model named `multi_simulations`.\n- Set up a global scope that initializes each simulation instance:\n - Use the `init` block to send a notification each time a new simulation is created. This should output a message indicating the creation of a simulation and include its name (utilize the `name` variable).\n\n\n- Create an experiment named `my_experiment` of the `gui` type.\n - Incorporate an `init` block within the experiment, which will be intentionally left empty for potential future enhancements or initialization code.\n\n\n- Embed a reflex that is triggered on a specific condition during the simulation\u2014each time the simulation cycle number is a multiple of 10 (excluding 0):\n - Employ the condition `(mod(cycle, 10) = 0 and cycle != 0)` to precisely fire the reflex every 10 cycles starting from cycle 10.\n - Within this reflex, issue a command to create a new instance of the simulation (represented by the `create simulation;` GAML statement).\n\n\n- Include an `output` block within the experiment to define how results or graphical interfaces should be displayed to the user. For now, it remains empty, serving as a placeholder for future coding elements or directives that may be needed for output management.\n\n\nThe snippet should facilitate running concurrent simulation instances at specified intervals, providing a basis for understanding or observing the behavior of multiple simulations in action.\n",
        "output": "model multi_simulations\n\n\nglobal {\n   init {\n       write \"new simulation created ! Its name is \"+name;\n   }\n}\n\n\nexperiment my_experiment type:gui  {\n   init {\n   }\n   reflex when:(mod(cycle,10)=0 and cycle!=0) {\n       create simulation;\n   }\n   output {\n   }\n}\n"
    },
    {
        "instruction": "Create a complete and simple prey and predator comodel which serves to demonstrate the mixing behaviors of preyPredator with the Ants. Ants are the prey, fleeing from Predators, when they are not chasing, they try to do job of the ants.",
        "output": "model prey_predator\n\n\nglobal\n{\n\tgeometry shape <- square(100);\n\tfloat perceipt_radius <- 20.0;\n\tint preyinit <- 500;\n\tint predatorinit <- 3;\n\tlist<agent> lstPredator;\/\/ <- list<agent> (predator);\n\tlist<agent> lstPrey; \/\/<- list<agent> (prey);\n\tinit\n\t{\n\t\tcreate prey number: preyinit;\n\t\tcreate predator number: predatorinit;\n\t\tlstPredator <- list<agent> (predator);\n\t\tlstPrey <- list<agent> (prey);\n\t}\n\n}\n\nspecies generic_species skills: [moving]\n{\n\tfloat speed <- 1.0;\n\tpoint goal;\n\tbool is_chased <- false;\n\treflex live_with_my_goal\n\t{\n\t\tif (goal != nil)\n\t\t{\n\t\t\tdo wander speed: speed;\n\t\t\tdo goto target: goal speed: speed;\n\t\t} else\n\t\t{\n\t\t\tdo wander speed: speed;\n\t\t}\n\n\t}\n\n}\n\nspecies prey parent: generic_species\n{\n\tgeometry shape <- circle(0.5);\n\tfloat speed <- 0.2;\n\trgb color <- # green;\n\treflex fleeing\n\t{\n\t\tif (length((lstPredator where (each != nil and !dead(each) and each distance_to self < perceipt_radius))) > 0)\n\t\t{\n\t\t\tspeed <- 1.0;\n\t\t\tis_chased <- true;\n\t\t\tcolor <- # lime;\n\t\t\tif (goal = nil)\n\t\t\t{\n\t\t\t\tagent a <- any(((lstPrey where (each != nil and !dead(each) and !generic_species(each).is_chased))));\n\t\t\t\tif (a != nil and !dead(a))\n\t\t\t\t{\n\t\t\t\t\tif (flip(0.5))\n\t\t\t\t\t{\n\t\t\t\t\t\tgoal <- a.location;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tgoal <- any_location_in(world.shape);\n\t\t\t\t\t}\n\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tgoal <- any_location_in(world.shape);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (goal != nil and self.location distance_to goal < 0.5)\n\t\t{\n\t\t\tgoal <- nil;\n\t\t}\n\n\t\tif (length((lstPredator where (each != nil and !dead(each))) where (each distance_to self <= perceipt_radius)) = 0)\n\t\t{\n\t\t\tis_chased <- false;\n\t\t\tcolor <- # green;\n\t\t\tspeed <- 0.2;\n\t\t}\n\n\t}\n\n\taspect default\n\t{\n\t\tdraw shape color: color;\n\t}\n\n}\n\nspecies predator parent: generic_species\n{\n\tgeometry shape <- triangle(2);\n\trgb color <- # red;\n\treflex hunting\n\t{\n\t\tif (goal = nil)\n\t\t{\n\t\t\tlist tmp <- (lstPrey where (!dead(each) and each.shape distance_to self.shape < perceipt_radius));\n\t\t\tif (length(tmp) > 0)\n\t\t\t{\n\t\t\t\tagent a <- first(tmp sort (each.shape distance_to self.shape));\n\t\t\t\tif (a = nil)\n\t\t\t\t{\n\t\t\t\t\ta <- any((lstPrey where (!dead(each))));\n\t\t\t\t}\n\n\t\t\t\tif (a != nil)\n\t\t\t\t{\n\t\t\t\t\tspeed <- 2.0;\n\t\t\t\t\tgoal <- a.location;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ((self.location distance_to goal < 0.5))\n\t\t{\n\t\t\task lstPrey where (!dead(each) and each.location distance_to goal < 0.5)\n\t\t\t{\n\t\t\t\tdo die;\n\t\t\t}\n\n\t\t\tgoal <- nil;\n\t\t\tspeed <- 1.0;\n\t\t}\n\n\t}\n\n\taspect default\n\t{\n\t\tdraw circle(perceipt_radius) color: # pink wireframe: true;\n\t\tdraw shape color: color rotate: 90 + my heading;\n\t}\n\n}\n\nexperiment \"Prey Predator Exp\" type: gui\n{\n\toutput\n\t{\n\t\tdisplay main_display\n\t\t{\n\t\t\tspecies prey;\n\t\t\tspecies predator;\n\t\t}\n\n\t}\n\n}"
    },
    {
        "instruction": "Create the species people that can move in the simulation.",
        "output": "species people_moving skills: [moving] {\n}"
    },
    {
        "instruction": "Create a model that displays the step to step algorithm of k-means over moving agents. In this model there 2 global parameters, 'n' being the number of datapoints agents and 'k' the number of cluster to create. \n\nThe clusters are represented as agents, cluster agent have an attribute giving the list of moving agent inside the cluster. The aspect of a cluster agent is a convex hull of the polygon created from the list of their datapoints. The color of this agent is randomly choosen.\n\nThe datapoints are represented as agents, they have a direct reference on the closest cluster agent as attribute. the datapoints agents are moving around each step using wander. the aspect of a datapoint is a circle taking the color of the cluster agent he is the closest to.\n\n\n",
        "output": "model MASKMEANS\n\n\nglobal\n{\n\t\/\/ the number of classes to create (kmeans)\n\tint k <- 2;\n\t\n\t\/\/ the number of points\n\tint N <- 500;\n\t\n\tinit\n\t{\n\t\tcreate centroids number: k\n\t\t{\n\t\t\tlocation <- { rnd(100), rnd(100) };\n\t\t}\n\t\tcreate datapoints number: N\n\t\t{\n\t\t\tlocation <- { rnd(100), rnd(100)};\n\t\t\tmycenter <- centroids closest_to self;\n\t\t}\n\t\t\n\t\tloop tmp over: centroids\n\t\t{\n\t\t\ttmp.color_kmeans  <- rgb(rnd(255),rnd(255),rnd(255));\n\t\t}\n\t}\n}\n\nspecies datapoints skills:[moving] \n{\n\trgb color_kmeans <- rgb(0,0,0) \t;\n\tcentroids mycenter;\n\t\n\treflex move \n    {\n    \tdo wander amplitude: 90.0;\n    }\n    \n    reflex when: mycenter != nil\n    {\t\t\n\t\tmycenter.mypoints <- mycenter.mypoints - self;\n\t\tmycenter <- centroids closest_to self;\n\t\t\n\t\tcolor_kmeans <- mycenter.color_kmeans;\n\t\tadd self to: mycenter.mypoints;\n    }\n\taspect kmeans_aspect2D\n\t{\n\t\tdraw circle(0.5) color: color_kmeans border: color_kmeans - 25;\n\t}\n}\n\nspecies centroids\n{\n\trgb color_kmeans <-  rgb(225,225,225);\n\tlist<datapoints> mypoints;\n\t\n\treflex update_location when: length(mypoints) > 0\n\t{\n\t\tlocation <- mean(mypoints collect each.location); \/\/ move centroid in the middle of the convex\n\t\twrite(\"lenght : \" + length(mypoints));\n\t}\n\t\n\taspect kmeans_aspect2D\n\t{\n\t\tdraw cross(3, 0.5) color: color_kmeans border: color_kmeans - 25;\n\t\t\n\t\tlist<geometry> li <- mypoints collect each.shape;\n\t\tgeometry convex <- convex_hull(polygon(li));\n\t\t\n\t\tdraw convex color: rgb(color_kmeans, 0.5);\n\t}\n}\n\nexperiment clustering2D type: gui\n{\n\toutput\n\t{\n\t\tdisplay map_kmeans \n\t\t{\n\t\t\tspecies datapoints aspect: kmeans_aspect2D transparency:0.4;\n\t\t\tspecies centroids aspect: kmeans_aspect2D;\n\t\t}\n\n\t}\n}"
    },
    {
        "instruction": "Generate a people species that can use the primitive of the moving skill. It represents an individual that can be infected or not. At each step, it will move randomly in the space. In addition, when it is infected, it will have a probability of proba_infection to infect all the people agents located at distance infection_distance. infection_distance and proba_infection are 2 existing global variables.\nIt may be displayed by drawing a circle of radius 5 and a color being red whether it is infected and green otherwise.",
        "output": "species people skills: [moving] {\n\tbool is_infected <- false;\n\n\treflex move {\n\t\tdo wander;\n\t}\n\n\treflex infect when: is_infected {\n\t\task people at_distance infection_distance {\n\t\t\tif (flip(proba_infection)) {\n\t\t\t\tis_infected <- true;\n\t\t\t}\n\t\t}\n\t}\n\n\taspect default {\n\t\tdraw circle(5) color: is_infected ? #red : #green;\n\t}\n}\n"
    },
    {
        "instruction": "Write a GAML code snippet for a model named `multi_simulations` featuring the initial creation of species and synchronized simulations with shared parameters:\n\n\n- Outline the structure of the model `multi_simulations`.\n- In the global species, use the `init` block for the instantiation of an entity from a species known as `my_species`.\n\n\n- Define the species `my_species` with a given movement capability:\n - Equip `my_species` with the skill `moving`.\n - Construct a `reflex update` that prompts the agent to engage in a random wandering behavior using the `do wander;` command.\n - Establish an `aspect base` for graphical representation. Within this aspect, direct to draw each agent as a green circle with a radius of `2`.\n\n\n- Develop an experiment titled `my_experiment` of the `gui` type:\n - Declare and initialize a floating-point variable `seedValue` with a default setting of `10.0`.\n - Assign the variable `seed` to `seedValue` to explicitly set the simulation\u2019s random seed to this value.\n - Within the experiment's `init` block:\n   - Create a directive to spawn a new simulation instance. This instance should be initialized with the same seed as the original, ensuring identical random behaviors across simulations.\n\n\n- Introduce an `output` segment that configures the visual display aspect:\n - Define a display labeled `my_display`.\n - Inside the display, specify that entities of `my_species` are to be exhibited using the `base` aspect.\n\n\nThis GAML code snippet should deliver the foundational elements for conducting dual concurrent simulations with a shared randomness determinant\u2014a particular seed value\u2014enabling parallel experiments with replicable, randomized events.\n",
        "output": "model multi_simulations\n\n\nglobal {\n   init {\n       create my_species;\n   }\n}\n\n\nspecies my_species skills:[moving] {\n   reflex update {\n       do wander;\n   }\n   aspect base {\n       draw circle(2) color:#green;\n   }\n}\n\n\nexperiment my_experiment type:gui  {\n   float seedValue <- 10.0;\n   float seed <- seedValue; \/\/ force the value of the seed.\n   init {\n       \/\/ create a second simulation with the same seed as the main simulation\n       create simulation with:[seed::seedValue];\n   }\n   output {\n       display my_display {\n           species my_species aspect:base;\n       }\n   }\n}\n"
    },
    {
        "instruction": "Create a complete model that shows pedestrians passing through a corridor.",
        "output": "model corridor\n\nglobal {\n\/\/Capture pedestrians parameter to define if wall will capture pedestrians\n\tbool capture_pedestrians <- false;\n\tint environment_width init: 8000;\n\tint environment_height init: 3000;\n\tgeometry shape <- rectangle(environment_width, environment_height);\n\n\t\/\/Pedestrians parameters\n\trgb pedestrian_color <- #green;\n\tfloat pedestrian_speed <- 10.0;\n\n\t\/\/Wall parameters\n\tfloat corridor_width <- environment_width \/ 1.5;\n\tint corridor_wall_height <- 800;\n\tgeometry corridor_wall_0_shape <- rectangle({corridor_width, corridor_wall_height}) at_location {environment_width \/ 2, corridor_wall_height \/ 2};\n\tgeometry corridor_wall_1_shape <- rectangle({corridor_width, corridor_wall_height}) at_location {environment_width \/ 2, environment_height - (corridor_wall_height \/ 2)};\n\t\n\n\t\/\/Corridor parameters\n\tfloat corridor_left_bounds <- (location.x - (corridor_width \/ 2));\n\tfloat corridor_right_bounds <- (location.x + (corridor_width \/ 2));\n\n\tinit {\n\t\tcreate corridor;\n\t}\n\n\treflex change_color when: every(200 #cycle) {\n\t\tpedestrian_color <- rnd_color(255);\n\t}\n\n\treflex generate_pedestrians when: every(4 #cycle) {\n\t\tcreate pedestrian number: 30 with: [color::pedestrian_color] {\n\t\t\tdo init_location({0, rnd(environment_height)});\n\t\t}\n\t}\n}\n\n\/\/Species pedestrian which will move from one side of the experiment to another and destroy itself once the other side is reached\nspecies pedestrian skills: [moving] topology: (topology(shape - (corridor_wall_0_shape + corridor_wall_1_shape))) {\n\tpoint target_location;\n\trgb color;\n\n\taction init_location (point loc) {\n\t\tlocation <- loc;\n\t\ttarget_location <- {environment_width, loc.y};\n\t\tspeed <- rnd(pedestrian_speed - 5) + 5.0;\n\t}\n\t\n\t\n\treflex change_speed when: every(rnd(200) #cycle) {\n\t\t\tspeed <- rnd(pedestrian_speed - 5) + 5.0;\n\t}\n\n\t\/\/Reflex to make the agent move to its target_location\n\treflex move {\n\t\tpoint previous_location <- location;\n\n\t\tif (location.y < corridor_wall_height) and (location.x <= (environment_width \/ 2)) {\n\t\t\tdo move heading: self towards {(environment_width \/ 2) - (corridor_width \/ 2), corridor_wall_height};\n\t\t} else if (location.y > environment_height - corridor_wall_height) and (location.x <= (environment_width \/ 2)) {\n\t\t\tdo move heading: self towards {(environment_width \/ 2) - (corridor_width \/ 2), environment_height - corridor_wall_height};\n\t\t} else {\n\t\t\tdo move heading: self towards target_location;\n\t\t}\n\t\tif (location.x = previous_location.x) { \/\/ No move detected\n\t\t\tdo move heading: self towards {environment_width, world.shape.location.y};\n\t\t}\n\t}\n\n\treflex arrived when: location.x >= target_location.x {\n\t\tdo die;\n\t}\n\n}\n\n\/\/Species which represents the corridor\nspecies corridor {\n\tgeometry shape <- ((rectangle({corridor_width, environment_height})) at_location world.location) - (corridor_wall_0_shape + corridor_wall_1_shape);\n\n\t\/\/Subspecies for the multi-level architectures : captured pedestrians in this case\n\tspecies captured_pedestrian parent: pedestrian schedules: [] {\n\t\tfloat release_time;\n\t}\n\n\t\/\/Reflex to capture pedestrians if the parameter is checked\n\treflex aggregate when: capture_pedestrians {\n\t\/\/If we have pedestrians inside the corridor, we capture them\n\t\/\/We update the time during which a pedestrian is captured according to the time the pedestrian\n\t\/\/ should need to pass through the corridor if it wasn't captured\n\t\tcapture (pedestrian where (p: p.location.x between (corridor_left_bounds, corridor_right_bounds))) as: captured_pedestrian {\n\t\t\trelease_time <- time + ((corridor_width - (location.x - ((environment_width \/ 2) - (corridor_width \/ 2)))) \/ (pedestrian_speed - 2.5));\n\t\t} }\n\n\t\t\/\/Reflex to release pedestrians which have already passed enough time in the corridor\n\t\/\/ which means if they weren't captured by the corridor, they would have finish passing through it\n\treflex disaggregate {\n\t\tlist tobe_released_pedestrians <- captured_pedestrian where (time >= each.release_time);\n\t\tif !(empty(tobe_released_pedestrians)) {\n\t\t\trelease tobe_released_pedestrians as: pedestrian in: world {\n\t\t\t\tlocation <- {((environment_width \/ 2) + (corridor_width \/ 2)), (location).y};\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nexperiment \"Corridor\" type: gui autorun: true {\n\tpoint button_location;\n\tbool button_hover;\n\tgeometry corridor_wall_0_display <- rectangle({corridor_width-30, corridor_wall_height-30}) at_location {environment_width \/ 2, corridor_wall_height \/ 2};\n\tgeometry corridor_wall_1_display <- rectangle({corridor_width-30, corridor_wall_height-30}) at_location {environment_width \/ 2, environment_height - (corridor_wall_height \/ 2)};\n\t\n\tinit {\n\t\tbutton_location <- {simulation.corridor_left_bounds + 100, 100};  \n\t}\n\toutput {\n\t\tdisplay defaut_display type: 2d background: #black fullscreen: true toolbar: false {\n\t\t\tgraphics back {\n\t\t\t\tdraw shape color: #black wireframe: false;\n\t\t\t\tdraw corridor_wall_0_display color: #gray wireframe: true;\n\t\t\t\tdraw corridor_wall_1_display color: #gray wireframe: true ;\n\t\t\t}\n\n\t\t\tspecies corridor {\n\t\t\t\tdraw shape color: #black;\n\t\t\t}\n\t\t\t\n\t\t\tagents \"Captured\" value: list(corridor(0).captured_pedestrian) transparency: 0.5 {\n\t\t\t\tdraw square(30) wireframe: false color: #white;\n\t\t\t}\n\n\t\t\tspecies pedestrian {\n\t\t\t\tdraw square(20) wireframe: false color: color;\n\t\t\t}\n\n\t\t\tgraphics front {\n\t\t\t\tdraw (capture_pedestrians ? \"Capturing\":\"Not capturing\") anchor: #left_center at: {corridor_left_bounds + 200, 100} color: !capture_pedestrians ? #darkred : #darkgreen font: font(\"Helvetica\", 20 * #zoom, 0);\n\t\t\t\tdraw (\"Captured: \" + length(corridor(0).captured_pedestrian)) anchor: #left_center at: {corridor_left_bounds + 200, 250} color: #white font: font(\"Helvetica\", 20 * #zoom, 0);\n\t\t\t\tdraw (\"Pedestrians: \" + length(pedestrian)) anchor: #left_center at: {corridor_left_bounds + 200, 400} color: #white font: font(\"Helvetica\", 20 * #zoom, 0);\n\t\t\t\tdraw (\"Step duration (ms): \" + (duration copy_between (0, 4))) anchor: #left_center at: {corridor_left_bounds + 200, 550} color: #white font: font(\"Helvetica\", 20 * #zoom, 0);\n\t\t\t}\n\n\t\t\tgraphics button {\n\t\t\t\tdraw circle(50) color: #darkgray at: button_location;\n\t\t\t\tdraw circle(40) color: !capture_pedestrians ? (button_hover ? #yellow : #red) : (button_hover ? #lightgreen : #darkgreen) at:  button_location;\n\t\t\t}\n\n\t\t\tevent #mouse_down {\n\t\t\t\tif (button_location distance_to #user_location <= 50) {\n\t\t\t\t\tcapture_pedestrians <- !capture_pedestrians;\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent #mouse_move {\n\t\t\t\tbutton_hover <- (button_location distance_to #user_location <= 50);\n\t\t\t}\n\t\t}\n\t}\n\n}"
    },
    {
        "instruction": "Generate a model with a species people, characterized by an attribute (is_infected, being true or false).\nThe global block should contain as global attribute the initial number of people (named nb_people, 500 by defaut) and the initial number of infected people (named nb_infected_init, 5 by default). nb_people people agents are created initially. Among the people agents, nb_infected_init are initialized as infected. The step duration is initialized to 1 minute, and the environment to a square with an edge of 500 meters.",
        "output": "global {\n    int nb_people <- 500;\n    int nb_infected_init <- 5;\n    float step <- 1 #minutes;\n    geometry shape <- envelope(square(500 #m));\n\n\tinit {\n\t\tcreate people number: nb_people {\n\t\t\tspeed <- agent_speed;\n\t\t}\n\n\t\task nb_infected_init among people {\n\t\t\tis_infected <- true;\n\t\t}\n\n\t}\n\n}\n\nspecies people skills: [moving] {\n\tbool is_infected <- false;\n}"
    },
    {
        "instruction": "Propose a GAML code snippet to institute an experiment designated as 'Run 5 simulations' which has the capacity to serially initiate multiple simulation runs with the following specifications:\n\n\n- Label the experiment 'Run 5 simulations' and configure it as a batch type to allow for automated sequential runs.\n- Set the number of repetitions for the experiment to `5` to indicate the total number of simulations to be run in this batch sequence.\n- Include the `keep_seed` property set to `true`, ensuring that each simulation run in the batch uses the same seed for its random number generator, contributing to reproducible outcomes across runs.\n- Establish an `until` condition that dictates the termination of each simulation run, predicated on the simulation `time` surpassing `1000` units.\n\n\n- Integrate a `reflex` labeled as `end_of_runs`, intended to execute an action at the end of each simulation within the batch:\n - Begin with a counter variable `cpt` initialized to `0`. This will serve as an incremental index to uniquely name saved files.\n - Use the `ask simulations` statement to iterate through all current simulations.\n - Within the block, deploy a save command for the `people` species, exporting them to a shapefile\u2014the format indicated by \"shp\".\n - Construct the file name by concatenating \"result\/people_shape\", the current value of `cpt`, and the extension \".shp\".\n - Specify the attributes `is_infected` and `is_immune` to be saved in the shapefile under the field names \"INFECTED\" and \"IMMUNE\", respectively.\n - Increment `cpt` after each simulation run to ensure unique file naming for subsequent exports.\n\n\nThe resulting snippet should facilitate the execution of controlled batch simulation runs, retaining consistent randomness and collecting structured geographic data in the form of shapefiles for each run, enabling detailed post-process analysis.\n",
        "output": "experiment 'Run 5 simulations' type: batch repeat: 5 keep_seed: true until: ( time > 1000 ) {\n   reflex end_of_runs {\n   int cpt <- 0;\n       ask simulations {\n           save people type: \"shp\" to: \"result\/people_shape\" + cpt + \".shp\" with: [is_infected::\"INFECTED\", is_immune::\"IMMUNE\"];\n           cpt <- cpt + 1;\n       }\n   }\n}\n"
    },
    {
        "instruction": "How to get a random value from a exponential distribution with a specified value of the rate (lambda) parameter equal to 5 ?\n",
        "output": "float var0 <- exp_rnd(5) ;"
    },
    {
        "instruction": "How to get an index of the given list with a probability following the (normalized) distribution described in the list ?\n",
        "output": "int index <- rnd_choice([0.2,0.5,0.3]);"
    },
    {
        "instruction": "Write the gama version in the console.",
        "output": "write sample(gama.version);"
    },
    {
        "instruction": "Write the list of plugins loaded in the current GAMA installation on the console.",
        "output": "write gama.plugins;"
    },
    {
        "instruction": "Write a GAML code snippet to implement an experiment named 'Run 5 simulations' that systematically conducts a series of simulation runs and captures specific statistical data at each step:\n\n- Designate the experiment with the title 'Run 5 simulations', setting it up as a batch operation to execute multiple consecutive trials.\n- Configure the experiment to repeat exactly `5` times, ensuring that a set number of simulation runs are completed.\n- Apply the `keep_seed` directive with a value of `true` to maintain the same initial conditions for each repeated run, providing consistent startup scenarios for comparative analysis.\n- Set a stopping condition using the `until` keyword, with the criteria being that the simulation cycle count (`cycle`) eclipses `1000`.\n\n- Establish a `reflex` within the experiment definition, denoted by `t`:\n  - Utilize the `save` instruction to regularly capture and output the simulation data to a file.\n  - Outline the data composition to be saved, which should include:\n    - The current simulation cycle number (`cycle`).\n    - The average number of infected individuals from all running simulations (acquired via `simulations mean_of each.nb_infected`).\n  - Instruct the code to output the gathered data into a file named \"result.txt\".\n  - Further specify that the saved file should follow the \"csv\" (comma-separated values) format for ease of data manipulation and review post-simulation.\n\nThis directive should enable the GAML model to autonomously run the prescribed number of simulations, ensuring data continuity via consistent seed usage, and systematically record key performance metrics to a CSV file for subsequent analytical purposes.",
        "output": "experiment 'Run 5 simulations' type: batch repeat: 5 keep_seed: true until: ( cycle > 1000 ) {\n   reflex t {\n       save [cycle, simulations mean_of each.nb_infected] to: \"result.txt\" type: \"csv\";\n   }\n}\n"
    },
    {
        "instruction": "How to get the value 0 with a probability 0.2, 1 with a probability 0.5, and 2 with a probability 0.3 ? ",
        "output": "int index <- rnd_choice([0.2,0.5,0.3]);"
    },
    {
        "instruction": "Create complete model that creates horizontal and vertical hexagonal grids.",
        "output": "model HexagonalGrid\n\nglobal {\n\tstring orientation <- \"horizontal\" among: [\"horizontal\", \"vertical\"] parameter: true;\t\n\t\n\tinit {\n\t\task cell {color <- #white;}\n\t}\n\treflex show_neighborhood {\n\t\task cell {color <- #white;}\n\t\task one_of(cell) {\n\t\t\tcolor <- #red;\n\t\t\task neighbors {\n\t\t\t\tcolor <- #green;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\/\/ the choices are 4,6 or 8 neighbors\ngrid cell height: 10 width: 10 neighbors: 6 horizontal_orientation: orientation = \"horizontal\";\n\n\nexperiment hexagonal type: gui{\n\toutput  synchronized:true{\n\t\tdisplay view type: 3d{\n\t\t\tgrid cell border: #black ;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Develop a GAML code snippet that orchestrates a simple model with hierarchical agent species and outputs an accumulated count of all instances. Follow these step-by-step instructions:\n\n- Initialize the `global` species with definitions for the simulation\u2019s setting.\n  - Create an `init` block that generates two instances of a species named `child` and one instance of a species named `mother`.\n\n- Within the global scope, script a reflex called `update` that performs an action each simulation cycle:\n  - The action should retrieve and write the total count of all `mother` species instances, including both direct and indirect (subspecies) instances, to the console or log.\n\n- In the global context, compose a list-returning function called `get_all_instances` that:\n  - Receives a single parameter, `spec`, which is a species of the generic type `agent`.\n  - Calculates and returns a list of all agents of the specified species, plus all agents of any subspecies thereof. The accumulation of instances should be achieved using recursion with the `accumulate` keyword and by invoking `get_all_instances(each)` for each subspecies.\n\n- Declare a basic species identified as `mother`, which will act as a parent species in the hierarchy.\n  \n- Define a species called `child` as a subspecies of `mother`, allowing for its instances to be accounted for as part of the `mother` population in the global reflex.\n\nThis crafted code snippet should produce a simple agent-based model where agents can be parents and children, and each cycle updates the console with the current total count of a species, including its subspecies.",
        "output": "global\n{\n   init {\n       create child number: 2;\n       create mother number: 1;\n   }\n   reflex update {\n       write length(get_all_instances(mother)); \/\/ will write 3 (1+2)\n   }\n   list<agent> get_all_instances(species<agent> spec) {\n       return spec.population +  spec.subspecies accumulate (get_all_instances(each));\n   }\n}\n\n\nspecies mother {}\n\n\nspecies child parent: mother {}"
    },
    {
        "instruction": "Here is my model:\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  \/\/ The init number of people\n    int number_I <- 5 ;\t\/\/ The init number of infected\n    float infection_rate <- 0.1 ; \/\/ The infection rate\n\tfloat infection_distance <- 5.0 ; \/\/ infection distance (in meters)\n\tfloat dying_proba <- 0.01; \/\/probability to die at each step if infected\n\tint immune_step <- 100 ; \/\/ number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; \/\/ speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\nCreate a batch experiment to determine what are the best values for the variables infection_rate and dying_proba to minimize the number of dead people in the simulation represented by the variable num_dead. Use the Particle Swarm Optimization (PSO) method to explore the parameter set. infection_rate cannot be smaller than 0.01 nor higher than 0.5 and dying_proba is defined between 0.01 and 0.2. The swarm will be composed of 3 particles, and will iterate 5 times. We consider a simulation over when 5000 seconds have passed in model time",
        "output": "\n\/\/ This experiment explores two parameters with a PSO strategy,\n\/\/ repeating each simulation three times (the aggregated fitness correspond to the mean fitness), \n\/\/ in order to find the best combination of parameters to minimize the number of infected people\nexperiment PSO type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod pso num_particles: 3 weight_inertia:0.7 weight_cognitive: 1.5 weight_social: 1.5  iter_max: 5  minimize: num_dead  ; \n}\n"
    },
    {
        "instruction": "Create a grid cell with height 10, width 10, 6 neighbours and with horizontal orientation.",
        "output": "\/\/ the choices are 4,6 or 8 neighbors\ngrid cell height: 10 width: 10 neighbors: 6 horizontal_orientation: orientation = \"horizontal\";"
    },
    {
        "instruction": "Construct a GAML code snippet that defines a grid and an experiment with the following specifications:\n\n1. Declare a `grid` species named `MyGrid`.\n   - Within this grid, define two distinct visual aspects:\n     - Name the first aspect `firstAspect`. In this aspect, instruct GAML to visually represent each cell in the grid as a square with a side length of 1 unit.\n     - Create a second aspect, titled `secondAspect`, where each cell is visually represented as a circle with a radius of 1 unit.\n\n2. Establish an experiment named `MyExperiment` with a 'gui' interface type.\n   - Inside the experiment, configure an `output` section that will determine what the user sees during the simulation run:\n     - Lay the foundations for a display called `MyDisplay`, specifying that it should use the `opengl` rendering type for enhanced graphics capabilities.\n     - Indicate that the `MyGrid` species should be displayed in `MyDisplay` utilizing the visual representation defined in `firstAspect`.\n\nThis code will regulate the setup of a visual simulation platform, presenting a grid in which cells are depicted with the designed graphical aspects, and coupling the grid display with an interactive GUI experiment environment.\n",
        "output": "grid MyGrid {\n   aspect firstAspect {\n       draw square(1);\n   }\n   aspect secondAspect {\n       draw circle(1);\n   }\n}\n\n\nexperiment MyExperiment type: gui {\n   output {\n       display MyDisplay type: opengl {\n           species MyGrid aspect: firstAspect;\n       }\n   }\n}\n"
    },
    {
        "instruction": "I have a model with two variables nb_preys and nb_predators that I want to save in a csv at the end of every simulation. A simulation ends either when the stop_sim action defined in the world returns true or if time is greater than end_cycle.\nMake me an experiment that will do that for 5 simulation runs.",
        "output": "experiment 'Run 5 simulations' type: batch repeat: 5 keep_seed: true until: world.stop_sim() or (time > end_cycle){\n\t\n\t\/\/ the reflex will be activated at the end of each run; in this experiment a run consists of the execution of 5 simulations (repeat: 5)\n\treflex end_of_runs\n\t{\n\t\task simulations\n\t\t{\n\t\t\tsave [nb_preys,nb_predators] to: \"Results\/preypredator.csv\" format:\"csv\" rewrite:false;\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Get the current workspace path and print to the console.",
        "output": "write gama.workspace_path;"
    },
    {
        "instruction": "Here is my model of disease infection:\n\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  \/\/ The init number of people\n    int number_I <- 5 ;\t\/\/ The init number of infected\n    float infection_rate <- 0.1 ; \/\/ The infection rate\n\tfloat infection_distance <- 5.0 ; \/\/ infection distance (in meters)\n\tfloat dying_proba <- 0.01; \/\/probability to die at each step if infected\n\tint immune_step <- 100 ; \/\/ number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; \/\/ speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\nMake an experiment to determine which values of infection_rate and dying_proba minimize the number of dead after 5000s in simulation time. infection_rate should be comprised between 0.1 and 0.5 and dying_proba between 0.01 and 0.2. To do so, use a genetic algorithm, with a population of 3, a probability of crossover of 0.7 a probability of mutation of 0.1 and stop after 5 generations.\n",
        "output": "\/\/ This experiment explores two parameters with a GA strategy,\n\/\/ repeating each simulation three times (the aggregated fitness correspond to the min fitness), \n\/\/ in order to find the best combination of parameters to minimize the number of infected people\nexperiment Genetic type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod genetic pop_dim: 3 crossover_prob: 0.7 mutation_prob: 0.1 improve_sol: true stochastic_sel: false\n\tnb_prelim_gen: 1 max_gen: 5  minimize: num_dead  aggregation: \"min\";\n}\n"
    },
    {
        "instruction": "Here is my model of disease infection:\n\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  \/\/ The init number of people\n    int number_I <- 5 ;\t\/\/ The init number of infected\n    float infection_rate <- 0.1 ; \/\/ The infection rate\n\tfloat infection_distance <- 5.0 ; \/\/ infection distance (in meters)\n\tfloat dying_proba <- 0.01; \/\/probability to die at each step if infected\n\tint immune_step <- 100 ; \/\/ number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; \/\/ speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\nMake an experiment to determine which values of infection_rate and dying_proba minimize the number of dead after 5000s in simulation time. infection_rate should be comprised between 0.1 and 0.5 and dying_proba between 0.01 and 0.2. To do so, use an hill climbing algorithm, with a start value of 0.2 for infection_rate and 0.05 for dying_proba",
        "output": "\/\/ This experiment explores two parameters with a Hill Climbing strategy from an explicit init solution (if no solution is given, start from a random sol),\n\/\/ repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n\/\/ in order to find the best combination of parameters to minimize the number of infected people\nexperiment Hill_Climbing type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.1;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod hill_climbing init_solution:map([\"infection_rate\"::0.2, \"dying_proba\":: 0.05])  minimize: num_dead aggregation: \"max\";\n}\n"
    },
    {
        "instruction": "Create a complete model to represent how to compute the shortest path from a grid (with the 4 algorithms: A*, Dijkstra, Jump Point Search (JPS) and Breadth First Search (BFS ).",
        "output": "model Grid\n\nglobal {\n\t\n\t\/*4 algorithms for the shortest path computation on a grid:\n\t*      - A* : default algorithm: Very efficient for both Moore (8) and Von Neumann (4) neighborhoods. An introduction to A*: http:\/\/www.redblobgames.com\/pathfinding\/a-star\/introduction.html\n\t*      - Dijkstra : Classic Dijkstra algorithm. An introduction to Dijkstra : http:\/\/www.redblobgames.com\/pathfinding\/a-star\/introduction.html\n\t*      - JPS : Jump Point Search, only usable for Moore (8) neighborhood. Most of time, more efficient than A*. An introduction to JPS: https:\/\/harablog.wordpress.com\/2011\/09\/07\/jump-point-search\/#3\n\t*      - BF : Breadth First Search. Should only be used for Von Neumann (4) neighborhood. An introduction to BF: http:\/\/www.redblobgames.com\/pathfinding\/a-star\/introduction.html\n\t*\/\n\t\n\tstring scenario <- \"wall\" among: [\"random\", \"wall\"] parameter: true;\n\tstring algorithm <- \"A*\" among: [\"A*\", \"Dijkstra\", \"JPS\", \"BF\"] parameter: true;\n\tint neighborhood_type <- 8 among:[4,8] parameter: true;\n\tfloat obstacle_rate <- 0.1 min: 0.0 max: 0.9 parameter: true;\n\tint grid_size <- 50 min: 5 max: 100 parameter: true;\n\tpoint source;\n\tpoint goal;\n\tpath the_path;\n\tinit toto {    \n\t\tif (scenario = \"wall\") {\n\t\t\task cell {is_obstacle <- false;}\n\t\t\tint x_max <- round(grid_size * 2\/3);\n\t\t\tloop i from: 2 to:x_max {\n\t\t\t\tcell[i, 3].is_obstacle <- true;\n\t\t\t\tcell[i, grid_size - 4].is_obstacle <- true;\n\t\t\t}\n\t\t\tloop i from: 3 to: grid_size - 4 {\n\t\t\t\tcell[x_max, i].is_obstacle <- true;\n\t\t\t}\n\t\t\task cell {color <- is_obstacle ? #black : #white;}\n\t\t}\n\t\tsource <- (one_of (cell where not each.is_obstacle)).location;\n\t\tgoal <- (one_of (cell where not each.is_obstacle)).location;\n\n\t\tusing topology(cell) {\n\t\t\tthe_path <- path_between((cell where not each.is_obstacle), source, goal);\t\n\t\t}\n\t} \n\t\n\treflex compute_path {\n\t\tsource <- (one_of (cell where not each.is_obstacle)).location;\n\t\tgoal <- (one_of (cell where not each.is_obstacle)).location;\n\n\t\tusing topology(cell) {\n\t\t\tthe_path <- path_between((cell where not each.is_obstacle), source, goal);\t\n\t\t}\n\t}\n}\n\ngrid cell width: grid_size height: grid_size neighbors: neighborhood_type optimizer: algorithm{\n\tbool is_obstacle <- flip(0.1);\n\trgb color <- is_obstacle ? #black : #white;\n} \n\n\t\n\nexperiment goto_grid type: gui {\n\toutput {\n\t\tdisplay objects_display type: 2d antialias:false{\n\t\t\tgrid cell border: #black;\n\t\t\tgraphics \"elements\" {\n\t\t\t\tdraw circle(1) color: #green at: source border: #black;\n\t\t\t\tdraw circle(1) color: #red at: goal  border: #black;\n\t\t\t\tloop v over: the_path.vertices {\n\t\t\t\t\tdraw triangle(0.5) color: #yellow border: #black at: point(v);\n\t\t\t\t}\n\t\t\t\tloop s over: the_path.segments {\n\t\t\t\t\tdraw s color: #red ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Develop a GAML code snippet for a species called `duck`, which employs a strategy pattern for flying behaviors and provides a way to visualize these behaviors:\n\n\n1. Begin by declaring a new species `duck`.\n  - Include an attribute `f` of type `fly_behavior` which will hold the current flying strategy.\n\n\n2. Define an action `set_fly_behavior` within `duck`:\n  - This action should take a single parameter `new_f` of type `fly_behavior`.\n  - Inside this action, assign the `f` attribute to this new passed-in behavior, effectively changing the duck's flying strategy.\n\n\n3. Implement an action `perform_fly` for the `duck` species:\n  - Utilize the `ask` scope to command `f`, the flying behavior, to execute its embedded `fly` action.\n\n\n4. Additionally, declare within `duck` an `action` named `my_display`.\n  - Mark this action as `virtual: true`, signifying that it should be overridden by any subspecies or be explicitly defined when creating instances of `duck`.\n\n\nEnsure the code snippet reflects the ability of a `duck` instance to dynamically change and perform its flying behavior, illustrating an aspect of behavioral design patterns within the GAML structure.\n",
        "output": "species duck {\n   fly_behavior f;\n\n\n   action set_fly_behavior (fly_behavior new_f) {\n       f <- new_f;\n   }\n  \n   action perform_fly {\n       ask f {\n           do fly;\n       }\n   }\n  \n   action my_display virtual: true;\n  \n}\n"
    },
    {
        "instruction": "Create a reflex that calculates the path in a grid from a source cell to a goal cell using the cell topology, and avoiding obstacles.",
        "output": "reflex compute_path {\n\t\tsource <- (one_of (cell where not each.is_obstacle)).location;\n\t\tgoal <- (one_of (cell where not each.is_obstacle)).location;\n\n\t\tusing topology(cell) {\n\t\t\tthe_path <- path_between((cell where not each.is_obstacle), source, goal);\t\n\t\t}\n\t}"
    },
    {
        "instruction": "Create a species thread_agent that uses the thread skill.",
        "output": "species thread_agent skills: [thread] {\n\t\/\/create and start a new thread - the thread_action will be activated continuously at a fixed rate every 1#s by the 2 agents\n\t\n\tinit {\n\t\tdo run_thread every: 1#s;\n\t}\n\t\n\t\/\/the action run in the thread\n\taction thread_action {\n\t\twrite \" > \" + self + \"current time: \" + #now;\n\t}\t\n}"
    },
    {
        "instruction": "Design a GAML code snippet to define a foundational agent species called `duck`, as well as two distinct subclasses that inherit from it and exhibit different behaviors and display messages:\n\n1. Start with a species declaration for `duck`:\n   - Assign an attribute `f` of type `fly_behavior`, which will serve to hold a reference to a current flying strategy.\n   \n2. Within the `duck` species, create an action named `set_fly_behavior`:\n   - This action should accept a parameter `new_f` of the `fly_behavior` type.\n   - Set the `duck`'s `f` attribute to the new behavior received as an argument.\n\n3. Implement an action called `perform_fly`:\n   - Compose this action to operate within the context of the contained `f` attribute and trigger its `fly` action.\n\n4. Declare an action `my_display` within `duck` species:\n   - Make sure this action is virtual (i.e., intended to be overridden) by adding the `virtual: true` attribute.\n\n5. Add a reflex block that invokes both the `perform_fly` and `my_display` actions within the `duck` species.\n\n6. Create a subclass of `duck` named `model_duck`:\n   - Within the 'init' block, instantiate a `fly_no_way` behavior and assign it to the `f` attribute of `model_duck` to indicate its inability to fly.\n   \n7. Define an overridden `my_display` action in `model_duck` that outputs \"i am a model duck\".\n\n8. Construct another subclass named `real_duck` which also inherits from `duck`.\n   - In the 'init' block, create a `fly_with_wings` behavior reflecting the capability of real ducks to fly and assign this behavior to `real_duck`\u2019s `f` attribute.\n   \n9. Similar to `model_duck`, include an overridden `my_display` action in `real_duck` that expresses \"i am a real duck\".\n\nThis GAML script should encapsulate the functionalities required for creating a generic `duck` species capable of changing its flying behavior dynamically and two specialized `duck` species, `model_duck` and `real_duck`, each with distinct flying capacities and self-identification messages.",
        "output": "species duck {\n   fly_behavior f;\n  \n   action set_fly_behavior (fly_behavior new_f) {\n       f <- new_f;\n   }\n  \n   action perform_fly {\n       ask f {\n           do fly;\n       }\n   }\n  \n   action my_display virtual: true;\n  \n   reflex {\n       do perform_fly;\n       do my_display;\n   }\n}\n\n\nspecies model_duck parent: duck {\n   init {\n       create fly_no_way {\n           ask myself {\n               f <- myself;\n           }\n       }\n   }\n  \n   action my_display {\n       write \"i am a model duck\";\n   }\n}\n\n\nspecies real_duck parent: duck {\n   init {\n       create fly_with_wings {\n           ask myself {\n               f <- myself;\n           }\n       }\n   }\n  \n   action my_display {\n       write \"i am a real duck\";\n   }\n}\n"
    },
    {
        "instruction": "I have an SIR model:\n\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  \/\/ The init number of people\n    int number_I <- 5 ;\t\/\/ The init number of infected\n    float infection_rate <- 0.1 ; \/\/ The infection rate\n\tfloat infection_distance <- 5.0 ; \/\/ infection distance (in meters)\n\tfloat dying_proba <- 0.01; \/\/probability to die at each step if infected\n\tint immune_step <- 100 ; \/\/ number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; \/\/ speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\n\nMake me an experiment to find out what combination of values for the infection rate and the dying probabilities are the most efficient to minimize the number of dead in the simulation. We consider a simulation to be over after 5000 seconds in simulation time. infection_rate must be between 0.1 and 0.5 and dying_proba between 0.01 and 0.2. Use the tabu method with a list size of 5 and 5 iterations. ",
        "output": "\/\/ This experiment explores two parameters with a Tabu Search strategy,\n\/\/ repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n\/\/ in order to find the best combination of parameters to minimize the number of infected people\nexperiment Tabu_Search type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod tabu iter_max: 5 tabu_list_size: 5 minimize: num_dead aggregation: \"max\";\n}\n"
    },
    {
        "instruction": "I have an SIR model:\n\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  \/\/ The init number of people\n    int number_I <- 5 ;\t\/\/ The init number of infected\n    float infection_rate <- 0.1 ; \/\/ The infection rate\n\tfloat infection_distance <- 5.0 ; \/\/ infection distance (in meters)\n\tfloat dying_proba <- 0.01; \/\/probability to die at each step if infected\n\tint immune_step <- 100 ; \/\/ number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; \/\/ speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\n\nMake me an experiment to find out what combination of values for the infection rate and the dying probabilities are the most efficient to minimize the number of dead in the simulation. We consider a simulation to be over after 5000 seconds in simulation time. infection_rate must be between 0.1 and 0.5 and dying_proba between 0.01 and 0.2. Use the reactive tabu method with an initial list size of 5, 10 iterations and cycles with a size between 3 and 10. ",
        "output": "\n\/\/ This experiment explores two parameters with a Reactive Tabu Search strategy,\n\/\/ repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n\/\/ in order to find the best combination of parameters to minimize the number of infected people\nexperiment Reactive_Tabu_Search type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod reactive_tabu iter_max: 10 cycle_size_max: 10 cycle_size_min: 3 tabu_list_size_init: 5 minimize: num_dead aggregation: \"max\";\n}"
    },
    {
        "instruction": "Write a GAML code snippet that fabricates a model comprising macro-species agents, each containing a random number of micro-species agents, with the objective to log the count of micro-species for each macro-species upon initialization:\n\n\n1. Define the `global` context:\n  - Start with an `init` block in the global scope that commands the creation of 5 `macro_species` agents.\n\n\n2. Declare a species named `macro_species`:\n  - Inside the `init` block for each `macro_species` instance:\n    - Instantiate a random number (from 1 to 10) of `micro_species_in_group` agents.\n    - Compose a `write` statement to log a message. This message should include the unique `name` of the `macro_species` agent and the `length` (count) of `micro_species_in_group` agents it contains.\n\n\n3. Within `macro_species`, outline the sub-species `micro_species_in_group` with no additional properties or actions. Its definition remains empty as it serves as an agent count inside its `macro_species`.\n\n\n4. Set up an experiment by the name of `my_experiment` with the interface type `gui`. This should be left as an empty shell for further development, with no specific configurations or output prescribed at this time.\n\n\nThe resulting snippet will produce an outcome whereby upon each simulation start, each macro-species agent reports its number of micro-species agents, reflecting an agent-contained hierarchy and the dynamic instantiation of agents in GAML.\n",
        "output": "global {\n   init {\n   create macro_species number:5;\n   }\n}\n\n\nspecies macro_species  {   \n   init {\n   create micro_species_in_group number: rnd(10);\n   write \"the macro species agent named \"+name+\" contains \"+length(micro_species_in_group)+\" agents of micro-species.\";\n   }\n\n\n   species micro_species_in_group { }\n}\n\n\nexperiment my_experiment type: gui { }\n"
    },
    {
        "instruction": "Can you give me an example model whereby a DEM file is rendered\/displayed in 3D?",
        "output": "model ThreeDModel\n\nglobal {\n\tmatrix<float> elevation_matrix <-  matrix<float>(image_file( \"images\/ITP_colored_100.tif\") as_matrix {300, 300});\n\tinit {\n\t\televation_matrix <- elevation_matrix * (30 \/ (min(elevation_matrix)-max(elevation_matrix)));\n\t\task elevation {\n\t\t\tgrid_value <- elevation_matrix at {grid_x, grid_y};\n\t\t}\n\t}\n}\n\n\ngrid elevation  width: 300 height: 300;\n\nexperiment \"3D\"  type:gui {\n\t\n\toutput {\n\t\t\n\t\tdisplay trees type: opengl\n\t\t{ \n\t\t\tgrid elevation elevation: elevation_matrix texture: image_file( \"images\/ITP_Reprojected_Filled_100.tif\") triangulation: true refresh: false;\n\t\t\t\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "show me how to collect one attribute value over a set of agent, in order to plot the minimum, maximum and average value in a chart",
        "output": "global {\nlist attvalues -> myagent collect (each.myattribute);\n}\n\nspecies myagent {\nfloat myattribute;\n}\n\nexperiment xp {\noutput {\ndisplay main {\nchart \"min max mean\" type:series {\n\t\t\t\tdata \"min\" value:min(attvalues);\n\t\t\t\tdata \"max\" value:max(attvalues);\n\t\t\t\tdata \"mean\" value:mean(attvalues);\n\t\t\t}\n}\n}\n}"
    },
    {
        "instruction": "I have an SIR model:\n\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  \/\/ The init number of people\n    int number_I <- 5 ;\t\/\/ The init number of infected\n    float infection_rate <- 0.1 ; \/\/ The infection rate\n\tfloat infection_distance <- 5.0 ; \/\/ infection distance (in meters)\n\tfloat dying_proba <- 0.01; \/\/probability to die at each step if infected\n\tint immune_step <- 100 ; \/\/ number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; \/\/ speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\n\nMake me an experiment to approximate the values for the infection rate and the dying probabilities that would be the best to minimize the number of dead in the simulation. We consider a simulation to be over after 5000 seconds in simulation time. infection_rate must be between 0.1 and 0.5 and dying_proba between 0.01 and 0.2. Use the simulated annealing method with an end temperature of 10.0, an initial temperature of 50 and a decrease step of 0.5",
        "output": "\/\/ This experiment explores two parameters with a Simulated annealing strategy,\n\/\/ repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n\/\/ in order to find the best combination of parameters to minimize the number of infected people\nexperiment Simulated_annealing type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod annealing  minimize: num_dead temp_decrease: 0.5 temp_end: 10.0 temp_init: 50;\n}"
    },
    {
        "instruction": "I have an SIR model:\n\n\nmodel batch_example\n\nglobal {\n    int number_people <- 100;  \/\/ The init number of people\n    int number_I <- 5 ;\t\/\/ The init number of infected\n    float infection_rate <- 0.1 ; \/\/ The infection rate\n\tfloat infection_distance <- 5.0 ; \/\/ infection distance (in meters)\n\tfloat dying_proba <- 0.01; \/\/probability to die at each step if infected\n\tint immune_step <- 100 ; \/\/ number of steps before becoming immune after infection\n\tfloat speed_people <- 5.0 ; \/\/ speed of the Host\n\n\tint num_dead <- 0;\n\tinit {\n\t\tfloat t <- machine_time;\n\t\tcreate people number: number_people ;\n        ask (number_I among people) {\n        \tis_infected <- true;\n        \tcolor <- #red;\n        }\n\t} \n\t\n\treflex write_info when: time = 5000  {\n\t\twrite sample(infection_rate) + \" \" + sample(dying_proba) + \" \" +sample(seed) + \" -> \" + sample(num_dead);\n\t}\n}\n\nspecies people skills:[moving] {\n\tbool is_infected <- false;\n\tbool is_immune <- false;\n\trgb color <- #green;\n\tint cpt <- 0;\n\treflex basic_move {\n\t\tdo wander speed: speed_people;\n\t}\n\n\treflex die when: is_infected {\n\t\tif flip(dying_proba) {\n\t\t\tnum_dead <- num_dead + 1;\n\t\t\tdo die;\n\t\t}\n\t}\n\treflex become_immune when: is_infected {\n\t\tif (cpt > immune_step) {\n\t\t\tcpt <- 0;\n\t\t\tis_immune <- true;\n\t\t\tis_infected <- false;\n\t\t\tcolor <-  #blue;\n\t\t} else {\n\t\t\tcpt <- cpt + 1;\n\t\t}\n\t}\n\treflex become_infected when: not is_infected and not is_immune{\n\t\tif (flip(infection_rate) and not empty(people at_distance infection_distance where each.is_infected)) {\n\t\t\tis_infected <- true;\n\t\t\tcolor <-  #red;\n\t\t}\n\t}\n\n\taspect default { \n\t\tdraw circle(1) color: color;\n    }\n}\n\nexperiment Simple type:gui {\n\tparameter 'Infection Rate:' var: infection_rate;\n\tparameter 'Infection Distance:' var: infection_distance;\n\toutput {\n\t\tmonitor \"nb of dead\" value: num_dead;\n\t\tdisplay map {\n\t\t\tspecies people aspect: default;\n\t\t}\n\t}\n}\n\nShow me all the different methods I can use to explore the different values of infection_rate and dying_proba to minimize num_dead by the end of the simulation once time becomes greater than 5000.\nFor each method create a new experiment and comment it to explain what happens.\nthe values of infection_rate and dying_proba should always be respectively between 0.1 and 0.5 and between 0.01 and 0.2.",
        "output": "\n\/\/ This experiment explores two parameters with a PSO strategy,\n\/\/ repeating each simulation three times (the aggregated fitness correspond to the mean fitness), \n\/\/ in order to find the best combination of parameters to minimize the number of infected people\nexperiment PSO type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod pso num_particles: 3 weight_inertia:0.7 weight_cognitive: 1.5 weight_social: 1.5  iter_max: 5  minimize: num_dead  ; \n}\n\n\/\/ This experiment explores two parameters with a GA strategy,\n\/\/ repeating each simulation three times (the aggregated fitness correspond to the min fitness), \n\/\/ in order to find the best combination of parameters to minimize the number of infected people\nexperiment Genetic type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod genetic pop_dim: 3 crossover_prob: 0.7 mutation_prob: 0.1 improve_sol: true stochastic_sel: false\n\tnb_prelim_gen: 1 max_gen: 5  minimize: num_dead  aggregation: \"min\";\n}\n\n\n\/\/ This experiment explores two parameters with a Hill Climbing strategy from an explicit init solution (if no solution is given, start from a random sol),\n\/\/ repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n\/\/ in order to find the best combination of parameters to minimize the number of infected people\nexperiment Hill_Climbing type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.1;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod hill_climbing init_solution:map([\"infection_rate\"::0.2, \"dying_proba\":: 0.05])  minimize: num_dead aggregation: \"max\";\n}\n\n\n\/\/ This experiment explores two parameters with a Tabu Search strategy,\n\/\/ repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n\/\/ in order to find the best combination of parameters to minimize the number of infected people\nexperiment Tabu_Search type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod tabu iter_max: 5 tabu_list_size: 5 minimize: num_dead aggregation: \"max\";\n}\n\n\/\/ This experiment explores two parameters with a Reactive Tabu Search strategy,\n\/\/ repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n\/\/ in order to find the best combination of parameters to minimize the number of infected people\nexperiment Reactive_Tabu_Search type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod reactive_tabu iter_max: 10 cycle_size_max: 10 cycle_size_min: 3 tabu_list_size_init: 5 minimize: num_dead aggregation: \"max\";\n}\n\n\/\/ This experiment explores two parameters with a Simulated annealing strategy,\n\/\/ repeating each simulation three times (the aggregated fitness correspond to the max fitness), \n\/\/ in order to find the best combination of parameters to minimize the number of infected people\nexperiment Simulated_annealing type: batch keep_seed: true repeat: 3 until: ( time > 5000 ) {\n\tparameter 'Infection rate' var: infection_rate min: 0.1 max:0.5 step:0.01;\n\tparameter 'Probability of dying:' var: dying_proba min: 0.01 max: 0.2 step:0.01;\n\tmethod annealing  minimize: num_dead temp_decrease: 0.5 temp_end: 10.0 temp_init: 50;\n}"
    },
    {
        "instruction": "Write a GAML code snippet that fabricates a model comprising macro-species agents, each containing a random number of micro-species agents, with the objective to log the count of micro-species for each macro-species upon initialization:\n\n\n1. Define the `global` context:\n  - Start with an `init` block in the global scope that commands the creation of 5 `macro_species` agents.\n\n\n2. Declare a species named `macro_species`:\n  - Inside the `init` block for each `macro_species` instance:\n    - Instantiate a random number (from 1 to 10) of `micro_species_in_group` agents.\n    - Compose a `write` statement to log a message. This message should include the unique `name` of the `macro_species` agent and the `length` (count) of `micro_species_in_group` agents it contains.\n\n\n3. Within `macro_species`, outline the sub-species `micro_species_in_group` with no additional properties or actions. Its definition remains empty as it serves as an agent count inside its `macro_species`.\n\n\n4. Set up an experiment by the name of `my_experiment` with the interface type `gui`. This should be left as an empty shell for further development, with no specific configurations or output prescribed at this time.\n\n\nThe resulting snippet will produce an outcome whereby upon each simulation start, each macro-species agent reports its number of micro-species agents, reflecting an agent-contained hierarchy and the dynamic instantiation of agents in GAML.\n",
        "output": "global {\n   init {\n   create macro_species number:5;\n   }\n}\n\n\nspecies macro_species  {   \n   init {\n   create micro_species_in_group number: rnd(10);\n   write \"the macro species agent named \"+name+\" contains \"+length(micro_species_in_group)+\" agents of micro-species.\";\n   }\n\n\n   species micro_species_in_group { }\n}\n\n\nexperiment my_experiment type: gui { }"
    },
    {
        "instruction": "Write a GAML code snippet illustrating the concept of agent interaction between two species, named `speciesA` and `speciesB`, each with initialization behaviors and reflexive actions revealing the nuances of self-referencing keywords:\n\n\n1. Establish an agent species identified as `speciesA`:\n  - In the `init` block, assign the string \"speciesA\" to the predefined attribute `name`, which serves as the agent's identifier.\n \n2. Within `speciesA`, craft a `reflex` titled `update` to perform actions based on certain conditions or at every simulation cycle:\n  - Engineer an `ask` directive within the reflex that sends a message to all `speciesB` agents.\n  - Instruct the code to execute two `write` statements inside the `ask` block:\n    - The first statement should simply output the value of `name` within the context of `speciesB`.\n    - The second statement should prepend the `self` reference to `name`, confirming the context-specific behavior of `self`.\n    - The third statement should use `myself.name` to clarify how the `myself` keyword refers back to the agent governed by the outermost scope, in this case, `speciesA`.\n\n\n3. Declare another agent species called `speciesB`:\n  - Similarly, during the initialization of `speciesB`, equate its `name` attribute to the string \"speciesB\".\n\n\nThe aim of this snippet is to demystify the distinctions of `self` and `myself` in a multi-agent system where species interact or reference each other, and to understand their respective outputs within differing scopes of action.",
        "output": "species speciesA {\n   init {\n       name <- \"speciesA\";\n   }\n   reflex update {\n       ask speciesB {\n           write name; \/\/ output : \"speciesB\"\n           write self.name; \/\/ output : \"speciesB\" write myself.name; \/\/ output : \"speciesA\" }\n       }\n   }\n}\nspecies speciesB {\n   init {\n       name <- \"speciesB\";\n   }\n}\n"
    },
    {
        "instruction": "I have a model file at the path \"..\/..\/Tutorials\/Predator Prey\/models\/Model 13.gaml\" I would like to reuse it but I don't want the it to save the simulation results as it is currently doing with the reflex save_result.\n\nCreate a model that could fix that",
        "output": "\nmodel Exploration\n\nimport \"..\/..\/Tutorials\/Predator Prey\/models\/Model 13.gaml\"\n\n\/*\n * Change a little bit the behavior of the world agent to remove the saving of results\n *\/\nglobal {\n\treflex save_result when: (nb_preys > 0) and (nb_predators > 0){ } \/\/ Overload method so we do not have any saved output\n\n}"
    },
    {
        "instruction": "Create a complete model to demonstrate the role of the restitution in the collision of objects in the box2D library, which simulates physical interactions in 2 dimensions.",
        "output": "model Box2D\n\nglobal parent: physical_world {\n\t\n\tint size <- 250;\n\t\n\tfloat seed <- machine_time;\n\tstring library <- \"box2D\";\n\t\/\/ The definition of the step plays a crucial role in the dynamics. If the physics engine can kick in at a high frequency, then the simulation is more accurate (but also slower). \n\t\/\/ The outcome of a model can be completely changed by the step. \n\tfloat step <- 1.0 \/ 100;\n\tfloat wall_restitution <- 1.0 min: 0.0 max: 2.0;\n\tfloat ball_restitution <- 0.9 min: 0.0 max: 1.0;\n\tgeometry shape <- box(size, size, 0.001);\n\tfloat friction <- 0.0;\n\tfloat restitution <- 0.0;\n\tbool accurate_collision_detection <- true; \/\/ expensive but much better\n\tint max_substeps <- 1;\n\tpoint ball_contact <- nil;\n\tint ball_timer <- 0;\n\tpoint wall_contact <- nil;\n\tint wall_timer <- 0;\n\tbool disturb <- true;\n\tlist<ball> movers;\n\n\tinit {\n\t\tdo register([self]);\n\n\t\tgeometry box <- box(size+3, 3, 10);\n\t\tcreate wall from: [box at_location ({size\/2, 0}), box rotated_by 90 at_location ({0, size\/2}), box at_location ({size\/2, size}), box rotated_by 90 at_location ({size, size\/2})];\n\t\tlist<point> starting_places <- [{5,5}, {5,size-5},{size-5,5}, {size-5,size-5}];\n\t\tcreate ball from: starting_places collect (circle(4) at_location each) with: [mass::10, color::#cadetblue, speed::30] returns: balls;\n\t\tmovers <-balls;\n\t\tloop x from: 5 to: size-5 step: 10 {\n\t\t\tloop y from: 5 to: size-5 step: 10 {\n\t\t\t\tif (x = 5) or (x = size-5) {\n\t\t\t\t\tif (y = 5) or (y = size-5) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tfloat n <- rnd(1.0, 4.5);\n\t\t\t\tcreate ball with: [shape::circle(n) at_location {x,y},mass::n, color::brewer_colors(\"Set3\")[int(n)], speed::n*2] {\n\t\t\t\t\tinitial_location <- location;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t\n\n\t}\n\t\n\treflex when: every(1000#cycle){\n\t\task movers{\n\t\t\tfloat s <- speed * 2;\n\t\t\tvelocity <- velocity + {(rnd(s) * rnd(-1.0,1.0)), (rnd(s) * rnd(-1.0,1.0))};\n\t\t}\n\t}\n\n}\n\nspecies wall skills: [static_body] {\n\tfloat restitution <- wall_restitution;\n\tfloat friction <- 0.1;\n}\n\nspecies ball skills: [dynamic_body, moving] {\n\tpoint initial_location;\n\tfloat contact_damping <- 0.1;\n\tfloat damping <- 0.1;\n\tfloat angular_damping <- 0.0;\n\tfloat restitution <- ball_restitution;\n\tfloat friction <- 0.1;\n\trgb color ;\/\/<- one_of(brewer_colors(\"Set3\"));\n\n\n\treflex go_back when: every(10#cycle) and (abs(velocity.x) between(0.0,1.0)) and (abs(velocity.y) between(0.0,1.0)) {\n\t\tdo goto target: initial_location;\n\t}\n\n}\n\nexperiment \"Disturbance\" type: gui {\n\t\n\n\n\timage_file bang <- image_file(\"..\/images\/bang.png\");\n\timage_file bam <- image_file(\"..\/images\/bam.png\");\n\ttext \"This experiment uses the Box2D library to display particles that are disturbed randomly and try to get back to their original location when this happens. Try stopping the disturbance or increasing or decreasing the restitution to see what happens. Agents are provided also with the moving skill, and it is a good example of mixing a physics-based with a behavior-based dynamics\";\n\n\toutput {\n\t\tlayout #split;\n\t\tdisplay \"Restitution\" type: 3d antialias: true axes: false {\n\n\t\t\tspecies ball {\n\t\t\t\tdraw shape color: color;\n\t\t\t\tdraw line(location, location + velocity) color: #black end_arrow: 1 width: 1;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}"
    },
    {
        "instruction": "Create a complete model showing water flowing in a river bed.",
        "output": "model Terrain\n\nglobal parent: physical_world {\n\tbool use_native <- true;\n\t\/\/ We scale the DEM up a little\n\tfloat z_scale <- 0.5;\n\tfloat step <-  1.0\/30;\t\n\tbool flowing <- true;\n\tpoint gravity <- {-z_scale\/4, z_scale, -9.81};\n\tint number_of_water_units <- 1 min: 0 max: 10;\n\tlist<point> origins_of_flow <- [{17,3}, {55,3}];\n\tfield terrain <- field(grid_file(\"..\/images\/DEM\/RedRiver.asc\"));\n\n\tgeometry shape <- box({terrain.columns, terrain.rows, max(terrain)*z_scale});\n\tfloat friction <- 0.0;\n\tfloat restitution <- 0.5;\n\n\n\tinit {\n\t\tdo register([self]);\n\t}\n\n\treflex flow {\n\t\t\tloop origin_of_flow over: origins_of_flow {\n\t\t\t\tint x <- int(min(terrain.columns - 1, max(0, origin_of_flow.x + rnd(10) - 5)));\n\t\t\t\tint y <- int(min(terrain.rows - 1, max(0, origin_of_flow.y + rnd(10) - 5)));\n\t\t\t\tpoint p <- origin_of_flow + {rnd(10) - 5, rnd(10 - 5), terrain[x, y] + 4};\n\t\t\t\tcreate water number: number_of_water_units with: [location::p];\n\t\t\t}\n\t}\n}\n\nspecies water skills: [dynamic_body] {\n\tgeometry shape <- sphere(1.0);\n\tfloat friction <- 0.0;\n\tfloat damping <- 0.0;\n\tfloat mass <- 0.5;\n\trgb color <- one_of(brewer_colors(\"Blues\"));\n\t\n\n\taspect default {\n\t\tif (location.y > 10){\n\t\tdraw shape color: color;}\n\t}\n\t\n\t\t\n\treflex manage_location when: location.z < -20 {\n\t\tdo die;\n\t}\n\n} \n\nexperiment \"Four different scales\" type: gui {\n\t\n\tstring camera_loc <- #from_up_front;\n\tint distance <- 200;\n\t\n\taction _init_ {\n\t\tcreate simulation with: [z_scale::0.3];\n\t\tcreate simulation with: [z_scale::1.0];\n\t\tcreate simulation with: [z_scale::2.0];\n\t\tcreate simulation with: [z_scale::3.0];\n\t} \n\tparameter \"Location of the camera\" var: camera_loc among: [#from_up_front, #from_above, #from_up_left, #from_up_right];\n\tparameter \"Distance of the camera\" var: distance min: 1 max: 1000 slider: true;\n \tparameter \"Number of water agents per cycle\" var: number_of_water_units;\n\t\n\toutput {\n\t\tlayout #split;\n\t\tdisplay \"Flow\" type: 3d background: #white   antialias: false {\n\t\t\tcamera #default location: camera_loc distance: distance dynamic: true;\n\t\t\tgraphics world {\n\t\t\t\tdraw \"Scale: \" + z_scale color: #cadetblue font: font(\"Helvetica\", 18, #bold) at: {world.location.x, -10, 25} anchor: #center depth: 2 rotate: -90::{1,0,0};\n\t\t\t\tdraw aabb wireframe: true color: #lightblue;\n\t\t\t}\n\t\t\tmesh terrain grayscale: true triangulation: true refresh: false scale: z_scale smooth: 2;\n\t\t\tspecies water;\n\t\t\tevent #mouse_down {\n\t\t\t\tpoint p <- #user_location;\n\t\t\t\torigins_of_flow << {p.x, p.y};\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\t\n\t\n\t}\n\t\nexperiment \"Largest scale\" type: gui {\n\t\n\tstring camera_loc <- #from_up_front;\n\tint distance <- 200;\n\t\n\taction _init_ {\n\t\tcreate simulation with: [z_scale::3.0];\n\t} \n\t\n\toutput {\n\t\tlayout #split;\n\t\tdisplay \"Flow\" type: 3d background: #white   antialias: false camera: #from_up_front{\n\t\t\tmesh terrain grayscale: true triangulation: true refresh: false scale: z_scale;\n\t\t\tspecies water;\n\t\t}\n\n\t}}\n\t"
    },
    {
        "instruction": "Create a complete model that shows falling objects to demonstrate how the physics engine works. Ball agents fall on a floor, giggle a bit, exchange colors, and fall from the floor to the void. The user can click on any of them to give it some impulse.\n",
        "output": "model Falling\n\n\n\nglobal parent: physical_world {\n\tbool use_native <- true;\n\tfloat restitution <- 0.8; \/\/ the \"bounciness\" of the world\n\tfloat friction <- 0.2; \/\/ the deceleration it imposes on other objects\n\tint environment_size <- 500; \n\tint max_substeps <-0;\n\tfloat step <- 0.006; \n\tgeometry shape <- box(environment_size,environment_size,10);\n\t\n\tinit {\n\t\t\/\/If the world is to be considered as a physical object in the world, it must register itself\n\t\tdo register([self]);\n\t\tcreate ball number: 100;\n\t}\n} \n\n\nspecies ball skills: [dynamic_body] {\n\tfloat radius <- float(rnd(25) + 1);\n\tgeometry shape <- flip(0.3) ? cube(radius) : (flip(0.5) ? sphere(radius) : cone3D(radius, radius));\n\tpoint location <- {rnd(environment_size), rnd(environment_size), rnd(environment_size)};\n\trgb color <- #grey;\n\tfloat restitution <- 0.7;\n\tfloat mass <- 1.0;\n\tfloat damping <- 0.1;\n\tfloat angular_damping <- 0.3;\n\tfloat friction <- 0.2;\n\n\t\/\/ A callback method when a contact is made with another agent. Here, we simply take its color\n\taction contact_added_with (agent other) {\n\t\tif (other is ball) {\n\t\t\tshape <- shape * 1.01;\t\n\t\t\tcolor <- rnd_color(255);\t\t\n\t\t\tdo update_body;\n\t\t}\n\t}\n\n\treflex manage_location when: location.z < -20 {\n\t\tdo die;\n\t}\n\n\taspect default {\n\t\tdraw shape color: color rotate: rotation;\n\t\t\/\/ We can also draw the bounding box of the agent in the physical world\n\/\/\tdraw aabb color: #black wireframe: true;\n\t}\n\n}\n\nexperiment Display type: gui {\n\toutput {\t\n\t\tdisplay Falling  type: 3d background:rgb(128,128,128) axes:false{\n\t\t\tcamera 'default' location: {177.8131,883.5764,615.7961} target: {250.0,250.0,0.0};\n\t\t\tgraphics World refresh: false{\n\t\t\t\t draw shape color: #white;\n\t\t\t}\n\t\t\tevent #mouse_down {\n\t\t\t\tball target <- ball with_min_of(each distance_to #user_location);\n\t\t\t\task target {\n\t\t\t\t\tdo apply impulse: {rnd(10)-5,rnd(10)-5,50}; \/\/ vertical, with some random side moves\n\t\t\t\t}\n\t\t\t}\n\t\t    species ball;\t\t\t\n\t\t}\n\n\t}\n}\n"
    },
    {
        "instruction": "Develop a GAML code snippet that defines a species with a reflexive behavior to internally record nearby agents. The objectives are:\n\n\n1. Begin by declaring an agent species named `my_species`.\n2. Within this new species, outline a reflex named `update` to be executed regularly as part of the simulation cycle:\n  - Inside the reflex, generate a local variable `neighbors` of type `list<agent>`.\n  - Assign `neighbors` with the result of the `agents at_distance(5)` function call. This operation should collect all agents residing within a radius of 5 meters from the calling agent.\n\n\nThe desired snippet serves to develop the capability for an agent to assess its immediate environment and maintain a list of proximate agents, which is a foundational concept in simulating agent-environment interactions within the GAML paradigm.\n",
        "output": "species my_species {\n   reflex update {\n       \/\/ neighbors contains the list of all the agents located at a distance <= 5 from the caller agent.\n       list<agent> neighbors <- agents at_distance(5);\n   }\n}\n"
    },
    {
        "instruction": "Create ball species for falling objects model.",
        "output": "species ball skills: [dynamic_body] {\n\tfloat radius <- float(rnd(25) + 1);\n\tgeometry shape <- flip(0.3) ? cube(radius) : (flip(0.5) ? sphere(radius) : cone3D(radius, radius));\n\tpoint location <- {rnd(environment_size), rnd(environment_size), rnd(environment_size)};\n\trgb color <- #grey;\n\tfloat restitution <- 0.7;\n\tfloat mass <- 1.0;\n\tfloat damping <- 0.1;\n\tfloat angular_damping <- 0.3;\n\tfloat friction <- 0.2;\n\n\t\/\/ A callback method when a contact is made with another agent. Here, we simply take its color\n\taction contact_added_with (agent other) {\n\t\tif (other is ball) {\n\t\t\tshape <- shape * 1.01;\t\n\t\t\tcolor <- rnd_color(255);\t\t\n\t\t\tdo update_body;\n\t\t}\n\t}\n\n\treflex manage_location when: location.z < -20 {\n\t\tdo die;\n\t}\n\n\taspect default {\n\t\tdraw shape color: color rotate: rotation;\n\t\t\/\/ We can also draw the bounding box of the agent in the physical world\n\/\/\tdraw aabb color: #black wireframe: true;\n\t}\n\n}"
    },
    {
        "instruction": "Develop a GAML code snippet that defines a species with a reflexive behavior to internally record nearby agents. The objectives are:\n\n\n1. Begin by declaring an agent species named `my_species`.\n2. Within this new species, outline a reflex named `update` to be executed regularly as part of the simulation cycle:\n  - Inside the reflex, generate a local variable `neighbors` of type `list<agent>`.\n  - Assign `neighbors` with the result of the `agents at_distance(5)` function call. This operation should collect all agents residing within a radius of 5 metres from the calling agent.\n\n\nThe desired snippet serves to develop the capability for an agent to assess its immediate environment and maintain a list of proximate agents, which is a foundational concept in simulating agent-environment interactions within the GAML paradigm.\n",
        "output": "species my_species {\n   reflex update {\n       \/\/ neighbors contains the list of all the agents located at a distance <= 5 from the caller agent.\n       list<agent> neighbors <- agents at_distance(5);\n   }\n}\n"
    },
    {
        "instruction": "Create a complete model of a vulcano, which is situated at the highest point of a DEM, erupts and the lava, falling down on the ground, erodes every patch of terrain it touches. The slope of the terrain evolves as more and more lava is produced (the epicenter of the eruption even changing when higher patches appear).",
        "output": "model Vulcano\n\/**\n * The model is inheriting from 'physical_world' a special model species that provides access to the physics engine -- and the possibility\n * to manage physical agents. In this model, the world itself is not a physical agent\n *\/\nglobal parent: physical_world {\n\tbool use_native <- true;\n\t\/\/Step (in #sec) passed to the physics engine. The same step is used for the simulation and the physics engine. The accuracy and synchronization\n\t\/\/between the two can be controlled by max_substeps. A too large step (e.g. 1#sec) would make the lava 'pass through' the ground (tunnel effect).\n\t\/\/A too small (e.g. 0.01), while more accurate, would, given the velocity of the lava, slow everything down on useless computations.\n\tfloat step <-  0.05;\n\t\/\/A boolean that controls whether or not the lava will erode the ground\n\tbool erosion;\n\tfloat uncertainty -> {rnd(10.0) - 5};\n\t\/\/ Support for display parameters\n\tbool show_legend;\n\tbool draw_inside;\n\t\/\/Every step the world creates a lava agent near the top of the highest patch in the terrain. It is provided with an initial high vertical velocity.\n\treflex flow {\n\t\tpatches highest <- patches with_max_of each.grid_value;\n\t\task highest {\n\t\t\tcreate lava number: 1 {\n\t\t\t\tlocation <- {highest.location.x + uncertainty, highest.location.y + uncertainty, highest.grid_value + uncertainty};\n\t\t\t\tvelocity <- velocity + {0,0,rnd(60) - 20};\n\t\t\t}\n\t\t}\n\t}\n}\n\n\/**\n * The patches come as a grid created after a simple DEM file and each cell is provided with a 'static body' in the physical world. The whole grid represents\n * an approximate terrain (or heightmap). Since the patches are agents, they can individually respond to events or have their own behavior, making the whole \n * a powerful way to describe dynamic environments.\n *\/\ngrid patches file: grid_file(\"..\/images\/DEM\/Volcano DEM.asc\") skills: [static_body] {\n\tfloat friction <- 0.5;\n\tfloat restitution <- 0.2;\n\t\n\t\/\/This action is a 'callback' action, one of the two (with 'contact_removed_with') called by the physics engine when a contact occurs between two agents. \n\t\/\/ When redefined, it allows agents to react to contacts. Here, every new contact with a lava agent makes a patch decrease its height (grid_value) \n\t\/\/ and that of its neigbors by a small amount, as well as stop the lava agent quite brutally (clearing all the forces applied to it) to imitate \"stickiness\"\n\taction contact_added_with (agent other) {\n\t\tif (erosion) {\n\t\t\tgrid_value <- max(0,grid_value - 0.01);\n\t\t\task neighbors {\n\t\t\t\tgrid_value <- max(0,grid_value - 0.005);\n\t\t\t\tdo update_body;\n\t\t\t}\n\t\t\tdo update_body;\n\t\t}\n\t}\n\t\n\taspect default {\n\t\tif (draw_inside) {draw aabb wireframe: true border: #white;}\n\t}\n}\n\n\/**\n * Species that represents the lava erupting from the vulcano. Their physical body will be a sphere, weighting 4#kg, offering no restitution but a lot of friction.\n *\/\nspecies lava skills: [dynamic_body] {\n\tgeometry shape <- sphere(0.75);\n\tfloat mass <- 1.0;\n\trgb color <- one_of (brewer_colors(\"Reds\"));\n\tfloat restitution <- 0.2;\n\tfloat friction <- 0.3;\n\tfloat damping <- 0.1;\n\tfloat angular_damping<-0.1;\n\n\t\/\/When a lava agent falls from the edges of the world, it is removed from the simulation (and the physical world as well).\t\t\n\treflex manage_location when: location.z < -20 {\n\t\tdo die;\n\t}\n\t\n\taspect default {\n\t\tdraw shape color: color; \n\t\tif (draw_inside) {\n\t\t\tdraw aabb color: #lightblue wireframe: true;\n\t\t\tdraw line(location, location+velocity) color: #yellow end_arrow: 1 width: 1;\n\t\t}\n\t}\n\n} \n\n\nexperiment \"3D view\" type: gui {\n\tfont title  <- font(\"Helvetica\", 12, #bold);\n\tparameter \"Show inside structures (velocities and aabbs)\" var: draw_inside <- false;\n\tparameter \"Better collision detection\" var: accurate_collision_detection <- false;\n\tparameter \"Enable erosion\" var: erosion <- false;\n\tparameter \"Show legend\" var: show_legend <- true;\n\toutput {\n\t\t\n\t\tdisplay \"3D\" type: 3d axes: false background: #black camera:#from_up_front antialias: false {\n\t\t\tgraphics title {\n\t\t\t\tif (show_legend) {\n\t\t\t\t\tdraw \"Average height \" + (patches mean_of each.grid_value) with_precision 2 + \" \/ # of lava agents \" + length(lava) color: #white font: title at: {world.location.x, 100, patches max_of each.grid_value + 10} anchor: #center depth: 2 rotate: -20::{1,0,0};\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/The terrain is represented as a field (but could be equally represented as a grid\t\t\n\t\t\tmesh patches  texture: image_file(\"..\/images\/DEM\/Volcano Texture.jpg\") triangulation: true ;\n\t\t\t\/\/We add to the representation the individual 'aabb's (axis-aligned bounding boxes) of the patches if 'draw_inside' is true\n\t\t \t\/\/species patches;\n\t\t \t\/\/Finally, each lava agent is represented (with its velocity if 'draw_inside' is true)\n\t\t\tspecies lava;\n\t\t}\n\n\t}\n\n}"
    },
    {
        "instruction": "Assuming I have a field called \"heatmap\", create a species named \"worm\" with the moving skill. Define two reflexes within this species: \"wander\" and \"mark\". The \"wander\" reflex should move the worm randomly with an amplitude of 5.0 and a speed of 0.01. The \"mark\" reflex should update the heatmap field by adding 0.1 to the value at the worm's current location.",
        "output": "species worm skills: [moving] {\n\t\n\treflex wander {\n\t\tdo wander amplitude: 5.0 speed: 0.01;\n\t}\n\t\n\treflex mark {\n\t\theatmap[location] <- (heatmap[location]) + 0.1;\n\t}\n}"
    },
    {
        "instruction": "Write a GAML code snippet for a model entitled `connect_the_neighbors` that simulates autonomous agents within a space, exhibits their movement, and visually connects each agent with its neighbors under certain conditions:\n\n\n1. Start with the model definition, `model connect_the_neighbors`.\n2. In the `global` scope, declare three variables:\n  - `speed`, a floating-point variable, which dictates the randomness of agent movement, initialized to `0.2`.\n  - `distance_to_intercept`, another float, representing the maximum distance at which agents will visually connect to one another, set to `10.0`.\n  - `number_of_circle`, an integer that represents the total number of agents to create, initialized to `100`.\n3. In the same global scope, write an `init` block that creates `number_of_circle` instances of `my_species`.\n\n\n4. Define the species `my_species`:\n  - Incorporate a reflex called `move` that randomly alters the location of an agent within a speed-limited range.\n  - Visualize `my_species` with an `aspect default`: Draw each agent as a yellow circle with a black border.\n  - Within the aspect code, use the `ask` command to select neighboring agents within `distance_to_intercept`:\n    - For each neighboring agent, draw a polyline from the neighbor (`self.location`) to the current agent (`myself.location`), representing the connection with a black line.\n\n\n5. Draft an experiment named `my_experiment` with a graphical user interface (`gui`):\n  - Under this experiment, define an `output` block containing a `display` named `myDisplay`.\n  - Inside the display configuration, specify that instances of `my_species` should be shown using the `default` aspect.\n\n\nFollowing the completion of these steps, the model will illustrate how agents can move independently within a virtual space and dynamically identify and visually connect with proximate agents.\n",
        "output": "model connect_the_neighbors\nglobal{\n   float speed <- 0.2;\n   float distance_to_intercept <- 10.0;\n   int number_of_circle <- 100;\n   init {\n       create my_species number:number_of_circle;\n   }\n}\nspecies my_species {\n   reflex move {\n       location <- {location.x+rnd(-speed,speed),location.y+rnd(-speed,speed)};\n   }\n   aspect default {\n   draw circle(1) color: #yellow border: #black;\n   ask my_species at_distance(distance_to_intercept) {\n       draw polyline([self.location,myself.location]) color:#black; }\n   }\n}\nexperiment my_experiment type:gui {\n   output{\n       display myDisplay {\n           species my_species aspect:default;\n       }\n   }\n}\n"
    },
    {
        "instruction": "Create a complete model showing waterflow from a digital elevation model (DEM). Upstream and downstream cells are determined automatically.",
        "output": "model WaterOnFields\n\n\nglobal {\n\tgrid_file dem_file <- file(\"..\/includes\/DEM_100m_PP.asc\");\n\tfield terrain <- field(dem_file) ;\n\tfield flow <- field(terrain.columns,terrain.rows);\n\t\/\/Shape of the environment using the dem file\n\tgeometry shape <- envelope(dem_file);\n\tbool fill <- false;\n\n\t\/\/Diffusion rate\n\tfloat diffusion_rate <- 0.8;\n\tint frequence_input <- 3;\n\tlist<point> drain_cells <- [];\n\tlist<point> source_cells <- [];\n\tmap<point, float> heights <- [];\n\tlist<point> points <- flow points_in shape;\n\tmap<point, list<point>> neighbors <- points as_map (each::(flow neighbors_of each));\n\tmap<point, bool> done <- points as_map (each::false);\n\tmap<point, float> h <- points as_map (each::terrain[each]);\n\tfloat input_water;\n\tinit {\n\t\tgeometry river_g <- first( file(\"..\/includes\/river.shp\"));\n\t\tfloat c_h <- shape.height\/flow.rows;\n\t\tlist<point>  rivers_pt <- points where ((each overlaps river_g) and (terrain[each] < 100.0)) ;\n\t\tif (fill) {\n\t\t\tloop pt over: rivers_pt  {\n\t\t\t\tflow[pt] <- 1.0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tloop pt over: rivers_pt  {\n\t\t\tif (pt.y <  (c_h)) {\n\t\t\t\tsource_cells <<pt;\n\t\t\t}\n\t\t}\t\n\t\tloop pt over: rivers_pt  {\n\t\t\tif (pt.y > (shape.height - (c_h) )) {\n\t\t\t\tdrain_cells <<pt;\n\t\t\t}\n\t\t}\t\n\t\t\n\t}\n\n\t\/\/Reflex to add water among the water cells\n\treflex adding_input_water when: every(frequence_input#cycle){\n\t\tloop p over: source_cells {\n\t\t\tflow[p] <- flow[p] + input_water;\n\t\t}\n\t}\n\n\t\/\/Reflex for the drain cells to drain water\n\treflex draining  {\n\t\tloop p over: drain_cells {\n\t\t\tflow[p] <- 0.0;\n\t\t}\n\t}\n\n\n\tfloat height (point c) {\n\t\treturn h[c] + flow[c];\n\t}\n\n\t\/\/Reflex to flow the water according to the altitude and the obstacle\n\treflex flowing {\n\t\tdone[] <- false;\n\t\theights <- points as_map (each::height(each));\n\t\tlist<point> water <- points where (flow[each] > 0) sort_by (heights[each]);\n\t\tloop p over: points - water {\n\t\t\tdone[p] <- true;\n\t\t}\n\t\tloop p over: water {\n\t\t\tfloat height <- height(p);\n\t\t\tloop flow_cell over: (neighbors[p] where (done[each] and height > heights[each])) sort_by heights[each]  {\n\t\t\t\tfloat water_flowing <- max(0.0, min((height - heights[flow_cell]), flow[p] * diffusion_rate));\n\t\t\t\tflow[p] <- flow[p] - water_flowing;\n\t\t\t\tflow[flow_cell] <- flow[flow_cell] + water_flowing;\n\t\t\t\theights[p] <- height(p) ;\n\t\t\t\theights[flow_cell] <- height(flow_cell) ;\n\t\t\t}\n\t\t\tdone[p] <- true;\n\t\t}\n\t}\n}\n\n\nexperiment hydro type: gui {\n\tparameter \"Input water at source\" var: input_water <- 1.0 min: 0.0 max: 3.0 step: 0.1;\n\tparameter \"Fill the river\" var: fill <- true;\n\toutput {\n\t\tdisplay d type: 3d {\n\t\t\tcamera 'default' location: {7071.9529,10484.5136,5477.0823} target: {3450.0,3220.0,0.0};\n\t\t\tmesh terrain scale: 10 triangulation: true  color: palette([#burlywood, #saddlebrown, #darkgreen, #green]) refresh: false smooth: true;\n\t\t\tmesh flow scale: 10 triangulation: true color: palette(reverse(brewer_colors(\"Blues\"))) transparency: 0.5 no_data:0.0 ;\n\t\t}\n\n\t}\n\n}\n"
    },
    {
        "instruction": "Load a DEM file as a grid.",
        "output": "grid_file dem_file <- file(\"..\/includes\/DEM_100m_PP.asc\");"
    },
    {
        "instruction": "You are tasked to write a GAML code snippet that establishes a hierarchy of species in which a child species inherits a movement skill from its parent and exhibits its own distinct movement behavior:\n\n\n1. Define a primary species named `mother_species`:\n  - Endow `mother_species` with the `moving` skill from the list of GAMA built-in skills to grant basic movement functionalities.\n\n\n2. Create a `child_species` that forms a subclass of `mother_species`:\n  - In the `init` block of `child_species`, initialize the `speed` attribute to `2.0`, specifying how fast the agents of this species will move.\n  - Add a `reflex` named `update`, stimulated at each simulation step, where the agents perform the `wander` action derived from the `moving` skill, allowing them to move randomly within the environment.\n\n\nEnsure the correct parent-child species relationship is portrayed, demonstrating the inheritance of skills and the customization of properties within the GAML framework.\n",
        "output": "species mother_species skills:[moving] { }\nspecies child_species parent:mother_species {\n   init {\n       speed <- 2.0;\n   }\n   reflex update {\n       do wander;\n   }\n}\n"
    },
    {
        "instruction": "Create a complete model of water flow where space is discretised in a grid. The river is a set of cells, each of them with an elevation. The data comes from a data elevation model (DEM) file. The upstream cells (i.e. the source cells) and the downstrem cells (i.e. the drain cells) are chosen by the modeler. At each step, the cells transmits a part of their water to their neighbor cells that are lower (their height is computed taken into account their elevation and height of water.",
        "output": "model Waterflowgridelevation\n\nglobal {\n\tfile dem_file <- file(\"..\/includes\/DEM_100m_PP.asc\");\n\tfile river_file <- file(\"..\/includes\/river.shp\");\n \n  \t \/\/Shape of the environment using the dem file\n  \t geometry shape <- envelope(dem_file);\n\t\n\t\/\/Diffusion rate\n\tfloat diffusion_rate <- 0.8;\n\t\n\tlist<cell> drain_cells;\n\tlist<cell> source_cells;\n\t\n\tfloat input_water;\n\t\n\tinit {\n\t\tcreate river from: river_file;\n\t\tdo init_cells;\n\t\tdo init_water;\n   \t  \t\/\/Initialization of the drain cells\n\t\tdrain_cells <- cell where (each.is_drain);\n\t\tsource_cells <- cell where(each.is_source);\n\t\task cell {do update_color;}\n\t}\t\n\t\n   \/\/Action to initialize the altitude value of the cell according to the dem file\n   action init_cells {\n      ask cell {\n         altitude <- grid_value;\n         neighbour_cells <- (self neighbors_at 1) ;\n      }\n   }\t\n   \n   action init_water {\n      ask cell overlapping first(river) {\n         \/\/water_height <- 3.0;\n         is_source <- grid_y = 0;\n         is_drain <- grid_y = matrix(cell).rows - 1;\n      }\n   }   \n\n   \/\/Reflex to add water among the water cells\n   reflex adding_input_water {\n   \t  float water_input <- input_water;\n      ask source_cells {\n         water_height <- water_height + water_input;\n      }\n   }\n   \n   \/\/Reflex to flow the water according to the altitute and the obstacle\n   reflex flowing {\n      ask cell {already <- false;}\n      ask (cell sort_by ((each.altitude + each.water_height))) {\n         do flow;\n      }\n   }\n   \n   \/\/Reflex to update the color of the cell\n   reflex update_cell_color {\n      ask cell {\n         do update_color;\n      }\n   }\n   \n   \/\/Reflex for the drain cells to drain water\n   reflex draining when: false{\n      ask drain_cells {\n         water_height <- 0.0;\n      }\n   }   \n\t\n\/\/\treflex d {\n\/\/\t\twrite \"min  \" + cell min_of(each.grid_value);\n\/\/\t\twrite \"max  \" + cell max_of(each.grid_value);\t\t\n\/\/\t}\n}\n\n   grid cell file: dem_file neighbors: 8 frequency: 0  use_regular_agents: false use_individual_shapes: false use_neighbors_cache: false {\n\tfloat altitude;\n\tfloat water_height;\n\tfloat height;\n\tlist<cell> neighbour_cells;\n\tbool is_drain;\n\tbool is_source;\n\tbool already;\n\n     \/\/Action to flow the water \n      action flow {\n      \t\/\/if the height of the water is higher than 0 then, it can flow among the neighbour cells\n         if (water_height > 0) {\n         \t\/\/We get all the cells already done\n            list<cell> neighbour_cells_al <- neighbour_cells where (each.already);\n            \/\/If there are cells already done then we continue\n            if (!empty(neighbour_cells_al)) {\n               \/\/We compute the height of the neighbours cells according to their altitude, water_height and obstacle_height\n               ask neighbour_cells_al {height <- altitude + water_height ;}\n               \/\/The height of the cell is equals to its altitude and water height\n               height <-  altitude +  water_height;\n               \/\/The water of the cells will flow to the neighbour cells which have a height less than the height of the actual cell\n               list<cell> flow_cells <- (neighbour_cells_al where (height > each.height)) ;\n               \/\/If there are cells, we compute the water flowing\n               if (!empty(flow_cells)) {\n                  loop flow_cell over: shuffle(flow_cells) sort_by (each.height){\n                     float water_flowing <- max([0.0, min([(height - flow_cell.height), water_height * diffusion_rate])]); \n                     water_height <- water_height - water_flowing;\n                     flow_cell.water_height <-flow_cell.water_height +  water_flowing;\n                     height <- altitude + water_height;\n                  }   \n               }\n            }\n         }\n         already <- true;\n      }  \n      \/\/Update the color of the cell\n      action update_color { \n         int val_water <- 0;\n         val_water <- max([0, min([255, int(255 * (1 - (water_height \/ 12.0)))])]) ;  \n         color <- rgb([val_water, val_water, 255]);\n         grid_value <- water_height + altitude;\n      }\n}\n\nspecies river {\n\taspect default {\n\t\tdraw shape color: #red;\n\t}\n}\n\nexperiment hydro type: gui {\n\tparameter \"input water\" var: input_water <- 1.0;\n\toutput {\n\t\tdisplay d type:2d antialias:false{\n\t\t\tgrid cell border: #black;\n\t\t\t\/\/species river;\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Create a GAML code snippet that simulates the relationship between a parent species 'mother' and a subspecies 'child', and defines a function to count all instances of a species, including its subspecies:\n\n\n1. Initiate a `global` scope:\n  - Within the `init` section, instruct the creation of 2 `child` agents and 1 `mother` agent.\n\n\n2. Within the `global` scope, define a `reflex` named `update`:\n  - This reflex should invoke a `write` action to display the total number of `mother` agents. Note that this count should include all instances of `mother`, as well as all instances of any subspecies therein.\n\n\n3. Provide a method `get_all_instances` in the same global context:\n  - This method should accept one parameter, `spec`, typed as a generic `species<agent>`.\n  - It should return a list of all agent instances of the given species `spec`, plus all agent instances from any of its subspecies. Utilize the `+` operator to concatenate the populations and apply `accumulate` in conjunction with `get_all_instances(each)` to recursively include all subspecies' instances.\n\n\n4. Declare an agent species labeled `mother`, which does not require additional configuration for this task.\n\n\n5. Define a subspecies named `child` that is a descendant of the `mother` species.\n\n\nAfter completing these steps, the code should allow the simulation to run and effectively count the total number of 'mother' and 'child' instances, considering the 'child' agents as part of the 'mother' group for tallying purposes.\n",
        "output": "global\n{\n   init {\n           create child number: 2;\n           create mother number: 1;\n       }\n   reflex update {\n       write length(get_all_instances(mother)); \/\/ will write 3 (1+2)\n   }\n   list<agent> get_all_instances(species<agent> spec) {\n       return spec.population + spec.subspecies accumulate (get_all_instances(each));\n   }\n}\nspecies mother {}\nspecies child parent: mother {}\n"
    },
    {
        "instruction": "Develop a GAML code snippet that defines the dynamics of a population through the lens of individual lifespan and birth processes. Begin by declaring a species named 'people.' Each person should have an 'age' attribute that initializes based on a Gaussian distribution with a mean of 40 and a standard deviation of 15.\n\n\nEach simulation step, individuals should experience a 'reflex' named 'older,' signifying the passage of time, which increments their age by 1.\n\n\nAdditionally, conceptualize a 'reflex' named 'die,' which introduces the concept of mortality based on the individual's age, with the chance of dying increasing progressively with age. This reflex should be triggered by a probabilistic condition, simulating a natural death process with a small likelihood dependent on age.\n\n\nUpon the event of death, a new individual should be immediately created signifying birth, with 'age' initialized to 0 to represent an infant. Also, ensure the original individual is removed from the population post-creation of the new individual, simulating the cycle of life and death in the population.\n",
        "output": "species people {\n   float age <- gauss(40.0, 15.0);\n   reflex older {\n       age <- age + 1;\n   }\n   reflex die when: flip(age \/ 1000) {\n       create people {\n           age <- 0.0;\n       }\n       do die;\n   }\n}\n"
    },
    {
        "instruction": "Create a complete model showing water flow in a river graph, using water flow in rivers. The graph is created from a shapefile. THe points of interest in the river also comes from a poi shapefile. The flow of water is modeled through the exchange of water between elements of rivers. Then the water flows toward the outlet point. ",
        "output": "model Waterflowrivergraph\n\nglobal {\n\tfile river_shape_file <- shape_file(\"..\/includes\/rivers.shp\");\n\tfile poi_file <- shape_file(\"..\/includes\/poi.shp\");\n\n\tgeometry shape <- envelope(river_shape_file) + 500;\n\t\n\tgraph the_river;\n\tpoi outlet;\n\n\tinit {\n\t\tcreate river from: river_shape_file;\n\t\tcreate poi from: poi_file;\n\t\toutlet <- poi first_with(each.type = \"outlet\");\n\t\tthe_river <- as_edge_graph(river);\n\t\n\t\task poi - outlet{\n\t\t\tclosest_river <- river closest_to self;\n\t\t\tpath path_to_outlet <- path_between(the_river,self,outlet);\n\t\t\tloop i from: 0 to: length(path_to_outlet.edges) - 2 {\n\t\t\t\triver(path_to_outlet.edges[i]).next_river <- river(path_to_outlet.edges[i+1]);\n\t\t\t}\n\t\t} \n\t}\n\t\n\treflex water_flow {\n\t\t\/\/ Every 20 simulation steps, the source points provide water to the closest river.\n\t\tif (every(10#cycles)) {\n\t\t\task poi - outlet {\n\t\t\t\tdo give_water;\n\t\t\t}\t\n\t\t\/\/  For a visualisation purpose, the water flow is not executed when the sources provide water.\n\t\t} else {\t\t\n\t\t\task river {\n\t\t\t\tdo water_flow;\n\t\t\t}\n\t\t\task river {\n\t\t\t\tdo update_water_level;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\n\nspecies poi {\n\tstring type;\n\triver closest_river ;\n\t\n\taction give_water {\n\t\tclosest_river.water_volume <- 200.0;\n\t}\n\t\n\taspect default {\n\t\tdraw circle(500) color: (type=\"source\") ? #green : #red border: #black;\t\t\n\t}\t\n}\n\nspecies river {\n\triver next_river ;\n\tfloat water_volume;\n\tfloat water_volume_from_other;\n\t\n\taction water_flow {\n\t\tif (next_river != nil) {\n\t\t\tnext_river.water_volume_from_other <- next_river.water_volume_from_other + 0.9 * water_volume;\n\t\t}\n\t}\n\t\n\taction update_water_level {\n\t\twater_volume <- 0.1 * water_volume + water_volume_from_other;\n\t\twater_volume_from_other <- 0.0;\n\t}\n\t\n\taspect default {\n\t\tdraw shape color: #blue;\t\n\t\tdraw shape + water_volume color: #blue;\n\t\t\n\t\t\t\n\t}\n}\n\nexperiment flow type: gui {\n\toutput {\n\t \tdisplay \"Water Unit\" type:2d { \n\t\t\tspecies river ; \n\t\t\tspecies poi;\t\t\t\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Calculate true or false given the probability represented by the operand, for example 0.66666.",
        "output": "bool var0 <- flip (0.66666); \/\/ var0 equals 2\/3 chances to return true."
    },
    {
        "instruction": "Create a complete model that generates a digital elevation model (DEM), with several features (which can be interpreted at will: sea, shore, mountain...).",
        "output": "model RandomMaps\n\nglobal {\n\t\/\/ the generation is mostly governed by these values (see the documentation of 'generate_terrain')\n\tfloat details <- 0.5;\n\tfloat smoothness <- 0.4;\n\tfloat scattering <- 0.7;\n\tint width <- 250;\n\tint height <- 250;\n\tfield terrain;\n\tstring palette_name <- \"Seaside\";\n\tint generator_seed <- 1;\n\n\tinit {\n\t\tdo generate();\n\t}\n\n\taction generate {\n\t\t\/\/ the generate_terrain operator returns a field where the elevations are between 0 and 1. It can be scaled afterwards.\n\t\tint scale_factor <- palette_name = \"Seaside\" ? 20 : 10;\n\t\tterrain <- generate_terrain(generator_seed, width, height, details, smoothness, scattering) * scale_factor;\n\t}\n\n}\n\nexperiment Terrain type: gui {\n\t\n\tparameter \"Seed for the generator\" var: generator_seed <- 1 {\n\t\tdo update();\n\t}\n\t\n\tparameter \"Width of the environment\" var: width min: 50 max: 2000 {\n\t\tdo update();\n\t}\n\tparameter \"Height of the environment\" var: height min: 50 max: 2000 {\n\t\tdo update();\n\t}\n\t\n\tparameter \"Level of details\" var: details min: 0.0 max: 1.0 {\n\t\tdo update();\n\t}\n\n\tparameter \"Level of smoothness\" var: smoothness min: 0.0 max: 1.0 {\n\t\tdo update();\n\t}\n\n\tparameter \"Level of scattering\" var: scattering min: 0.0 max: 1.0 {\n\t\tdo update();\n\t}\n\t\n\tparameter \"Palette\" var: palette_name  among: [\"Countryside\",\"Seaside\"] {\n\t\tdo update();\n\t}\n\t\n\tuser_command \"Save\" {\n\t\tdo save_tif();\n\t}\n\n\taction update {\n\t\task simulation {\n\t\t\tdo generate();\n\t\t}\n\t\tdo update_outputs();\n\t}\n\t\n\taction save_tif {\n\t\tstring file_name <- \"seed\"+generator_seed+\"w\"+width+\"h\"+height+\"d\"+(details with_precision 2)+\"smooth\"+(smoothness with_precision 2)+\"scatter\"+(scattering with_precision 2)+\".tif\";\n\t\tsave grid_file(file_name, terrain);\n\t}\n\n\taction _init_ {\n\t\t\n\t\/\/ A trick to make sure the parameters are expanded and visible when the simulation is launched.\n\t\tbool previous <- gama.pref_experiment_expand_params;\n\t\tgama.pref_experiment_expand_params <- true;\n\t\tcreate simulation;\n\t\tgama.pref_experiment_expand_params <- previous;\n\t}\n\n\tlist<rgb> land_and_sea <- palette(reverse([#darkgreen, #darkgreen, #green, rgb(32, 176, 0), rgb(224, 224, 0), rgb(128, 128, 255), #blue, #blue]));\n\tlist<rgb> field_and_forest <- palette(reverse([#sienna, #olive, #darkgreen, #green, #forestgreen,  #lightgreen]));\n\toutput {\n\t\tlayout #split consoles: false controls: false toolbars: false;\n\t\tdisplay \"Terrain\" type: 3d axes: false camera: #from_up_front {\n\t\t\tmesh terrain color: palette_name = \"Seaside\" ? land_and_sea : field_and_forest triangulation: true;\n\t\t}\n\n\t}\n\n}"
    },
    {
        "instruction": "Create a complete model that demonstrates how to build a simple heatmap based on fields and how to display it. This heatmap records the number of people passed in each area of the city. ",
        "output": "model BuildingHeatmap\n\nimport \"3D Visualization\/models\/Building Elevation.gaml\"\n\nglobal {\n\tint size <- 300;\n\tfield instant_heatmap <- field(size, size);\n\tfield history_heatmap <- field(size, size);\n\treflex update {\n\t\tinstant_heatmap[] <- 0 ;\n\t\task people {\n\t\t\tinstant_heatmap[location] <- instant_heatmap[location] + 10;\n\t\t\thistory_heatmap[location] <- history_heatmap[location] + 1;\n\t\t}\n\t}\n}\n\nexperiment \"Show heatmap\" type: gui {\n\toutput synchronized:true{\n\t\tlayout #split;\n\t\t\n\t\tdisplay city_display type: 3d {\n\t\t\tcamera 'default' location: {1318.6512,3.5713,945.6612} target: {431.7016,495.2155,0.0};\n\t\t\tlight #ambient intensity: 180;\n\t\t\tlight #default intensity: 180 direction: {0.5, 0.5, -1};\n\t\t\tevent #mouse_down {ask simulation {do resume;}}\n\t\t\tspecies building aspect: base refresh: false;\n\t\t\tspecies road aspect: base refresh: false;\n\t\t\tspecies people refresh: true;\n\t\t}\n\t\tdisplay \"Instant heatmap with palette\" type: 3d axes: false background: #black  {\n\t\t\t\/\/ The field is displayed  without 3D rendering, a palettre of warm colors and a smoothness of 2 (meaning two passes of box blur are being done to \"spread\" the values)\n\t\t\tmesh instant_heatmap scale: 0 color: palette([ #black, #black, #orange, #orange, #red, #red, #red]) smooth: 2 ;\n\t\t}\n\t\tdisplay \"History heatmap with gradient\" type: 3d axes: false background: #black camera: #from_up_front {\n\t\t\t\/\/ The field is displayed a little bit above the other layers, with a slight 3D rendering, and a smoothness of 1 (meaning one pass of box blur is being done to \"spread\" the values). The colors are provided by a gradient with three stops\n\t\t\tmesh history_heatmap scale: 0.01 color: gradient([#black::0, #cyan::0.5, #red::1]) transparency: 0.2 position: {0, 0, 0.001} smooth:1 ;\n\t\t }\n\t\t\n\n\t}\n\n}"
    },
    {
        "instruction": "I want a code for adding trees to available places in a given parcel, like in tree planting.",
        "output": "action treePlanting(int no_ttb_planted, parcel destination_parcel){\ngeometry available_space; \n\t\task destination_parcel{\n\t\t\tgeometry sh <- shape;\n\t\t\task parcel_trees {\n\t\t\t\tgeometry occupied_spaces <- circle(self.dbh #cm) translated_to self.location;\n\t\t\t\t sh <- sh - occupied_spaces;\n\t\t\t}\n\t\t\tavailable_space <- sh;\n\t\t}\n\n\n\t\tcreate trees number: no_ttb_planted{\n\t\t\tdbh <- 0.5;\t\n\t\t\tth <- 0.3;\t\n\t\t\tlocation <- any_location_in(available_space);\t\n\t\t\t\/\/location <- any_location_in(myself.my_parcel.shape);\/\/same as above\n\t\t\tmyself.destination_parcel.parcel_trees << self;\t\n\t\t\tgeometry circle_tree <- circle(self.dbh #cm) translated_to self.location;\n\t\t\tavailable_space <- available_space - circle_tree;\n\t\t}\n}\n"
    },
    {
        "instruction": "Create an experiment to display a field called \"heatmap\". I wan't smooth color transitions between white and red, depending on the values of the heatmap.",
        "output": "experiment \"Show heatmap\" type: gui {\n\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t\/\/ The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t\t\n}"
    },
    {
        "instruction": "Create complete model to show how to use overlay layers in a display.",
        "output": "model Overlay\n\nglobal\n{\n\t\/\/define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}\n\n\/\/define a simple grid with 10 rows and 10 columns\ngrid cell width: 10 height: 10 {\n\t\/\/each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}\nexperiment overlay type: gui\n{\n    output \n    {\n        display map type: 3d axes:false antialias:false\n        {\n        \t\/\/define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t\/\/for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }\n            \/\/then we display the grid\n\t\t\tgrid cell border: #black;\n        }\n\n    }\n}\n"
    },
    {
        "instruction": "Create a complete model concerning the  use of the simpleBDI plug-in  with emotions. In this model, a technological accident is simulated in one of the buildings of a city center.",
        "output": "model City_Evacuation\n\nglobal {\n\tfile shapefile_roads <- file(\"..\/includes\/Rouen roads.shp\");\n\tfile shapefile_hazard <- file(\"..\/includes\/Technological hazard.shp\");\n\tfile shapefile_shelters <- file(\"..\/includes\/Escapes.shp\");\n\tgeometry shape <- envelope(shapefile_roads);\n\tgraph road_network;\n\tmap<road,float> current_weights;\n\t\n\tfloat hazard_distance <- 400.0;\n\tfloat catastrophe_distance <- 100.0;\n\tfloat proba_detect_hazard <- 0.2;\n\tfloat proba_detect_other_escape <- 0.01;\n\tfloat other_distance <- 10.0;\n\t\n\tinit {\n\t\tcreate road from: shapefile_roads;\n\t\tcreate hazard from: shapefile_hazard;\n\t\tcreate catastrophe;\n\t\tcreate shelter from: shapefile_shelters;\n\t\t\n\t\t\/\/at the begining of the simulation, we add to the people agent the desire to go to their target.\n\t\tcreate people number: 200{\n\t\t\tlocation <- any_location_in(one_of(road));\n\t\t\tdo add_desire(at_target);\n\t\t\t\n\t\t \t\/\/the agent has also the desire that there is no catastrophe (we set the piority of this desire to 0 as it is a general desire)\n\t\t\tdo add_desire(nonCatastrophe ,0.0);\n\t\t\t\n\t\t\t\/\/ we give the agent a random charisma and receptivity (built-in variables linked to the emotions)\n\t\t\tcharisma<-rnd(1.0);\n\t\t\treceptivity<-rnd(1.0);\n\t\t\t\n\t\t\tif(flip(0.9)){\n\t\t\t\tfearful<-true;\n\t\t\t}else{\n\t\t\t\tfearful <- false;\n\t\t\t}\n      \t}\n      \troad_network <- as_edge_graph(road);\n      \tcurrent_weights <- road as_map (each::each.shape.perimeter);\n\t}\n\t\n\treflex update_speeds when: every(10#cycle){\n\t\tcurrent_weights <- road as_map (each::each.shape.perimeter \/ each.speed_coeff);\n\t\troad_network <- road_network with_weights current_weights;\n\t}\n\t\n\treflex stop_sim when: empty(people) {\n\t\tdo pause;\n\t}\n}\n \nspecies people skills: [moving] control: simple_bdi{\n\tpoint target;\n\tfloat speed <- 30 #km\/#h;\n\trgb color <- #blue;\n\tbool escape_mode <- false;\n\tbool fearful;\n\t\n\t\/\/in order to simplify the model we define  4 desires as variables\n\tpredicate at_target <- new_predicate(\"at_target\");\n\tpredicate in_shelter <- new_predicate(\"shelter\");\n\tpredicate has_target <- new_predicate(\"has target\");\n\tpredicate has_shelter <- new_predicate(\"has shelter\");\n\n    \/\/we give them as well 2 beliefs as variables\n\tpredicate catastropheP <- new_predicate(\"catastrophe\");\n\tpredicate nonCatastrophe <- new_predicate(\"catastrophe\",false);\n\t\n\t\/\/at last we define 2 emotion linked to the knowledge of the catastrophe\n\temotion fearConfirmed <- new_emotion(\"fear_confirmed\",catastropheP);\n\temotion fear <- new_emotion(\"fear\",catastropheP);\n\t\n\tbool noTarget<-true;\n\t\n\t\/\/we set this built-in variable to true to use the emotional process\n\tbool use_emotions_architecture <- true;\n\n    \/\/if the agent perceive that their is something that is not normal (a hazard), it has a probability proba_detect_hazard to suppose (add to its unertainty base) that there is a catastrophe occuring\n\tperceive target:hazard in: hazard_distance when: not escape_mode and flip(proba_detect_hazard){\n\t\tfocus id:\"catastrophe\" is_uncertain: true;\n\t\task myself {\n\t\t\tif(fearful){\n\t\t\t\tdo to_escape_mode;\n\t\t\t}else{\n\t\t\t\tcolor<-#green;\n\t\t\t}\n\t\t}\n\t}\n\n\t\/\/if the agent perceive the catastrophe, it adds a belief about it and pass in escape mode\n\tperceive target:catastrophe in:catastrophe_distance{\n\t\tfocus id:\"catastrophe\";\n\t\task myself{\n\t\t\tif(not escape_mode){\n\t\t\t\tdo to_escape_mode;\n\t\t\t}\n\t\t}\n\t}\n\n\t\/\/if the agent perceives other people agents in their neighborhood that have fear, it can be contaminate by this emotion\n\tperceive target:people in: other_distance when: not escape_mode {\n\t\temotional_contagion emotion_detected:fearConfirmed when: fearful;\n\t\temotional_contagion emotion_detected:new_emotion(\"fear\") charisma: charisma receptivity:receptivity;\n\t\temotional_contagion emotion_detected:fearConfirmed emotion_created:fear;\n\t}\n\temotion joy <- nil;\n\t\n\t\n\tperceive target:people in: other_distance{\n\t\temotional_contagion emotion_detected: joy;\n\t\temotional_contagion emotion_detected:fearConfirmed emotion_created:fear;\n\t}\n\t\n\t\/\/if the agent has a fear confirmed, it has the desire to go to a shelter\n\trule emotion:fearConfirmed remove_intention: at_target new_desire:in_shelter strength:5.0;\n\t\n\t\/\/if the agent has the belief that there is a a catastrophe,  it has the desire to go to a shelter\n\trule belief:new_predicate(\"catastrophe\") remove_intention:at_target new_desire:in_shelter strength:5.0;\n\t\n\trule emotion:new_emotion(\"fear\" ,new_predicate(\"catastrophe\")) new_desire:in_shelter remove_intention:at_target when: fearful strength:5.0;\n\t\n\t\/\/normal move plan\n\tplan normal_move intention: at_target  {\n\t\tif (target = nil) {\n\t\t\ttarget <- any_location_in(one_of(road));\n\t\t} else {\n\t\t\tdo goto target: target on: road_network move_weights: current_weights recompute_path: false;\n\t\t\tif (target = location)  {\n\t\t\t\ttarget <- nil;\n\t\t\t\tnoTarget<-true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\/\/fast evacuation plan in case where the agent has a fear confirmed\n\tplan evacuationFast intention: in_shelter emotion: fearConfirmed priority:2 {\n\t\tcolor <- #yellow;\n\t\tspeed <- 60 #km\/#h;\n\t\tif (target = nil or noTarget) {\n\t\t\ttarget <- (shelter with_min_of (each.location distance_to location)).location;\n\t\t\tnoTarget <- false;\n\t\t}\n\t\telse  {\n\t\t\tdo goto target: target on: road_network move_weights: current_weights recompute_path: false;\n\t\t\tif (target = location)  {\n\t\t\t\tdo die;\n\t\t\t}\t\t\n\t\t}\n\t}\t\n\t\n\t\/\/normal evacuation plan\n\tplan evacuation intention: in_shelter finished_when: has_emotion(fearConfirmed){\n\t\tcolor <-#darkred;\n\t\tif (target = nil or noTarget) {\n\t\t\ttarget <- (shelter with_min_of (each.location distance_to location)).location;\n\t\t\tnoTarget <- false;\n\t\t}\n\t\telse  {\n\t\t\tdo goto target: target on: road_network move_weights: current_weights recompute_path: false;\n\t\t\tif (target = location)  {\n\t\t\t\tdo die;\n\t\t\t}\t\t\n\t\t}\n\t}\n\t\n\taction to_escape_mode {\n\t\tescape_mode <- true;\n\t\tcolor <- #darkred;\n\t\ttarget <- nil;\t\n\t\tnoTarget <- true;\n\t\tdo remove_intention(at_target, true);\n\t}\n\t\n\t\n\taspect default {\n\t\tdraw triangle(30) rotate: heading + 90 color: color;\n\t}\n}\n\nspecies road {\n\tfloat capacity <- 1 + shape.perimeter\/50;\n\tint nb_people <- 0 update: length(people at_distance 1);\n\tfloat speed_coeff <- 1.0 update:  exp(-nb_people\/capacity) min: 0.1;\n\t\n\taspect default {\n\t\tdraw shape color: #black;\n\t}\n}\n\nspecies shelter {\n\taspect default {\n\t\tdraw circle(30) color: rgb(#gamablue,0.8) border: #gamablue depth:10;\n\t}\n}\n\nspecies hazard {\n\taspect default {\n\t\tdraw circle(hazard_distance) color: rgb(#gamaorange,0.3) border:#gamaorange depth:5;\n\t}\n}\n\nspecies catastrophe{\n\tinit{\n\t\tlocation <- first(hazard).location;\n\t}\n\taspect default{\n\t\tdraw circle(catastrophe_distance) color: rgb(#gamared,0.4) border:#gamared depth:10;\n\t}\n}\n\nexperiment main type: gui {\n\tfloat minimum_cycle_duration <- 0.02;\n\toutput {\n\t\tdisplay map type: 3d{\n\t\t\tspecies shelter refresh: false;\n\t\t\tspecies road refresh: false;\n\t\t\tspecies people;\n\t\t\tspecies catastrophe;\n\t\t\tspecies hazard;\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Create a short and complete Hello World model demonstrating the simple BDI architecture. ",
        "output": "model HelloWorldBDI\n\nglobal {\n\tinit {\n\t\tcreate bdi_species;\n\t}\n}\n\n\/\/add the simple_bdi architecture to the agents\nspecies bdi_species control: simple_bdi {\n\t\n\t\/\/define a new predicate that will be used as a desire\n\tpredicate saying_hello_desire <- new_predicate(\"say hello\");\n\t\n\t\/\/at init, add the saying_hello_desire to the agent desire base\n\tinit {\n\t\tdo add_desire(saying_hello_desire);\n\t}\n\t\n\t\/\/definition of a plan that allow to fulfill the  saying_hello_desire intention\n\tplan saying_hello intention: saying_hello_desire{\n\t\twrite \"Hello World!\";\n\t}\n}\n\nexperiment HelloWorldBDI type: gui ;"
    },
    {
        "instruction": "Create a species named bdi_species with the control: simple_bdi.",
        "output": "species bdi_species control: simple_bdi {\n\t\n\t\/\/define a new predicate that will be used as a desire\n\tpredicate saying_hello_desire <- new_predicate(\"say hello\");\n\t\n\t\/\/at init, add the saying_hello_desire to the agent desire base\n\tinit {\n\t\tdo add_desire(saying_hello_desire);\n\t}\n\t\n\t\/\/definition of a plan that allow to fulfill the  saying_hello_desire intention\n\tplan saying_hello intention: saying_hello_desire{\n\t\twrite \"Hello World!\";\n\t}\n}"
    },
    {
        "instruction": "Create a complete and simple model to show how the BDI architectures and its tools work (perceive, rule, etc). It's the model of a helicopter that fights fires. The Chopper agent has a general desire to patrol. As it is the only thing he wants at the beginning, it is its initial intention (what it is doing). To patrol, it wanders around (its plan to patrol). When it perceives a fire, it stores this information (it has a new belief about the existence of this fire), and it has a new desire (it wants the fire to be extinct). When it sees a fire, the Patrol intention is put on hold and a new intention is selected (to put out the fire). To achieve this intention, the plan has two steps, i.e. two new (sub)desires: go to the fire and put water on the fire. And so on.",
        "output": "model Firefighters\n\nglobal {\n\tint displatTextSize <-4;\n\t\n\t\/\/We define the predicates that will be used later.\n\tpredicate patrol_desire <- new_predicate(\"patrol\");\n\tpredicate water_predicate <- new_predicate(\"has water\",true);\n\tpredicate no_water_predicate <- new_predicate(\"has water\", false) ;\n\tstring fireLocation <- \"fireLocation\";\n\t\n\tinit {\n\t\tcreate fireArea number:20;\n\t\tcreate waterArea number:1;\n\t\tcreate firefighter number: 2;\n\t}\n\t\n\treflex stop when: length(fireArea) = 0 {\n\t\tdo pause;\n\t}\n}\n\n\n\/\/give the simple_bdi architecture to the firefighter agents\nspecies firefighter skills: [moving] control: simple_bdi{\t\n\t\n\t\/\/Here are the variables used by a helicopter. \n\trgb color <- rnd_color(150);\n\tfloat waterValue;\n\tgrille maCellule <- one_of(grille);\n\t\/\/Definition of the variables featured in the BDI architecture.\n\tfloat plan_persistence <- 1.0; \n\tfloat intention_persistence <- 1.0;\n\tbool probabilistic_choice <- false;\n\t\n\t\/\/Initialisation of the agent. At the begining, the agent just has the desire to patrol.\n\tinit {\n\t\twaterValue <-2.0;\n\t\tlocation<-maCellule.location;\n\t\tdo add_desire(patrol_desire );\n\t}\n\t\n\t\/\/This perceive is used to update the beliefs concerning the intern variable of the agent (the amount of water it has).\n\tperceive target:self {\n\t\tif(waterValue>0){\n\t\t\tdo add_belief(water_predicate);\n\t\t\tdo remove_belief(no_water_predicate);\n\t\t}\n\t\tif(waterValue<=0){\n\t\t\tdo add_belief(no_water_predicate);\n\t\t\tdo remove_belief(water_predicate);\n\t\t}\n\t}\n\t\n\t\/\/The helicopter perceive the fires at a certain distance. It just record the location of the fire it obsrves. When it sees a fire, it stops it's intention of patroling.\n\tperceive target:fireArea in: 15{ \n\t\tfocus id:\"fireLocation\" var:location strength:10.0; \n\t\task myself{\n\t\t\tdo remove_intention(patrol_desire, true);\n\t\t} \n\t}\n\t\n\t\/\/The rules are used to create a desire from a belief. We can specify the priority of the desire with a statement priority.\n\trule belief: new_predicate(fireLocation) new_desire: get_predicate(get_belief_with_name(fireLocation));\n\trule belief: no_water_predicate new_desire: water_predicate strength: 10.0;\n\t\n\t\/\/The plan to do when the intention is to patrol.\n\tplan patrolling intention:patrol_desire{\n\t\tdo wander amplitude: 30.0 speed: 2.0;\n\t}\n\t \n\t\/\/The plan that is executed when the agent got the intention of extinguish a fire.\n\tplan stopFire intention: new_predicate(fireLocation) priority:5{\n\t\tpoint target_fire <- point(get_predicate(get_current_intention()).values[\"location_value\"] );\n\t\tif(waterValue>0){\n\t\t\tif (self distance_to target_fire <= 1) {\n\t\t\t\tfireArea current_fire <- fireArea first_with (each.location = target_fire);\n\t\t\t\tif (current_fire != nil) {\n\t\t\t\t\t waterValue <- waterValue - 1.0;\n\t\t\t\t\t current_fire.size <-  current_fire.size - 1;\n\t\t\t\t\t if ( current_fire.size <= 0) {\n\t\t\t\t\t\task  current_fire {do die;}\n\t\t\t\t\t\tdo remove_belief(get_predicate(get_current_intention()));\n\t\t\t\t\t\tdo remove_intention(get_predicate(get_current_intention()), true);\n\t\t\t\t\t\tdo add_desire(patrol_desire,1.0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdo remove_belief(get_predicate(get_current_intention()));\n\t\t\t\t\tdo remove_intention(get_predicate(get_current_intention()), true);\n\t\t\t\t\tdo add_desire(patrol_desire,1.0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdo goto(target: target_fire);\n\t\t\t}\n\t\t} else {\n\t\t\tdo add_subintention(get_current_intention(),water_predicate,true);\n\t\t\tdo current_intention_on_hold();\n\t\t}\n\t}  \n\t\n\t\/\/The plan to take water when the agent get the desire of water.\n    plan gotoTakeWater intention: water_predicate priority:2 {\n    \twaterArea wa <- first(waterArea);\n    \tlist<grille> voisins <-  (grille(location) neighbors_at (1)) + grille(location);\n\t\t\tpath cheminSuivi <-  goto(wa);\n    \tif (self distance_to wa <= 1) {\n    \t\twaterValue <- waterValue + 2.0;\n\t\t}\n    }\n\n\taspect base {\n\t\tdraw triangle(2) color:color rotate: 90 + heading;\t\n\t\tdraw circle(15) color: color ;\t\n\t}\n\t\n\taspect bdi {\n\t\tdraw triangle(2) color:color rotate: 90 + heading;\t\n\t\tdraw circle(15) color: color wireframe: true;\n\t\tdraw (\"B:\" + length(belief_base) + \":\" + belief_base) color:#black size:displatTextSize; \n\t\tdraw (\"D:\" + length(desire_base) + \":\" + desire_base) color:#black size:displatTextSize at:{location.x,location.y+displatTextSize}; \n\t\tdraw (\"I:\" + length(intention_base) + \":\" + intention_base) color:#black size:displatTextSize at:{location.x,location.y+2*displatTextSize}; \n\t\tdraw (\"curIntention:\" + get_current_intention()) color:#black size:displatTextSize at:{location.x,location.y+3*displatTextSize}; \t\n\t}\n}\n\nspecies fireArea{\n\tfloat size <-1.0;\n\t\n\tinit{\n\t\tgrille place <- one_of(grille);\n\t\tlocation <- place.location;\n\t}\n\t\n\taspect base {\n\t  draw file(\"..\/includes\/Fire.png\") size: 5;\n\t}\n}\n\nspecies waterArea{\n\tinit {\n\t\tgrille place <- one_of(grille);\n\t\tlocation <- place.location;\n\t}\n\taspect base {\n\t  draw square(5) color: #blue border: #black;\t\t\n\t}\n}\n\ngrid grille width: 25 height: 25 neighbors:4 {\n\trgb color <- #green;\n}\n\n\nexperiment fight_fire type: gui {\n\tfloat minimum_cycle_duration <- 0.05;\n\toutput {\t\t\t\t\t\n\t\tdisplay view1 { \n\t\t\tgrid grille border: #darkgreen;\n\t\t\tspecies fireArea aspect:base;\n\t\t\tspecies waterArea aspect:base;\n\t\t\tspecies firefighter aspect: bdi;\n\t\t}\n\t}\n\n}"
    },
    {
        "instruction": "Create a GAML action named treePlanting that takes two parameters: an integer no_ttb_planted representing the number of trees to be planted and a parcel named destination_parcel representing the parcel where the trees will be planted. The action should perform the following:\n1. Within the scope of the destination_parcel, calculate the available space by subtracting the occupied spaces of existing trees in the parcel_trees attribute from the parcel's shape.\n2. Create no_ttb_planted number of trees with attributes dbh set to 0.5 and th set to 0.3.\n3. Place each tree randomly within the calculated available space.\n4. Add each newly created tree to the destination_parcel.parcel_trees list.\n5. Update the available_space by subtracting the space occupied by each newly planted tree (represented by a circle with a radius equal to the tree's dbh).\nNote: This request assumes the existence of agent types trees and parcel with appropriate attributes.",
        "output": "action treePlanting(int no_ttb_planted, parcel destination_parcel){\ngeometry available_space; \n\t\task destination_parcel{\n\t\t\tgeometry sh <- shape;\n\t\t\task parcel_trees {\n\t\t\t\tgeometry occupied_spaces <- circle(self.dbh #cm) translated_to self.location;\n\t\t\t\t sh <- sh - occupied_spaces;\n\t\t\t}\n\t\t\tavailable_space <- sh;\n\t\t}\n\n\n\t\tcreate trees number: no_ttb_planted{\n\t\t\tdbh <- 0.5;\t\n\t\t\tth <- 0.3;\t\n\t\t\tlocation <- any_location_in(available_space);\t\n\t\t\t\/\/location <- any_location_in(myself.my_parcel.shape);\/\/same as above\n\t\t\tmyself.destination_parcel.parcel_trees << self;\n\t\t\tgeometry circle_tree <- circle(self.dbh #cm) translated_to self.location;\n\t\t\tavailable_space <- available_space - circle_tree;\n\t\t}\n}\n"
    },
    {
        "instruction": "Create a complete model which illustrates the use of univariate statistical operators of GAMA.",
        "output": "model statistic_operators\n\nglobal {\n\tinit tet {\n\t\tlist data <- [1,2,3,4,5,6,7,10,20,100];\n\t\twrite \"data: \" + data;\n\t\twrite \"min: \" + min(data);\n\t\twrite \"max: \" + max(data);\n\t\twrite \"sum: \" + sum(data);\n\t\twrite \"mean: \" + mean(data);\n\t\twrite \"median: \" + median(data);\n\t\twrite \"standard_deviation: \" + standard_deviation(data);\n\t\twrite \"geometric_mean: \" + geometric_mean(data);\n\t\twrite \"harmonic_mean: \" + harmonic_mean(data);\n\t\twrite \"variance: \" + harmonic_mean(data);\n\t\twrite \"mean_deviation: \" + mean_deviation(data);\n\t\twrite \"kurtosis: \" + kurtosis(data);\n\t\twrite \"skewness: \" + skewness(data);\n\t\twrite \"gamma_rnd: \" + gamma_rnd(0.1,1); \n\t\twrite \"gini index: \" + gini([10.0, 1.0, 2.0, 0.0]);\n\t\t\n\t\tlist<float> l1 <- [10.0,5.0,1.0, 3.0, 4.0, 7.5, 1.0,10.0,5.0,1.0];\n\t\tlist<float> l2 <- [1.0,1.0,15.0,1.0,1.0, 3.0, 4.0, 7.5];\n\t\twrite \"Dynamic Time Warping: \" + dtw(l1,l2);\n\t\twrite \"Dynamic Time Warping with a radius of 2: \" + dtw(l1,l2,2);\t\n\t}\n}\n\nexperiment test_operators type: gui;"
    },
    {
        "instruction": "What is the syntax to make a loop in GAMA? ",
        "output": "loop index from: 0 to: 100 {\n  write index;\n}"
    },
    {
        "instruction": "Given a list of numbers named data, calculate and write down the standard deviation of this list.",
        "output": "list data <- [1,2,3,4,5,6,7,10,20,100];\nwrite \"standard_deviation: \" + standard_deviation(data)"
    },
    {
        "instruction": "Create a complete model of pedestrian movement in a simple environment for a big crowd, frontal crossing and perpendicular crossing.",
        "output": "model pedestrian_simple_environment\n\nglobal {\n\tfloat environment_size <- 50.0 parameter: true;\n\tfloat margin <- 2.0;\n\tint nb_obstacles <- 0 parameter: true;\n\tint nb_people <- 100;\n\tstring scenario <- \"frontal crossing\" among: [\"big crowd\", \"frontal crossing\", \"perpendicular crossing\"] ;\n\t\t\n\tbool display_free_space <- false parameter: true;\n\tbool display_force <- false parameter: true;\n\tbool display_circle_min_dist <- true parameter: true;\n\t\n\tfloat P_shoulder_length <- 0.45 parameter: true;\n\tfloat P_proba_detour <- 1.0 parameter: true ;\n\tbool P_avoid_other <- true parameter: true ;\n\tfloat P_obstacle_consideration_distance <- 5.0 parameter: true ;\n\tfloat P_pedestrian_consideration_distance <- 5.0 parameter: true ;\n\tfloat P_tolerance_waypoint <- 0.1 parameter: true;\n\tbool P_use_geometry_waypoint <- true parameter: true;\n\t\n\tstring P_model_type <- \"simple\" among: [\"simple\", \"advanced\"] parameter: true ; \n\t\n\tfloat P_A_pedestrian_SFM_advanced parameter: true <- 25.0 category: \"SFM advanced\" ;\n\tfloat P_A_obstacles_SFM_advanced parameter: true <- 25.0 category: \"SFM advanced\" ;\n\tfloat P_B_pedestrian_SFM_advanced parameter: true <- 0.5 category: \"SFM advanced\" ;\n\tfloat P_B_obstacles_SFM_advanced parameter: true <- 0.1 category: \"SFM advanced\" ;\n\tfloat P_relaxion_SFM_advanced  parameter: true <- 0.1 category: \"SFM advanced\" ;\n\tfloat P_gama_SFM_advanced parameter: true <- 0.35 category: \"SFM advanced\" ;\n\tfloat P_lambda_SFM_advanced <- 0.1 parameter: true category: \"SFM advanced\" ;\n\tfloat P_minimal_distance_advanced <- 0.5 parameter: true category: \"SFM advanced\" ;\n\t\n\t\n\tfloat P_n_prime_SFM_simple parameter: true <- 3.0 category: \"SFM simple\" ;\n\tfloat P_n_SFM_simple parameter: true <- 2.0 category: \"SFM simple\" ;\n\tfloat P_lambda_SFM_simple <- 2.0 parameter: true category: \"SFM simple\" ;\n\tfloat P_gama_SFM_simple parameter: true <- 0.35 category: \"SFM simple\" ;\n\tfloat P_relaxion_SFM_simple parameter: true <- 0.54 category: \"SFM simple\" ;\n\tfloat P_A_pedestrian_SFM_simple parameter: true <- 4.5category: \"SFM simple\" ;\n\t\n\tgeometry shape <- square(environment_size);\n\tgeometry free_space <- copy(shape);\n\tgeometry left_space;\n\tgeometry right_space;\n\tgeometry bottom_space; \n\tgeometry top_space;\n\t\n\tfloat step <- 0.1;\n\t\n\tinit {\n\t\tleft_space <- polygon([{0,0}, {0, environment_size}, {environment_size\/10, environment_size}, {environment_size\/10,0}]);\n\t\tright_space <- polygon([{environment_size,0}, {environment_size, environment_size}, {9 * environment_size\/10, environment_size}, {9 * environment_size\/10,0}]);\n\t\tbottom_space <- polygon([{0, environment_size}, {0, 9 * environment_size\/10}, {environment_size,9*  environment_size\/10}, {environment_size, environment_size}]);\t\n\t\ttop_space <- polygon([{0, 0}, {0, environment_size\/10}, {environment_size, environment_size\/10}, {environment_size, 0.0}]);\t\n\t\t\n\t\tcreate obstacle number:nb_obstacles {\n\t\t\tlocation <- any_location_in(square(8*environment_size\/10) at_location {environment_size\/2, environment_size\/2} scaled_by 0.8);\n\t\t\tshape <- sphere(1+rnd(environment_size\/50.0));\n\t\t\tfree_space <- free_space - shape;\n\t\t}\n\t\t\n\t\tcreate people number: nb_people {\n\t\t\tobstacle_consideration_distance <- P_obstacle_consideration_distance;\n\t\t\tobstacle_consideration_distance <- P_obstacle_consideration_distance;\n\t\t\tpedestrian_consideration_distance <- P_pedestrian_consideration_distance;\n\t\t\tshoulder_length <- P_shoulder_length;\n\t\t\tavoid_other <- P_avoid_other;\n\t\t\tproba_detour <- P_proba_detour;\n\t\t\tuse_geometry_waypoint <- P_use_geometry_waypoint;\n\t\t\ttolerance_waypoint <- P_tolerance_waypoint;\n\t\t\t\n\t\t\tpedestrian_model <- P_model_type;\n\t\t\tif (pedestrian_model = \"simple\") {\n\t\t\t\tA_pedestrians_SFM <- P_A_pedestrian_SFM_simple;\n\t\t\t\trelaxion_SFM <- P_relaxion_SFM_simple;\n\t\t\t\tgama_SFM <- P_gama_SFM_simple;\n\t\t\t\tlambda_SFM <- P_lambda_SFM_simple;\n\t\t\t\tn_prime_SFM <- P_n_prime_SFM_simple;\n\t\t\t\tn_SFM <- P_n_SFM_simple;\n\t\t\t} else {\n\t\t\t\tA_pedestrians_SFM <- P_A_pedestrian_SFM_advanced;\n\t\t\t\tA_obstacles_SFM <- P_A_obstacles_SFM_advanced;\n\t\t\t\tB_pedestrians_SFM <- P_B_pedestrian_SFM_advanced;\n\t\t\t\tB_obstacles_SFM <- P_B_obstacles_SFM_advanced;\n\t\t\t\trelaxion_SFM <- P_relaxion_SFM_advanced;\n\t\t\t\tgama_SFM <- P_gama_SFM_advanced;\n\t\t\t\tlambda_SFM <- P_lambda_SFM_advanced;\n\t\t\t\tminimal_distance <- P_minimal_distance_advanced;\n\t\t\t}\n\t\t\t\n\t\t\tpedestrian_species <- [people];\n\t\t\tobstacle_species<-[obstacle];\n\t\t\tswitch scenario {\n\t\t\t\tmatch \"frontal crossing\" {\n\t\t\t\t\tint id <- int(self);\n\t\t\t\t\tlocation <- any_location_in(even(id) ? left_space : right_space);\n\t\t\t\t\tcurrent_target <- closest_points_with(location, even(id) ? right_space : left_space)[1];\n\t\t\t\t} match \"perpendicular crossing\" {\n\t\t\t\t\tint id <- int(self);\n\t\t\t\t\tlocation <- any_location_in(even(id) ? left_space : bottom_space);\n\t\t\t\t\tcurrent_target <- closest_points_with(location, (even(id) ? right_space : top_space))[1];\n\t\t\t\t} match \"big crowd\" {\n\t\t\t\t\tlocation <- any_location_in(free_space);\n\t\t\t\t\tcurrent_target <- any_location_in(world.shape.contour);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treflex end_simulation when: empty(people) {\n\t\tdo pause;\n\t}\n}\n\nspecies people skills: [pedestrian] schedules: shuffle(people) {\n\trgb color <- rnd_color(255);\n\tfloat speed <- 3 #km\/#h;\n\tbool avoid_other <- true;\n\tpoint current_target ;\n\treflex move when: current_target != nil{\n\t\tif (nb_obstacles > 0) {\n\t\t\tdo walk_to target: current_target bounds: free_space;\n\t\t} else {\n\t\t\tdo walk_to target: current_target;\n\t\t}\n\t\tif (self distance_to current_target < 0.5) {\n\t\t\tdo die;\n\t\t}\n\t}\n\taspect default {\n\t\tif (display_circle_min_dist and minimal_distance > 0) {\n\t\t\t\tif not empty(people at_distance minimal_distance) {\n\t\t\t\t\tdraw circle(minimal_distance) color: #red;\n\t\t\t\t}\n\t\t\t\t\n\t\t}\n\t\tdraw triangle(shoulder_length) color: color rotate: heading + 90.0;\n\t\t\n\t\tif  display_force {\n\t\t\n\t\t\tloop op over: forces.keys {\n\t\t\t\tif (species(agent(op)) = obstacle ) {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #red end_arrow: 0.1;\n\t\t\t\t}\n\t\t\t\telse if ((agent(op)) = self ) {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #blue end_arrow: 0.1;\n\t\t\t\t} \n\t\t\t\telse {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #green end_arrow: 0.1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n}\n\nspecies obstacle {\n\taspect default {\n\t\tdraw shape color: #gray border: #black;\n\t}\n}\nexperiment big_crowd type: gui {\n\tfloat minimum_cycle_duration <- 0.02;\n\taction _init_ {\n\t\tcreate simulation with: [scenario :: \"big crowd\", nb_people::500];\n\t}\n\toutput {\n\t\tdisplay map  {\n\t\t\tspecies obstacle;\n\t\t\tspecies people;\n\t\t}\n\t}\n}\n\nexperiment frontal_crossing type: gui {\n\tfloat minimum_cycle_duration <- 0.02;\n\taction _init_ {\n\t\tcreate simulation with: [scenario :: \"frontal crossing\", nb_people::100];\n\t}\n\toutput {\n\t\tdisplay map  {\n\t\t\tgraphics \"areas\" transparency: 0.5{\n\t\t\t\tdraw right_space color: #green border: #black;\n\t\t\t\tdraw left_space color: #red border: #black;\n\t\t\t}\n\t\t\tspecies obstacle;\n\t\t\tspecies people;\n\t\t}\n\t}\n}\nexperiment perpendicular_crossing type: gui {\n\tfloat minimum_cycle_duration <- 0.02;\n\taction _init_ {\n\t\tcreate simulation with: [scenario :: \"perpendicular crossing\", nb_people::100];\n\t}\n\t\n\toutput {\n\t\tdisplay map  {\n\t\t\tgraphics \"areas\" transparency: 0.7{\n\t\t\t\tdraw right_space color: #green border: #black;\n\t\t\t\tdraw left_space color: #red border: #black;\n\t\t\t\tdraw bottom_space color: #yellow border: #black;\n\t\t\t\tdraw top_space color: #magenta border: #black;\n\t\t\t}\n\t\t\tspecies obstacle;\n\t\t\tspecies people;\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Create a complete model to show how to use the pedestrian skill for complex environment. This will use a pedestrian paths from \"Generate Pedestrian path.gaml\".",
        "output": "model pedestrian_complex_environment\n\nglobal {\n\t\n\tfile wall_shapefile <- file(\"..\/includes\/walls.shp\");\n\t\n\tshape_file free_spaces_shape_file <- shape_file(\"..\/includes\/free spaces.shp\");\n\tshape_file open_area_shape_file <- shape_file(\"..\/includes\/open area.shp\");\n\tshape_file pedestrian_paths_shape_file <- shape_file(\"..\/includes\/pedestrian paths.shp\");\n\n\t\n\tgraph network;\n\t\n\tgeometry shape <- envelope(wall_shapefile);\n\t\n\tbool display_free_space <- false parameter: true;\n\tbool display_force <- false parameter: true;\n\tbool display_target <- false parameter: true;\n\tbool display_circle_min_dist <- true parameter: true;\n\t\n\tfloat P_shoulder_length <- 0.45 parameter: true;\n\tfloat P_proba_detour <- 0.5 parameter: true ;\n\tbool P_avoid_other <- true parameter: true ;\n\tfloat P_obstacle_consideration_distance <- 3.0 parameter: true ;\n\tfloat P_pedestrian_consideration_distance <- 3.0 parameter: true ;\n\tfloat P_tolerance_target <- 0.1 parameter: true;\n\tbool P_use_geometry_target <- true parameter: true;\n\t\n\t\n\tstring P_model_type <- \"simple\" among: [\"simple\", \"advanced\"] parameter: true ; \n\t\n\tfloat P_A_pedestrian_SFM_advanced parameter: true <- 0.16 category: \"SFM advanced\" ;\n\tfloat P_A_obstacles_SFM_advanced parameter: true <- 1.9 category: \"SFM advanced\" ;\n\tfloat P_B_pedestrian_SFM_advanced parameter: true <- 0.1 category: \"SFM advanced\" ;\n\tfloat P_B_obstacles_SFM_advanced parameter: true <- 1.0 category: \"SFM advanced\" ;\n\tfloat P_relaxion_SFM_advanced  parameter: true <- 0.5 category: \"SFM advanced\" ;\n\tfloat P_gama_SFM_advanced parameter: true <- 0.35 category: \"SFM advanced\" ;\n\tfloat P_lambda_SFM_advanced <- 0.1 parameter: true category: \"SFM advanced\" ;\n\tfloat P_minimal_distance_advanced <- 0.25 parameter: true category: \"SFM advanced\" ;\n\t\n\tfloat P_n_prime_SFM_simple parameter: true <- 3.0 category: \"SFM simple\" ;\n\tfloat P_n_SFM_simple parameter: true <- 2.0 category: \"SFM simple\" ;\n\tfloat P_lambda_SFM_simple <- 2.0 parameter: true category: \"SFM simple\" ;\n\tfloat P_gama_SFM_simple parameter: true <- 0.35 category: \"SFM simple\" ;\n\tfloat P_relaxion_SFM_simple parameter: true <- 0.54 category: \"SFM simple\" ;\n\tfloat P_A_pedestrian_SFM_simple parameter: true <-4.5category: \"SFM simple\" ;\n\t\n\tfloat step <- 0.1;\n\tint nb_people <- 250;\n\n\tgeometry open_area ;\n\t\n\tinit {\n\t\topen_area <- first(open_area_shape_file.contents);\n\t\tcreate wall from:wall_shapefile;\n\t\tcreate pedestrian_path from: pedestrian_paths_shape_file {\n\t\t\tlist<geometry> fs <- free_spaces_shape_file overlapping self;\n\t\t\tfree_space <- fs first_with (each covers shape); \n\t\t}\n\t\t\n\n\t\tnetwork <- as_edge_graph(pedestrian_path);\n\t\t\n\t\task pedestrian_path {\n\t\t\tdo build_intersection_areas pedestrian_graph: network;\n\t\t}\n\t\n\t\tcreate people number:nb_people{\n\t\t\tlocation <- any_location_in(one_of(open_area));\n\t\t\tobstacle_consideration_distance <-P_obstacle_consideration_distance;\n\t\t\tpedestrian_consideration_distance <-P_pedestrian_consideration_distance;\n\t\t\tshoulder_length <- P_shoulder_length;\n\t\t\tavoid_other <- P_avoid_other;\n\t\t\tproba_detour <- P_proba_detour;\n\t\t\t\n\t\t\tuse_geometry_waypoint <- P_use_geometry_target;\n\t\t\ttolerance_waypoint<- P_tolerance_target;\n\t\t\tpedestrian_species <- [people];\n\t\t\tobstacle_species<-[wall];\n\t\t\t\n\t\t\tpedestrian_model <- P_model_type;\n\t\t\t\n\t\t\n\t\t\tif (pedestrian_model = \"simple\") {\n\t\t\t\tA_pedestrians_SFM <- P_A_pedestrian_SFM_simple;\n\t\t\t\trelaxion_SFM <- P_relaxion_SFM_simple;\n\t\t\t\tgama_SFM <- P_gama_SFM_simple;\n\t\t\t\tlambda_SFM <- P_lambda_SFM_simple;\n\t\t\t\tn_prime_SFM <- P_n_prime_SFM_simple;\n\t\t\t\tn_SFM <- P_n_SFM_simple;\n\t\t\t} else {\n\t\t\t\tA_pedestrians_SFM <- P_A_pedestrian_SFM_advanced;\n\t\t\t\tA_obstacles_SFM <- P_A_obstacles_SFM_advanced;\n\t\t\t\tB_pedestrians_SFM <- P_B_pedestrian_SFM_advanced;\n\t\t\t\tB_obstacles_SFM <- P_B_obstacles_SFM_advanced;\n\t\t\t\trelaxion_SFM <- P_relaxion_SFM_advanced;\n\t\t\t\tgama_SFM <- P_gama_SFM_advanced;\n\t\t\t\tlambda_SFM <- P_lambda_SFM_advanced;\n\t\t\t\tminimal_distance <- P_minimal_distance_advanced;\n\t\t\t\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\treflex stop when: empty(people) {\n\t\tdo pause;\n\t}\n\t\n}\n\nspecies pedestrian_path skills: [pedestrian_road]{\n\taspect default { \n\t\tdraw shape  color: #gray;\n\t}\n\taspect free_area_aspect {\n\t\tif(display_free_space and free_space != nil) {\n\t\t\tdraw free_space color: #lightpink border: #black;\n\t\t}\n\t\t\n\t}\n}\n\nspecies wall {\n\tgeometry free_space;\n\tfloat high <- rnd(10.0, 20.0);\n\t\n\taspect demo {\n\t\tdraw shape border: #black depth: high texture: [\"..\/includes\/top.png\",\"..\/includes\/texture5.jpg\"];\n\t}\n\t\n\taspect default {\n\t\tdraw shape + (P_shoulder_length\/2.0) color: #gray border: #black;\n\t}\n}\n\nspecies people skills: [pedestrian]{\n\trgb color <- rnd_color(255);\n\tfloat speed <- gauss(5,1.5) #km\/#h min: 2 #km\/#h;\n\n\treflex move  {\n\t\tif (final_waypoint = nil) {\n\t\t\tdo compute_virtual_path pedestrian_graph:network target: any_location_in(open_area) ;\n\t\t}\n\t\tdo walk ;\n\t}\t\n\t\n\taspect default {\n\t\t\n\t\tif display_circle_min_dist and minimal_distance > 0 {\n\t\t\tdraw circle(minimal_distance).contour color: color;\n\t\t}\n\t\t\n\t\tdraw triangle(shoulder_length) color: color rotate: heading + 90.0;\n\t\t\n\t\tif display_target and current_waypoint != nil {\n\t\t\tdraw line([location,current_waypoint]) color: color;\n\t\t}\n\t\tif  display_force {\n\t\t\tloop op over: forces.keys {\n\t\t\t\tif (species(agent(op)) = wall ) {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #red end_arrow: 0.1;\n\t\t\t\t}\n\t\t\t\telse if ((agent(op)) = self ) {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #blue end_arrow: 0.1;\n\t\t\t\t} \n\t\t\t\telse {\n\t\t\t\t\tdraw line([location, location + point(forces[op])]) color: #green end_arrow: 0.1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n}\n\n\nexperiment normal_sim type: gui {\n\tfloat minimum_cycle_duration <- 0.02;\n\t\toutput {\n\t\tdisplay map type: 3d{\n\t\t\tspecies wall refresh: false;\n\t\t\tspecies pedestrian_path aspect:free_area_aspect transparency: 0.5 ;\n\t\t\tspecies pedestrian_path refresh: false;\n\t\t\tspecies people;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Create a complete model that show how to create pedestrian path and associated free space.",
        "output": "model generate_pedestrian_path\n\nglobal {\n\t\n\tfile wall_shapefile <- file(\"..\/includes\/walls.shp\");\n\t\n\t\n\tgeometry shape <- envelope(wall_shapefile);\n\tbool display_free_space <- false parameter: true;\n\tfloat P_shoulder_length <- 0.45 parameter: true;\n\t\n\tfloat simplification_dist <- 0.5; \/\/simplification distance for the final geometries\n\t\n\tbool add_points_open_area <- true;\/\/add points to open areas\n \tbool random_densification <- false;\/\/random densification (if true, use random points to fill open areas; if false, use uniform points), \n \tfloat min_dist_open_area <- 0.1;\/\/min distance to considered an area as open area, \n \tfloat density_open_area <- 0.01; \/\/density of points in the open areas (float)\n \tbool clean_network <-  true; \n\tfloat tol_cliping <- 1.0; \/\/tolerance for the cliping in triangulation (float; distance), \n\tfloat tol_triangulation <- 0.1; \/\/tolerance for the triangulation \n\tfloat min_dist_obstacles_filtering <- 0.0;\/\/ minimal distance to obstacles to keep a path (float; if 0.0, no filtering), \n\t\n\t\n\tgeometry open_area ;\n\t\n\tinit {\n\t\topen_area <- copy(shape);\n\t\tcreate wall from:wall_shapefile {\n\t\t\topen_area <- open_area -(shape buffer (P_shoulder_length\/2.0));\n\t\t}\n\t\tlist<geometry> generated_lines <- generate_pedestrian_network([],[open_area],add_points_open_area,random_densification,min_dist_open_area,density_open_area,clean_network,tol_cliping,tol_triangulation,min_dist_obstacles_filtering,simplification_dist);\n\t\t\n\t\tcreate pedestrian_path from: generated_lines  {\n\t\t\tdo initialize bounds:[open_area] distance: min(10.0,(wall closest_to self) distance_to self) masked_by: [wall] distance_extremity: 1.0;\n\t\t}\n\t\tsave pedestrian_path to: \"..\/includes\/pedestrian paths.shp\" format:\"shp\";\n\t\tsave open_area to: \"..\/includes\/open area.shp\" format:\"shp\";\n\t\tsave pedestrian_path collect each.free_space to: \"..\/includes\/free spaces.shp\" format:\"shp\";\n\t}\n}\n\nspecies pedestrian_path skills: [pedestrian_road]{\n\trgb color <- rnd_color(255);\n\taspect default {\n\t\tdraw shape  color: color;\n\t}\n\taspect free_area_aspect {\n\t\tif(display_free_space and free_space != nil) {\n\t\t\tdraw free_space color: #cyan border: #black;\n\t\t}\n\t}\n}\n\nspecies wall {\n\taspect default {\n\t\tdraw shape + (P_shoulder_length\/2.0) color: #gray border: #black;\n\t}\n}\n\nexperiment normal_sim type: gui {\n\t\toutput {\n\t\tdisplay map type: 3d{\n\t\t\tspecies wall refresh: false;\n\t\t\tgraphics \"open_area\" {\n\t\t\t\tdraw open_area color: #lightpink;\n\t\t\t}\n\t\t\tspecies pedestrian_path aspect:free_area_aspect transparency: 0.5 ;\n\t\t\tspecies pedestrian_path refresh: false;\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Create complete model which imports a shapefile of contour lines, build triangles from these contour lines, compute their elevation by using the elevation attribute of the contour lines which had been linked to the elevation column of the shapefile.",
        "output": "model contour_lines_import\n\nglobal {\n\t\/\/the contour lines shapefile\n\tfile shape_file_cl <- file('..\/includes\/contourLines.shp') ;\n\t\n\t\/\/define the size of the world from the countour line shapefile\n\tgeometry shape <- envelope(shape_file_cl);\n\t\n\tinit {\n\t\t\/\/create the contour line agents from the shapefile, and init the elevation for each agent\n\t\tcreate contour_line from: shape_file_cl with: [elevation:: float(read(\"ELEVATION\"))];\n\t\t\n\t\t\/\/triangulate the contour lines\n\t\tlist<geometry> triangles  <- triangulate (list(contour_line));\n\t\t\n\t\t\/\/for each triangle geometry, create a triangle_ag agent and compute the elevation of each of its points (and modified their z value)\n\t\tloop tr over: triangles {\n\t\t\tcreate triangle_ag {\n\t\t\t\tshape <- tr;\n\t\t\t\tloop i from: 0 to: length(shape.points) - 1{ \n\t\t\t\t\tfloat val <- (contour_line closest_to (shape.points at i)).elevation;\n\t\t\t\t\tshape <- shape set_z (i,val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n}\n\nspecies contour_line {\n\tfloat elevation;\n\taspect default {\n\t\tdraw shape color: #red depth: 30 at: {location.x,location.y, elevation}; \n\t}\n}\nspecies triangle_ag {\n\taspect default {\n\t\tdraw shape color: #grey ; \n\t}\n}\n\n\nexperiment contour_lines_import type: gui {\n\toutput {\n\t\tdisplay map type: 3d {\n\t\t\tcamera 'default' location: {4341.8834,20215.2668,9585.3894} target: {5500.0,5500.0,0.0};\n\t\t\tspecies triangle_ag refresh: false;\n\t\t\tspecies contour_line refresh: false;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Create a complete model which shows how to initialize a grid using a ESRI ASCII file.",
        "output": "model ascimport\n\nglobal {\n\t\/\/definiton of the file to import\n\tfile grid_data <- file('..\/includes\/hab10.asc') ;\n\t\n\t\/\/computation of the environment size from the geotiff file\n\tgeometry shape <- envelope(grid_data);\t\n}\n\n\n\n\/\/definition of the grid from the asc file: the width and height of the grid are directly read from the asc file. The values of the asc file are stored in the grid_value attribute of the cells.\ngrid cell file: grid_data{\n\tinit {\n\t\tcolor<- grid_value = 0.0 ? #black  : (grid_value = 1.0  ? #green :   #yellow);\n\t}\n}\n\nexperiment gridloading type: gui {\n\toutput {\n\t\tdisplay \"As DEM\" type: 3d axes:false{\n\t\t\tgrid cell border: #gray elevation: self.grid_value * 300 ;\n\t\t}\n\t\t\n\t\tdisplay \"As 2D grid\"  type: 2d {\n\t\t\tgrid cell border: #black;\n\t\t}\n\t} \n}\n"
    },
    {
        "instruction": "Create grid data from ascii file.",
        "output": "file grid_data <- file('..\/includes\/hab10.asc') ;"
    },
    {
        "instruction": "Create complete model that initializes a set of geometries from a GEOJSON FIle.",
        "output": "model geojson_loading   \n\nglobal {\n\tfile geo_file <- geojson_file(\"..\/includes\/countries.geojson\");\n\tgeometry shape <- envelope(geo_file);\n\tinit {\n\t\tcreate countries from: geo_file with: [name::read(\"name\")];\n\t}\n} \n\nspecies countries {\n\trgb color <- rnd_color(255);\n\trgb text_color <- (color.brighter);\n\t\n\tinit {\n\t\tshape <- (simplification(shape,0.01));\n\t}\n\taspect default {\n\t\tdraw shape color: color depth: 10;\n\t\tdraw name font: font(\"Helvetica\", 12 + #zoom, #bold) color: #black at: location + {0,0,12} perspective:false;\n\t}\n}\n\nexperiment Display  type: gui {\n\toutput {\n\t\tdisplay Countries type: 3d{\t\n\t\t\tspecies countries;\t\t\t\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Give me an example GAML function that takes as input a list of laborers and returns the laborer with the highest salary. ",
        "output": "labour getHWLaborer(list<labour> laborers){\n\t\tlaborers <- reverse(sort_by(laborers, each.salary));\n\t\treturn first(laborers);\n\t}\n"
    },
    {
        "instruction": "Create a complete model which shows how to use several grid files to initialize a grid. The elevation file is from a DEM, and the landcover file is from a tif file. ",
        "output": "model importationraster\n\nglobal {\n\t\/\/the two grid files that we are going to use to initialize the grid\n\tfile dem_file <- file(\"..\/includes\/mnt.asc\");\n\tfile land_cover_file <- file(\"..\/includes\/land-cover.tif\");\n\t\n\t\/\/we use the dem file to initialize the world environment\n\tgeometry shape <- envelope(dem_file);\n\t\n\t\/\/map of colors (key: land_use, value: color)  just uses to visualize the different land_use\n\tmap<int,rgb> colors;\n\t\n\tinit {\n\t\t\/\/we set the value of the land_use variable by the second (index = 1) value stored in the bands attribute \n\t\task cell {\n\t\t\tland_use <- int(bands[1]);\n\t\t}\n\t\t\n\t\t\/\/we define a color per land_use and use it to define the color of the cell\n\t\tlist<int> land_uses <- remove_duplicates(cell collect each.land_use);\n\t\tcolors <- land_uses as_map (each::rnd_color(255));\n\t\task cell {\n\t\t\tcolor <- colors[land_use];\n\t\t}\n\t}\n}\n\n\/\/we define the cell grid from the two grid files: the first file (dem_file) will be used as reference for the definition of the grid number of rows and columns and location\n\/\/the value of the files are stored in the bands built-in list attribute: each value of the list corresponds to the value in the file\n\/\/the value of the first file is also stored in thr grid_value built-in variable\ngrid cell files: [dem_file,land_cover_file] {\n\tint land_use;\n}\n\nexperiment importationraster type: gui {\n\toutput {\n\t\tdisplay map type: 3d axes:false antialias:false{\n\t\t\tgrid cell elevation: true  triangulation: true refresh: false;\t\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Assuming I've defined a field called \"heatmap\", create an experiment named \"Show heatmap\" with a GUI type. The output section has a layout of type split. Include a display named 'Heatmap' of type 3D with a black background. Use a mesh to visualize the heatmap data. Ensure that the colors transition smoothly as the values increase by defining a fixed color palette with colors ranging from white to red.",
        "output": "experiment \"Show heatmap\" type: gui {\n\n\t\n\toutput {\n\t\tlayout #split;\n\t\t\n\t\tdisplay Heatmap type: 3d background: #black {\n\t\t\t\/\/ The display is 2D only, and defining a fixed palette makes the color slowly slide as the values increase\n\t\t\tmesh heatmap scale: 0 color: palette([#white, #orange, #red, #red]);\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Create a complete model to vectorize an image and save result into shapefile.",
        "output": "model EscapeTrainingEnvironment\n\nglobal {\n\t\n\t\/*\n\t * How precise the vectorization is\n\t *\/\n\tfloat resolution_factor <- 0.2 parameter:true max:1.0;\n\t \n\t\/*\n\t * Import the image to vectorize\n\t *\/\n\timage_file im <- image_file(\"..\/images\/drawing.png\");\n\t\n\t\/*\n\t * Get the resolution of the image\n\t *\/\n\tint res_x <- int(envelope(im).width);\n\tint res_y <- int(envelope(im).height);\n\t\n\t\/*\n\t * \n\t * Adapt the underlying grid to vectorize and the shape of the world\n\t * according to image resolution and the ratio of vectorization\n\t * \n\t *\/\n\tint g_x <- int(res_x * resolution_factor);\n\tint g_y <- int(res_y * resolution_factor);\t\n\tgeometry shape <- rectangle(res_x,res_y);\n\t\n\t\/*\n\t * The color and associated species\n\t * WARNING: Model specific\n\t *\/\n\tmap<rgb,string> color_to_species <- [\n\t\t#brown::string(ground),#blue::string(water),#yellow::string(beach),\n\t\t#green::string(tree),#gray::string(building)\n\t];\n\t\n\tinit {\n\t\tfloat t <- machine_time;\n\t\t\n\t\twrite \"START CREATION OF THE ENVIRONMENT\";\n\t\t\n\t\twrite \"Image resolution : \"+string(res_x)+\" x \"+string(res_y);\n\t\t\n\t\t\/*\n\t\t * Manage resolution ratio\n\t\t *\/\n\t\tfloat factorDiscret_width <- res_y \/ g_y;\n\t\tfloat factorDiscret_height <- res_x \/ g_x;\n\t\task cell {\t\t\n\t\t\tcolor <-rgb( (im) at {grid_x * factorDiscret_height,grid_y * factorDiscret_width}) ;\n\t\t}\n\t\t\n\t\t\/*\n\t\t * Find the different color in the image\n\t\t *\/\n\t\tmap<rgb, list<cell>> cells_per_color <- cell group_by each.color;\n\t\t\n\t\twrite \"Found \"+length(cells_per_color)+\" color in the draw\";\n\t\t\n\t\t\/*\n\t\t * Loop over all colors and match them with proper species\n\t\t *\/\n\t\tloop col over: cells_per_color.keys {\n\t\t\tgeometry geom <- union(cells_per_color[col]) + 0.001;\n\t\t\tif (geom != nil) {\n\t\t\t\t\n\t\t\t\twrite \"--------\";\n\t\t\t\trgb best_match;\n\t\t\t\tlist bm <- [255,255,255];\n\t\t\t\tloop cl over:color_to_species.keys {\n\t\t\t\t\tint r <- abs(cl.red-col.red);\n\t\t\t\t\tint g <- abs(cl.green-col.green);\n\t\t\t\t\tint b <- abs(cl.blue-col.blue);\n\t\t\t\t\tif(r+g+b < sum(bm)){\n\t\t\t\t\t\tbest_match <- cl;\n\t\t\t\t\t\tbm <- [r,g,b];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twrite \"Detected color image [\"+string(col)+\"] has been associated to [\"+string(best_match)+\"]\";\n\n\t\t\t\t\/*\n\t\t\t\t * Create the proper species where color have been detected\n\t\t\t\t *\/\n\t\t\t\tstring species_name <- color_to_species[best_match];\n\t\t\t\tswitch species_name {\n\t\t\t\t\tmatch string(water) {\n\t\t\t\t\t\tcreate water from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t\tmatch string(ground) {\n\t\t\t\t\t\tcreate ground from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t\tmatch string(beach) {\n\t\t\t\t\t\tcreate beach from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t\tmatch string(tree) {\n\t\t\t\t\t\tcreate tree from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t\tmatch string(building) {\n\t\t\t\t\t\tcreate building from: geom.geometries;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twrite \"END - TIME ELAPSE: \"+((machine_time-t)\/1000)+\"sec\";\n\t\t\n\t\twrite \"EXPORT TO FILES\";\n\t\tsave water to:\"..\/results\/water_body.shp\" ;\n\t\tsave ground to:\"..\/results\/ground.shp\" ;\n\t\tsave beach to:\"..\/results\/beach.shp\" ;\n\t\tsave tree to:\"..\/results\/trees.shp\" ;\n\t\tsave building to:\"..\/results\/building.shp\" ;\n\t\t\n\t}\n\t\n}\n\ngrid cell  width: g_x height: g_y;\n\nspecies water {\n\taspect default {\n\t\tdraw shape color: #navy border: #black;\n\t}\n}\n\nspecies building {\n\taspect default {\n\t\tdraw shape color: #gray;\n\t}\n}\n\nspecies ground {\n\taspect default {\n\t\tdraw shape color: rgb (128, 64, 3) border: #black;\n\t}\n}\n\nspecies beach {\n\tfloat capacity;\n\taspect default {\n\t\tdraw shape color:#yellow;\n\t}\n}\n\nspecies tree {\n\taspect default {\n\t\tdraw shape border:#black color:#green;\n\t}\n}\n\nexperiment Vectorize type: gui {\n\toutput {\n\t\tdisplay map_vector type:3d axes:false{\n\t\t\tspecies water;\n\t\t\tspecies ground;\n\t\t\tspecies beach;\n\t\t\tspecies tree;\n\t\t\tspecies building;\n\t\t}\n\t\tdisplay image {\n\t\t\timage im;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Create complete model which shows how to import a OSM file in GAMA and use it to create Agents. A filter is used to take only into account the roads and the buildings contained in the file.",
        "output": "model simpleOSMLoading\n\n\nglobal\n{\n\n\/\/map used to filter the object to build from the OSM file according to attributes. for an exhaustive list, see: http:\/\/wiki.openstreetmap.org\/wiki\/Map_Features\n\tmap filtering <- map([\"highway\"::[\"primary\", \"secondary\", \"tertiary\", \"motorway\", \"living_street\", \"residential\", \"unclassified\"], \"building\"::[\"yes\"]]);\n\t\/\/OSM file to load\n\tfile<geometry> osmfile;\n\n\t\/\/compute the size of the environment from the envelope of the OSM file\n\tgeometry shape <- envelope(osmfile);\n\tinit\n\t{\n\t\/\/possibility to load all of the attibutes of the OSM data: for an exhaustive list, see: http:\/\/wiki.openstreetmap.org\/wiki\/Map_Features\n\t\tcreate osm_agent from: osmfile with: [highway_str::string(read(\"highway\")), building_str::string(read(\"building\"))];\n\n\t\t\/\/from the created generic agents, creation of the selected agents\n\t\task osm_agent\n\t\t{\n\t\t\tif (length(shape.points) = 1 and highway_str != nil)\n\t\t\t{\n\t\t\t\tcreate node_agent with: [shape::shape, type:: highway_str];\n\t\t\t} else\n\t\t\t{\n\t\t\t\tif (highway_str != nil)\n\t\t\t\t{\n\t\t\t\t\tcreate road with: [shape::shape, type:: highway_str];\n\t\t\t\t} else if (building_str != nil)\n\t\t\t\t{\n\t\t\t\t\tcreate building with: [shape::shape];\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\/\/do the generic agent die\n\t\t\tdo die;\n\t\t}\n\n\t}\n\n}\n\nspecies osm_agent\n{\n\tstring highway_str;\n\tstring building_str;\n}\n\nspecies road\n{\n\trgb color <- rnd_color(255);\n\tstring type;\n\taspect default\n\t{\n\t\tdraw shape color: color;\n\t}\n\n}\n\nspecies node_agent\n{\n\tstring type;\n\taspect default\n\t{\n\t\tdraw square(3) color: # red;\n\t}\n\n}\n\nspecies building\n{\n\taspect default\n\t{\n\t\tdraw shape color: #grey;\n\t}\n\n}\n\nexperiment \"Load OSM\" type: gui\n{\n\tparameter \"File:\" var: osmfile <- file<geometry> (osm_file(\"..\/includes\/rouen.gz\", filtering));\n\toutput\n\t{\n\t\tdisplay map type: 3d\n\t\t{\n\t\t\tspecies building refresh: false;\n\t\t\tspecies road refresh: false;\n\t\t\tspecies node_agent refresh: false;\n\t\t}\n\n\t}\n\n}\n\nexperiment \"Load OSM from Internet\" type: gui parent: \"Load OSM\"\n{\n\tparameter \"File:\" var: osmfile <- file<geometry> (osm_file(\"http:\/\/download.geofabrik.de\/europe\/andorra-latest.osm.pbf\", filtering));\n\t\n}"
    },
    {
        "instruction": "Create a complete model that initializes a grid from a JSON FIle.",
        "output": "model json_loading   \n\nglobal {\n\tfile JsonFile <- json_file(\"..\/includes\/cityIO.json\");\n    map<string, unknown> c <- JsonFile.contents;\n\n\tinit { \n\t\tlist<map<string, int>> cells <- c[\"grid\"];\n        loop mm over: cells {                 \n            cityMatrix cell <- cityMatrix grid_at {mm[\"x\"],mm[\"y\"]};\n            cell.type <-int(mm[\"type\"]);\n        }\n\t}  \n} \n\ngrid cityMatrix width:16  height:16{\n\trgb color <- #black;\n\tint type;\n   \taspect base{\t\n    \t\tdraw shape color:rgb(type*30) border:#black ;\n    }\n}\n\nexperiment Display  type: gui {\n\toutput {\n\t\tdisplay cityMatrixView   type: 3d axes:false{\t\n\t\t\tspecies cityMatrix aspect:base;\t\t\t\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "propose a simple architecture for a model to represent agent that exhibit realistic pedestrian movement",
        "output": "global {\n\ncreate myagent with:[mytarget::any_location_in(world.shape)];\n\n}\n\nspecies myagent skills:[pedestrian] {\n\npoint mytarget;\n\nreflex move {\ndo walk_to target:mytarget bounds:free_space;\n}\n\ndraw triangle(1) rotate: heading + 90.0;\n\n}\n\nexperiment xp type:gui {\noutput {\ndisplay main {\nspecies myagent;\n}\n}\n}"
    },
    {
        "instruction": "Create a model that simulates agents with random data values (from 0 to 50) and identifies those exceeding a specific threshold with a variable called 'threshold'.",
        "output": "global\n{\n\tint threshold <- 25;\n\tinit\n\t{\n\t\tcreate agentSpecies number: 10;\n\t\tlet agents5 <- agentSpecies where (each.data > threshold);\n\t}\n}\n\nspecies agentSpecies\n{\n\tint data;\n\t\n\tinit\n\t{\n\t\tdata <- rnd(50);\n\t}\n}"
    },
    {
        "instruction": "Write me an action asking for the user to enter an answer to a question related to her age, and that write back the answer and the age of Gama in the console",
        "output": "action ask_age {\nmap  result <- user_input_dialog(\"The question\",[enter(\"What is you age?\", 0.0)]);\nwrite \"Your age is \"+result[\"What is you age?\"];\nwrite \"The Gama platform has \"+date(#now).year-2009+\" years old\";\n}"
    },
    {
        "instruction": "How can I serialize a given agent to JSON ?",
        "output": "string serializedAgent <- serialize(agentToBeSerialized);"
    },
    {
        "instruction": "How can I deserialize an agent from a JSON string ? ",
        "output": "agentDeserialized deseri <- create agentDeserialized from: serializedString;"
    },
    {
        "instruction": "give me the minimal starting model to simulate classical opinion dynamic model based on the bounded confidence of agent",
        "output": "global {\n\nfloat delta <- 0.1;\n\ninit {\ncreate myagent number:100 {\n\topinion <- rnd(1.0)*2-1; \n\tconfidence <- 0.2;\n}\t\n}\n\n}\n\nspecies myagent {\nfloat opinion min:-1 max:1;\nfloat confidence min:-1 max:1;\n\nreflex opinion_diffusion {\n\task any(myagent-self) { \n\t\tif abs(opinion-myself.opinion) < myself.confidence {\n\t\t\tmyself.opinion <- myself.opinion * (1-delta) + opinion * (delta); \n\t\t}\n\t}\n}\n\n}\n\nexperiment xp {\n\toutput {\n\t\tdisplay op {\n\t\t\tchart \"opinion_chart\" type:series {\n\t\t\t\tloop a over:myagent { data string(a) value:a.opinion; }\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Generate me a species of grid with theses properties :\n\nEach square can be either alive or dead. This world follows simple rules to decide which cell stay alive and which die in the next turn.\n\n    If a filled cell has fewer than 2 or more than 3 filled neighbors, it die in the next turn\n\n    If an empty square has exactly 3 filled neighbors, it becomes filled in the next turn. \n\nStarting with any arrangement of filled and empty squares, these rules are applied to every square at the same time, creating a new pattern for the next turn.\n\nThe size of the grid is given by two variables : environment_width  and environment_height. Each cell have maximum 8 neighbors. At init, a cell is alive in 20% of the cases.",
        "output": "grid life_cell width: environment_width height: environment_height neighbors: 8 {\n\tbool new_state;\n\tlist<life_cell> neighbours <- self neighbors_at 1;\n\tbool alive <- (rnd(100)) < 80;\n\t\n\trgb color <- alive ? livingcolor : deadcolor;\n\t\n\taction evolve {\n\t\tint living <- neighbours count each.alive;\n\t\tif alive {\n\t\t\tnew_state <- living in living_conditions;\n\t\t\tcolor <- new_state ? livingcolor : dyingcolor;\n\t\t} else {\n\t\t\tnew_state <- living in birth_conditions;\n\t\t\tcolor <- new_state ? emergingcolor : deadcolor;\n\t\t}\n\n\t}\n\treflex update {\n\t\talive <- new_state;\n\t}\n\n}"
    },
    {
        "instruction": "Generates a model of social influence, in which 1000 \"people\" agents have an opinion between 0 and 1 and are influenced by other agents - at each stage of the simulation, their opinion moves closer to that of another agent if their opinions are not too far apart. ",
        "output": "\/**\n* Name: BoundedConfidence\n* Model proposed in Deffuant, G., Neau, D., Amblard, F., & Weisbuch, G. (2000). Mixing beliefs among interacting agents. Advances in Complex Systems, 3(01n04), 87-98. \n* Tags: social influence, bounded conficence\n*\/\n\nmodel BoundedConfidence\n\nglobal {\n\tfloat mu <- 0.5; \/\/convergence parameter\n\tfloat d <- 0.5; \/\/openness to discussion\n\t\n\tinit {\n\t\tcreate people number: 100;\n\t}\n\t\n}\n\nspecies people {\n\tfloat opinion <- rnd(1.0);\n\t\n\treflex interaction {\n\t\task one_of (people - self) {\n\t\t\tif abs(opinion - myself.opinion) < d {\n\t\t\t\topinion <- opinion + mu * (myself.opinion - opinion);\n\t\t\t\tmyself.opinion <- myself.opinion + mu * (opinion - myself.opinion);\n\t\t\t} \n\t\t}\n\t}\n}\n\nexperiment run type: gui {\n\toutput {\n\t\tdisplay opinion_evolution {\n\t\t\tchart \"opinion evolution\" {\n\t\t\t\tloop p over: people {\n\t\t\t\t\tdata string(int(p)) value: p.opinion;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Generates a fire propagation model on a grid. At each time step, a cell on fire has a probability of 0.2 of igniting a cell in its neighborhood that has never been on fire, and a cell on fire takes 5 time steps to be no longer on fire. ",
        "output": "\nmodel fire_spreading\n\nglobal {\n\tint fire_time <- 5;\n\tfloat proba_fire <- 0.2;\n\t\n\tinit {\n\t\task cell(location) {\n\t\t\tdo to_fire;\n\t\t}\n\t}\n}\n\ngrid cell width: 50 height: 50 schedules: cell where each.on_fire{\n\tbool on_fire <- false;\n\tint fire_counter;\n\t\n\taction to_fire {\n\t\ton_fire <- true;\n\t\tcolor <- #red;\n\t\tfire_counter <- fire_time;\n\t}\n\t\n\treflex spread when: on_fire {\n\t\task neighbors where (each.color = #white){\n\t\t\tif flip(proba_fire) {\n\t\t\t\tdo to_fire;\n\t\t\t}\n\t\t}\n\t\tfire_counter <- fire_counter - 1;\n\t\t\n\t}\n\t\n\treflex end_of_fire when: on_fire and fire_counter = 0{\n\t\ton_fire <- false;\n\t\tcolor <- #gray;\n\t}\n}\n\nexperiment fire type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tgrid cell border: #black;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Code a model that simulate the international aircraft trafic ",
        "output": "\/**\n* Name: NewModel2\n* Based on the internal empty template. \n* Author: kevinchapuis\n* Tags: \n*\/\n\n\nmodel NewModel2\n\nglobal {\n\t\n\tsvg_file planeicon <- svg_file(\"..\/includes\/plane-icon.svg\");\n\n\tshape_file worldmap <- shape_file(\"..\/includes\/worldmap.shp\");\n\tgeometry shape <- envelope(worldmap);\n\t\n\tint maxtripperstep <- 100;\n\n\tinit {\n\t\tcreate country from:worldmap with:[name::get('name')];\n\t\t\n\t\tcsv_file airtripspercapita <- csv_file(\"..\/includes\/air-trips-per-capita.csv\");\n\t\tfloat m <- max(rows_list(matrix(airtripspercapita)) collect (float(last(each))));\n\t\t\n\t\tloop l over:rows_list(matrix(airtripspercapita)) {\n\t\t\tcountry c <- country first_with (first(l)=each.name);\n\t\t\tif c != nil { c.triprob <- float(last(l))\/m; }\n\t\t}\n\n\t}\n\n\n}\n\nspecies aircraft skills:[moving]{\n\tfloat speed <- 800#km\/#h;\n\tpoint destination;\n\treflex travel {\n\t\tdo goto target:destination;\n\t}\n\t\n\taspect default {\n\t\tdraw planeicon size:100#km color:#black rotate:heading+45;\n\t}\n}\n\nspecies country {\n\tfloat triprob <- 0.01;\n\t\n\treflex when:every(10#mn) {\n\t\tcreate aircraft number:rnd(maxtripperstep*triprob) with:[location::any_location_in(self),destination::any(country-self)];\n\t}\n\t\n\taspect default {\n\t\tdraw shape border:#black;\n\t}\n\t\n}\n\nexperiment xp {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies country;\n\t\t\tspecies aircraft;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "Generate a code snippet to load the geotiff file \"\/includes\/bogota_grid.tif\" and use it to initialize the grid cell.",
        "output": "global {\n\t\/\/definiton of the file to import\n\tfile grid_data <- grid_file(\"..\/includes\/bogota_grid.tif\");\n\n\t\/\/computation of the environment size from the geotiff file\n\tgeometry shape <- envelope(grid_data);\t\n\t\n}\n\n\/\/definition of the grid from the geotiff file: the width and height of the grid are directly read from the asc file. The values of the asc file are stored in the grid_value attribute of the cells.\ngrid cell file: grid_data;"
    },
    {
        "instruction": "How to create a field called \"cells\", from an .asc file.",
        "output": "grid_file file_to_load <- grid_file(\"includes\/example_file.asc\");\nfield cells <- field(file_to_load);"
    },
    {
        "instruction": "Generate a code snippet to load the \"\/includes\/hab10.asc\" asc file and to use it to initialize the grid cell.",
        "output": "\nglobal {\n\t\/\/definiton of the file to import\n\tfile grid_data <- file('..\/includes\/hab10.asc') ;\n\t\n\t\/\/computation of the environment size from the arc file\n\tgeometry shape <- envelope(grid_data);\t\n}\n\n\n\n\/\/definition of the grid from the asc file: the width and height of the grid are directly read from the asc file. The values of the asc file are stored in the grid_value attribute of the cells.\ngrid cell file: grid_data;"
    },
    {
        "instruction": "I have declared a field called \"cells\". Create an experiment called ShowCells of type gui. Add a 3d display called \"Texture\", which displays the field with a jpg texture file. Set the borders to black and enable triangulation.",
        "output": "experiment Palettes type: gui {\n\toutput synchronized: true {\n\n\t\tdisplay \"Texture \" type: 3d { \n\t\t\tmesh cells texture: file(\"includes\/Texture.jpg\") triangulation: true border: #black smooth: true;\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
    },
    {
        "instruction": "generate an aspect called obj to display the agent using the my_obj.obj obj file oriented in the direction of the heading of the agent. ",
        "output": "aspect obj {\n\t\t\/\/we draw an obj file in the aspect apply an initial rotation r0 to give the boat the right orientation and apply a composition of rotation (pitch,roll,yaw) and \n\t\t\/\/the location of a obj file is centroid of the bounding box, so we add with the \"at\" facet a translated along the z axis to place the obj on the ground and not inside\n\t\t\/\/the size represents here the max size of the bounding box\n\t\t\/\/at last, we dynamically apply a rotation to the obj to make it head in direction of the heading of the agents. \n\t\tdraw obj_file(\"my_obj.obj\", -90::{1,0,0}) at: location + {0,0,9} size: 5 rotate: heading + 90;\n\t}\t"
    },
    {
        "instruction": "Generate a code snippet to create agents of species my_agents from the \"data.csv\" file reading the \"name\" column to init the name of attribute of the agents and the \"age\" column to init the age attribute of the agents. ",
        "output": "create my_agent from:csv_file( \"data.csv\",true) with:\n\t\t\t[name::string(get(\"name\")), \n\t\t\t\tage::int(get(\"age\"))\n\t\t\t];\t"
    },
    {
        "instruction": "I have defined a field in the global section. Create an experiment named Palettes with two 3d displays called \"Brewer\" and \"Simple gradient\". All the displays use triangulation. The first one uses the set3 from brewers colors. The second one must be a smooth color transition from darkgreen to white. For this latter, the borders of the mesh must be black.\nI want both displays to be displayed at the same time. Moreover, the output must be sychronized with the simulation cycles.",
        "output": "global {\n\tfield my_field <- field(500,500);\n}\n\nexperiment Palettes type: gui {\n\t\/\/ Displays are synchronized with the experiment cycles\n\toutput synchronized: true {\n\t\t\/\/ Allows to display all the displays in the same view\n\t\tlayout #split;\n\t\tdisplay \"Brewer\" type: 3d {\n\t\t\tmesh my_field color:(brewer_colors(\"Set3\")) triangulation: true smooth: true;\n\t\t}\n\n\t\tdisplay \"Simple gradient\" type: 3d { \n\t\t\tmesh my_field color: palette([#darkgreen, #darkgreen, #green, #green, #sienna, #sienna, #white]) triangulation: true border: #black ;\n\t\t\t\n\t\t}\n\t}\n\n}"
    },
    {
        "instruction": "I have defined in the global section the following map: map<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\nI also have an experiment in which I want to add an overlay layer displaying a square for each element in the map color_per_type. Each square must have the color defined in the map, and the name next to them is also the one corresponding to the color.\nThe legend overlay must be at position (5,5) and each square must have a white borde. ",
        "output": "\/\/define a new overlay layer positioned at the coordinate 5,5, with a constant size of 180 pixels per 100 pixels.\n            overlay position: { 5, 5 } size: { 180 #px, 100 #px } background: # black transparency: 0.5 border: #black rounded: true\n            {\n            \t\/\/for each possible type, we draw a square with the corresponding color and we write the name of the type\n                float y <- 30#px;\n                loop type over: color_per_type.keys\n                {\n                    draw square(10#px) at: { 20#px, y } color: color_per_type[type] border: #white;\n                    draw type at: { 40#px, y + 4#px } color: # white font: font(\"Helvetica\", 18, #bold);\n                    y <- y + 25#px;\n                }\n\n            }"
    },
    {
        "instruction": "I have a model called Overlay. In the global section, give the code of a map whith the following key\/value pairs:\n\"water\": #blue\n\"vegetation\": #green\n\"building\": #pink",
        "output": "model Overlay\n\nglobal\n{\n\t\/\/define the color for each possible type (among \"water\", \"vegetation\" and \"building\")\n\tmap<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\n}"
    },
    {
        "instruction": "I have defined a map defined as folows in the global section: map<string,rgb> color_per_type <- [\"water\"::#blue, \"vegetation\":: #green, \"building\":: #pink];\nCode a grid named cell with 10 rows and 10 columns.\nI want each box of the grid to randomly get attributed with one of the colors defined in the color_per_type map.",
        "output": "grid cell width: 10 height: 10 {\n\t\/\/each cell has a random type\n\tstring type <- one_of(color_per_type.keys);\n\trgb color <- color_per_type[type];\n}"
    },
    {
        "instruction": "Create an action named generate to create an realistic random terrain.\nPut the code in the global section.",
        "output": "global {\n\tfield terrain;\n\n\taction generate {\n\t\t\/\/ the generate_terrain operator returns a field where the elevations are between 0 and 1. It can be scaled afterwards.\n\t\tterrain <- generate_terrain(generator_seed, width, height, details, smoothness, scattering);\n\t}\n}"
    },
    {
        "instruction": "In the global section I have a boolean variable called dark_mode. In the experiment section of my model, add a parameter with the title \"Toggle dark mode\", tracking the value of the dark_mode variable.\nProvide the whole architecture of the model.",
        "output": "model my_model\n\nglobal {\n\tbool dark_mode <- false;\n\tinit {\n\t\t\/\/ Put here the init code\n\t}\n}\n\neperiment my_experiment {\n\tparameter \"Toggle dark mode\" var:dark_mode;\n\touptut {\n\t\t\/\/ Put the output code here\n\t}\n}"
    },
    {
        "instruction": "Create a basic species called Animal represented as a 3d red sphere.\nInstanciate it in a basic experiment.",
        "output": "species Animal {\n\t\n\t\/\/ Add here the logic of the species\n\t\n\t\/\/ Define the aspect of the species\n\taspect sphere_aspect {\n\t\tdraw sphere(1.0) color: #red;\n\t}\n}\n\nexperiment my_experiment type: gui {\n\toutput {\n\t\tdisplay basic_display type: 3d {\n\t\t\t\/\/ use the sphere_aspect defined in the Animal species\n\t\t\tspecies Animal aspect: sphere_aspect;\n\t\t}\n\t}\n}"
    },
    {
        "instruction": "I want to create a wizard with 2 fields. The first allows to upload a file from my computer. The other one must be a dropdown menu in which choices are \"circle\" and \"square\".\nName the wizard \"Options\" and add a subtitle \"Choose the simulation options\".\nCreate the wizard in the init statement of the global section.",
        "output": "global {\n\tinit {\n\t\tmap results <-  wizard(\"My wizard\", eval_finish,\n\t\t\t[ \n\t\t\twizard_page(\"Options\",\"Choose the simulation options\" ,[enter(\"file\" , file), choose(\"shape\", string, \"circle\", [\"circle\", \"square\"])], font(\"Helvetica\", 14 , #bold))\n\t\t\t] \n\t\t);\n\t}\n\t\n\tbool eval_finish(map<string,map> input_map) {\n\t\t return input_map[\"Options\"][\"file\"] != nil;\n\t}\n}"
    },
    {
        "instruction": "generate a code snippet to group people agents according to their distance. Two people agents are in the same groups if their distance is lower than max_dist_people",
        "output": "\n    \t\/\/returns a list of lists (i.e. a list of groups, a group is a list of people agents)\n    \tlist<list<people>> clusters <- list<list<people>>(simple_clustering_by_distance(people, max_dist_people));\n        \n       "
    },
    {
        "instruction": "Generate a code snippet to let people agents move at a speed of 10m\/s  following the shortest path towards a target cell on a grid of cells with different weights that depends on the value read from the dem grid file. ",
        "output": "global {\n      map<cell,float> cell_weights;\n      init {\n           cell_weights <- cell as_map (each::each.grid_value);\t\n      }\n}\ngrid cell file: dem ;\n\t  \nspecies people skills: [moving] {\n\tcell target;\n\tfloat speed <- 10.0;\n\t\n        reflex move when: location != target{\n\t\tdo goto (on:cell_weights, target:target, speed:speed, recompute_path: false);\n\t}\n}\n"
    },
    {
        "instruction": "Generate a code snippet to clean network data from the road_shapefile shape file. To clean the network, reconnect the node at a distance of 3m or less, split the line at their intersection and do not reduce the graph to its main connected component. ",
        "output": "\t\/\/clean data, with the given options\n\t\tlist<geometry> clean_lines <-clean_network(road_shapefile.contents,3.0,true,false) ;\n\t\t\n\t"
    },
    {
        "instruction": "generate a snippet to save the \"grid_value\" attribute of the grid cell into an asc file.\n",
        "output": "save cell to:\"..\/results\/grid.asc\";"
    },
    {
        "instruction": "Generate a code snippet in the main experiment to init the simulation with 1000 for values for the agent_number global attribute and red for the agent_color attribute.",
        "output": "\nexperiment main type: gui {\n\t\n\taction _init_ {\n\t\tcreate simulation with:(agent_number:1000, agent_color:#red);\n\t}\n}"
    },
    {
        "instruction": "define a reflex that pauses the simulation when there is no people agents. ",
        "output": "\nglobal {\n\treflex pause_simulation when: empty(people) {\n\t\tdo pause;\n\t}\n}"
    },
    {
        "instruction": "In the following model, add the possibility to click on the map display with the mouse to create a circle_agent agent at location clicked by the user.\n\nmodel simple_event\n\nspecies circle_agent {\n\taspect default {\n\t\tdraw circle(1.0) color: #red;\n\t}\n}\nexperiment main type: gui {\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies circle_agent;\n\t\t}\n\t}\n}\n\n\n",
        "output": "experiment main type: gui {\n\taction create_agent {\n\t\task world {\n\t\t\tcreate circle_agent with:(location: #user_location);\n\t\t}\n\t}\n\toutput {\n\t\tdisplay map {\n\t\t\tspecies circle_agent;\n\t\t\tevent #mouse_down action: create_agent;\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Given this code snippet: \nlabour getLaborer(list<labour> laborers){\n\t\tlaborers <- sort_by(laborers, each.salary);\n\t\treturn first(laborers);\n\t}\nModify it to return the laborer with the highest salary.\n",
        "output": "labour getLWLaborer(list<labour> laborers){\n\t\tlaborers <- sort_by(laborers, each.salary);\n\t\treturn last(laborers);\n\t}\n"
    },
    {
        "instruction": "I want a global environnement that can be manipulated by the user to be smaller, up to 10 meter square, or bigger, up to 200 meter square",
        "output": "global torus: torus_environment {\n\t\/\/Size of the environment\n\tint environment_width <- 100 min: 10 max: 200 parameter:true;\n\tint environment_height <- 100 min: 10 max: 200 parameter:true;\n        geometry shape <- rectangle(environment_width, environment_height);\n}"
    },
    {
        "instruction": "I want the parameter in the global section of this model:\nglobal torus: torus_environment {\n\t\/\/Size of the environment\n\tint environment_width <- 100 min: 10 max: 200 parameter:true;\n\tint environment_height <- 100 min: 10 max: 200 parameter:true;\n        geometry shape <- rectangle(environment_width, environment_height);\n}\nto be moved in an experiment section, and put in a separate tab in the interface called environment",
        "output": "experiment xp type:gui {\n    \tparameter 'Width:' var: environment_width category: 'environment';\n\tparameter 'Height:' var: environment_height category: 'environment';\n}"
    },
    {
        "instruction": "I want to define an agent that describes itself when he is created, using a dedicated action in the init bloc of the species definition",
        "output": "species myagent {\n\n        init {\n\t\tdo description;\n\t}\n\n        action description {\n                 write \"my name is \"+name+\" and I am \"+sample(self); \n        }\n\n}"
    },
    {
        "instruction": "Give me the code of a specific agent, called grid, that represent a regular grid of 50 by 50 cells. Those agent should be executed in parallel and have a boolean state as attribute",
        "output": "grid cell width:50 height:50 neighbors:8 parallel:parallel {\n         bool state;\n}"
    },
    {
        "instruction": "I want to code an agent that notify a global variable when it is killed",
        "output": "species myagent {\n         abort {\n                    myglobalvar <+ self;\n         }\n}"
    },
    {
        "instruction": "Create a road species with with color black.",
        "output": "species road {\n\taspect default {\n\t\tdraw shape color: #black;\n\t}\n}"
    },
    {
        "instruction": "Create a road species with color white.",
        "output": "species road {\n\taspect default {\n\t\tdraw shape color: #white;\n\t}\n}"
    },
    {
        "instruction": "Create a road species with color red.",
        "output": "species road {\n\taspect default {\n\t\tdraw shape color: #red;\n\t}\n}"
    },
    {
        "instruction": "Save my building data to geojson format. The output geojson file should include the ID and TYPE attributes.",
        "output": "save building to:\"..\/results\/buildings.geojson\" format: \"json\" attributes: [\"ID\"::name, \"TYPE\"::self.type];"
    },
    {
        "instruction": "Save my building agent data to shapefile format with the attributes ID and TYPE.",
        "output": "save building to:\"..\/results\/buildings.shp\" format:\"shp\" attributes: [\"ID\":: int(self), \"TYPE\"::type];"
    },
    {
        "instruction": "Create 50 bug agents.",
        "output": "create bug number: 50;"
    },
    {
        "instruction": "code me the block of code that make it possible to prompt the user when the simulation is closed",
        "output": "experiment xp {\n\tabort {\n\t\tdo tell(\"You are now leaving this experiment. Hope you enjoyed it ! \", false);\n\t}\n}"
    },
    {
        "instruction": "Load a building shapefile into the model.",
        "output": "file building_file <- shape_file(\"..\/gis\/init.shp\");"
    },
    {
        "instruction": "Code me a species that is controlled by rules, one first rule called 'a' that has a probability of 0.2 to be triggered each time step and high priority of 10, while the second rule is called 'b' having a higher probability of 0.5 but a lower priority of 1",
        "output": "species agentrulebased control: rules {\n\n\tdo_rule a when: flip(0.2) priority: 10 {\n\t\twrite \"Rule a fired\";\n\t}\n\t\n\tdo_rule b when: flip(0.5) priority: 1 {\n\t\twrite \"Rule b fired\"; \n\t}\n\n}"
    },
    {
        "instruction": "code me a very simple way to control an agent with the 'rules' architecture in Gama, with only one rules and a priority variable defined as an attribute of the agent that is incremented each time the rule is triggered",
        "output": "species myagent control: rules {\n\n        int prio <- 1;\n\n\tdo_rule therule priority: prio {\n\t\tprio <- prio + 1;\n\t}\n\n}"
    },
    {
        "instruction": "Capitalise a string.",
        "output": "string var0 <- capitalize(\"abc\");"
    },
    {
        "instruction": "Get the centroid of the world.",
        "output": "point var0 <- centroid(world);"
    },
    {
        "instruction": "Write me a piece of code that make use of an action within the init of the global section.",
        "output": "global {\n\n\tinit {\n\t\tdo hello_world;\t\t\n        }\n\n        action hello_world{}\n\n}"
    },
    {
        "instruction": "I want to create instances of the species \u201ctrees\u201d with attributes dbh and mh given a shapefile, please give me a code to do that. ",
        "output": "global{\nfile trees_shapefile <- shape_file(\"..\/includes\/Initial_Distribution_Trees.shp\");\ninit {\ncreate trees from: trees_shapefile{\ndbh <- float(read(\"Book2_DBH\"));\nmh <- float(read(\"Book2_MH\"));\t\n}\n}\n}\nspecies trees{\nfloat dbh; \/\/diameter at breast height\n\tfloat mh;\t\/\/merchantable height\n}\n"
    },
    {
        "instruction": "Create a circle of radius 10, with its center at the location {80,30}.",
        "output": "geometry var1 <- circle(10,{80,30}); "
    },
    {
        "instruction": "Find the closest points to a geometry named geom2.",
        "output": "list<point> var0 <- geom1 closest_points_with(geom2);"
    },
    {
        "instruction": "Write me a simple code that uses a boolean condition the user can change during simulation, and that will eventually trigger a message in the console, let's say the message hello world!, when the value is true ",
        "output": "global {\n\t\n\tbool condition1 parameter:true init:true;\n\n        reflex myreflex when:condition1 {\n\t\twrite \"Hello world !\";\n        }\n\n}"
    },
    {
        "instruction": "Multiply each element in a list by 2.",
        "output": "list var0 <- [1,2,4] collect (each *2);"
    },
    {
        "instruction": "Create a complete model with examples creating a wizard.",
        "output": "model Wizard_example\n\nglobal {\n\tinit {\n\t\tmap results <-  wizard(\"My wizard\", eval_finish,\n\t\t\t[ \n\t\t\twizard_page(\"page1\",\"enter info page 1\" ,[enter(\"file\" , file), choose(\"shape\", string, \"circle\", [\"circle\", \"square\"])], font(\"Helvetica\", 14 , #bold)),\n\t\t\twizard_page(\"page2\",\"enter info page 2\" ,[enter(\"var2\",string), enter(\"to consider\", bool, true)], font(\"Arial\", 10 , #bold))\n\t\t\t] \n\t\t);\n\t\twrite sample(results);  \n\t}\n\t\n\tbool eval_finish(map<string,map> input_map) {\n\t\t return input_map[\"page1\"][\"file\"] != nil;\n\t}\n}\n\nexperiment Wizard_example type: gui ;"
    },
    {
        "instruction": "Given this code snippet: \nlabour getLaborer(list<labour> laborers){\n\t\tlaborers <- sort_by(laborers, each.salary);\n\t\treturn first(laborers);\n\t}\nModify it to return the laborer with the highest salary.\n",
        "output": "labour getLaborer(list<labour> laborers){\n\t\tlaborers <- reverse(sort_by(laborers, each.salary));\n\t\treturn first(laborers);\n\t}\n"
    },
    {
        "instruction": "Modify the simulation step variable to 1 hour.",
        "output": "global {\n    float step <- 1 #hour;\n}"
    },
    {
        "instruction": "Add a wandering reflex to an agent.",
        "output": "reflex wandering {\n\t\tdo wander;\n\t}"
    },
    {
        "instruction": "Create a complete model for a boat moving on water.",
        "output": "model Moving3Dobject\n\nglobal {\n\t\n\tinit { \n\t\tcreate boat;\n\t}  \n} \n\nspecies boat skills: [moving]{\n\tpoint target <- any_location_in(world);\n\treflex move {\n\t\tdo goto target: target speed:0.5;\n\t\tif (target = location) {\n\t\t\ttarget <- any_location_in(world);\n\t\t}\t\n\t}\n\taspect obj {\n\t\t\/\/we draw an obj file in the aspect apply an initial rotation r0 to give the boat the right orientation and apply a composition of rotation (pitch,roll,yaw) and \n\t\t\/\/the location of a obj file is centroid of the bounding box, so we add with the \"at\" facet a translated along the z axis to place the boat on the water and not inside\n\t\t\/\/the size represents here the max size of the bounding box\n\t\t\/\/at last, we dynamically apply a rotation to the boat to make it head in direction of the heading of the agents. \n\t\tpair<float,point> r0 <-  -90::{1,0,0};\t\n\t\tpair<float,point> pitch <-  5 * cos(cycle*10) ::{1,0,0};\n\t\tpair<float,point> roll <- 20*sin(cycle*3)::{0,1,0};\n\t\tpair<float,point> yaw <- 1*sin(cycle*7)::{0,0,1};\n\t\tdraw obj_file(\"..\/includes\/boat\/fishing-boat.obj\", rotation_composition(r0,pitch,roll,yaw)) at: location + {0,0,9} size: 5 rotate: heading + 90;\n\t}\t\n}\t\n\n\nexperiment Display  type: gui {\n\toutput synchronized: true {\n\t\tdisplay ComplexObject type: 3d background: #black axes:false{\n\t\t\tcamera 'default' location: {-34.826,115.0892,54.4789} target: {50.0,50.0,0.0};\n\t\t\tlight #ambient intensity: 100;\n\t\t\tspecies boat aspect:obj;\t\n\t\t\tgraphics world transparency: 0.4 { \n\t\t\t\tdraw world depth: 5 texture:(\"..\/images\/water.gif\") ;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    {
        "instruction": "Tell the agent to move towards a target with a speed of 0.5.",
        "output": "do goto target: target speed:0.5;"
    },
    {
        "instruction": "Define the target location to be any location in the world.",
        "output": "target <- any_location_in(world);"
    },
    {
        "instruction": "Create a sphere species with attributes color and size.",
        "output": "species sphere_species {\n\trgb color;\n\tfloat size;\n\n\taspect base {\n\t\tdraw sphere(size) color: color;\n\t}\n\n}"
    },
    {
        "instruction": "Create a cube species with specific color and size.",
        "output": "species cube_species {\n\trgb color;\n\tfloat size;\n\n\taspect base {\n\t\tdraw cube(size) color: color;\n\t}\n\n}"
    },
    {
        "instruction": "Create a cylinder species with color and size. It should appeal fallen over on the surface. ",
        "output": "species cylinder_species {\n\trgb color;\n\tfloat size;\n\n\taspect base {\n\t\tdraw cone3D(size, size * 2) rotated_by (90, {1, 0, 0}) color: color;\n\t}\n\n}\n"
    },
    {
        "instruction": "Create a board species with the texture of wood. ",
        "output": "species board {\n\n\n\taspect base {\n\t\tdraw rectangle(100, 100) texture: \"..\/includes\/wood.jpg\";\n\t\tdraw rectangle(100, 10) at: {50, 5} depth: 10 texture: \"..\/includes\/wood.jpg\";\n\t\tdraw rectangle(100, 10) at: {50, 95} depth: 10 texture: \"..\/includes\/wood.jpg\";\n\t\tdraw rectangle(10, 100) at: {5, 50} depth: 10 texture: \"..\/includes\/wood.jpg\";\n\t\tdraw rectangle(10, 100) at: {95, 50} depth: 10 texture: \"..\/includes\/wood.jpg\";\n\t}\n\n}"
    },
    {
        "instruction": "Given a list of data values. Get the mean of the list and write it to the console. ",
        "output": "list data <- [1,2,3,4,5,6,7,10,20,100];\nwrite \"mean: \" + mean(data);"
    },
    {
        "instruction": "Given a list of data values. Get the mean devacion of the list and write it to the console.",
        "output": "list data <- [1,2,3,4,5,6,7,10,20,100];\nwrite \"mean_deviation: \" + mean_deviation(data);"
    },
    {
        "instruction": "Given two lists, l1 and l2, calculate dynamic time warping comparing the two lists. Write the results to the console.",
        "output": "list<float> l1 <- [10.0,5.0,1.0, 3.0, 4.0, 7.5, 1.0,10.0,5.0,1.0];\n\t\tlist<float> l2 <- [1.0,1.0,15.0,1.0,1.0, 3.0, 4.0, 7.5];\n\t\twrite \"Dynamic Time Warping: \" + dtw(l1,l2);"
    },
    {
        "instruction": "Given two lists, l1 and l2, calculate dynamic time warping with radius 2, comparing the two lists. Write the results to the console.",
        "output": "list<float> l1 <- [10.0,5.0,1.0, 3.0, 4.0, 7.5, 1.0,10.0,5.0,1.0];\n\t\tlist<float> l2 <- [1.0,1.0,15.0,1.0,1.0, 3.0, 4.0, 7.5];\nwrite \"Dynamic Time Warping with a radius of 2: \" + dtw(l1,l2,2);"
    },
    {
        "instruction": "Given two lists, l1 and l2, calculate dynamic time warping with a radius of 2, comparing the two lists. Write the results to the console.",
        "output": "list<float> l1 <- [10.0,5.0,1.0, 3.0, 4.0, 7.5, 1.0,10.0,5.0,1.0];\n\t\tlist<float> l2 <- [1.0,1.0,15.0,1.0,1.0, 3.0, 4.0, 7.5];\n\n\t\twrite \"Dynamic Time Warping with a radius of 2: \" + dtw(l1,l2,2);\t"
    },
    {
        "instruction": "How can i load a tiff file in GAMA? ",
        "output": "grid_file dem_file <- grid_file(\"..\/includes\/DEM\/dem_500x500_align.tif\");"
    },
    {
        "instruction": "Declare an attribute nb_people that counts at every cyle the number of people at a distance 1 from the agent.",
        "output": "int nb_people <- 0 update: length(people at_distance 1);"
    },
    {
        "instruction": "Prepare the grid and field layers for volcano visualisation. Load an ascii file \"vulcano_50.asc\" as a grid file named volcano. Then create a field named cells from this volcano grid. ",
        "output": "grid_file volcano <- grid_file(\"includes\/vulcano_50.asc\");\n\tfield cells <- field(volcano);"
    },
    {
        "instruction": "Create a datalist_bar 2d chart of type histogram, where the x values are the cycles and two functions respectively which are (sin(100*cycle) +  1) * cycle\/2  and (sin(100*(cycle+30)) + 1) * cycle\/2. The colors of the bar are green, black and purple respectively. The names of the each bar are \"cycle\",\"cosinus normalized\" and \"offsetted cosinus normalized respectively.",
        "output": "display \"datalist_bar_cchart\" type:2d {\n\t\t\tchart \"datalist_bar\" type:histogram \n\t\t\tseries_label_position: onchart\n\t\t\t{\n\t\t\t\tdatalist legend:[\"cycle\",\"cosinus normalized\",\"offsetted cosinus normalized\"] \n\t\t\t\t\tstyle: bar\n\t\t\t\t\tvalue:[cycle,(sin(100*cycle) +  1) * cycle\/2,(sin(100*(cycle+30)) + 1) * cycle\/2] \n\t\t\t\t\tcolor:[#green,#black,#purple];\n\t\t\t}\n\t\t}"
    },
    {
        "instruction": "Create a series chart for two variables named coslist and sinlist. Each will be drawn as a line, and colored blue and red respectively.",
        "output": "chart \"Long series values\" type: series x_label: \"#points to draw at each step\" memorize: false {\n\t\t\t\tdata \"Cosinus\" value: coslist color: #blue marker: false style: line;\n\t\t\t\tdata \"Sinus\" value: sinlist color: #red marker: false style: line;\n\t\t\t}"
    },
    {
        "instruction": "Create a minimal but complete model to use the BDI architecture. The agent will have to write \"Hello World\" on the console. The model will have three sections, a global block where the species will be created, a species section where the species parameters are specified and initialised. This will also contain the predicates and the plan of the bdi agent. An experiment section will print the output to the gui. ",
        "output": "model HelloWorldBDI\n\nglobal {\n\tinit {\n\t\tcreate bdi_species;\n\t}\n}\n\n\/\/add the simple_bdi architecture to the agents\nspecies bdi_species control: simple_bdi {\n\t\n\t\/\/define a new predicate that will be used as a desire\n\tpredicate saying_hello_desire <- new_predicate(\"say hello\");\n\t\n\t\/\/at init, add the saying_hello_desire to the agent desire base\n\tinit {\n\t\tdo add_desire(saying_hello_desire);\n\t}\n\t\n\t\/\/definition of a plan that allow to fulfill the  saying_hello_desire intention\n\tplan saying_hello intention: saying_hello_desire{\n\t\twrite \"Hello World!\";\n\t}\n}\n\nexperiment HelloWorldBDI type: gui ;"
    },
    {
        "instruction": "How do I add a width of 10#m to a shape? ",
        "output": "draw shape width:10#m;"
    },
    {
        "instruction": "I want to create a building species and be able to draw it with a specific height at a specific location with a specific color ",
        "output": "species building{\n\tfloat height;\n\trgb color;\n\n\taspect base{\n\t  draw shape depth:height at:location color:color;\n\t}\n}\n"
    },
    {
        "instruction": "Can I place a layer in my display at a specific position? ",
        "output": "species people aspect:base position:{x,y,z};"
    },
    {
        "instruction": "How can I be sure that my display are synchronized with the simulation? ",
        "output": "experiment demo type: gui {\n  output synchronized:true{\n  }\n}"
    },
    {
        "instruction": "How can i be sure that my camera doesn't move in my simulation? ",
        "output": "display \"myDisplay\"{\n  camera \"fixed\" locked: true; \n}"
    },
    {
        "instruction": "How can I draw the trajectory of my agent ? ",
        "output": "species people aspect:base trace:true;"
    }
]